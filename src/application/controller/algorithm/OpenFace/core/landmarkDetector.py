# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_landmarkDetector')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_landmarkDetector')
    _landmarkDetector = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_landmarkDetector', [dirname(__file__)])
        except ImportError:
            import _landmarkDetector
            return _landmarkDetector
        try:
            _mod = imp.load_module('_landmarkDetector', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _landmarkDetector = swig_import_helper()
    del swig_import_helper
else:
    import _landmarkDetector
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    # import __builtin__
    pass


def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        if _newclass:
            object.__setattr__(self, name, value)
        else:
            self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except __builtin__.Exception:
    class _object:
        pass
    _newclass = 0


import sys as _sys
if _sys.byteorder == 'little':
    _cv_numpy_endianess = '<'
else:
    _cv_numpy_endianess = '>'

_cv_numpy_typestr_map = {}
_cv_numpy_bla = {}

CV_VERSION_MAJOR = _landmarkDetector.CV_VERSION_MAJOR
CV_VERSION_MINOR = _landmarkDetector.CV_VERSION_MINOR
CV_VERSION_REVISION = _landmarkDetector.CV_VERSION_REVISION
CV_VERSION_STATUS = _landmarkDetector.CV_VERSION_STATUS
CV_VERSION = _landmarkDetector.CV_VERSION
CV_MAJOR_VERSION = _landmarkDetector.CV_MAJOR_VERSION
CV_MINOR_VERSION = _landmarkDetector.CV_MINOR_VERSION
CV_SUBMINOR_VERSION = _landmarkDetector.CV_SUBMINOR_VERSION
class DataType_bool(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, DataType_bool, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, DataType_bool, name)
    __repr__ = _swig_repr
    generic_type = _landmarkDetector.DataType_bool_generic_type
    channels = _landmarkDetector.DataType_bool_channels
    fmt = _landmarkDetector.DataType_bool_fmt

    def __init__(self):
        this = _landmarkDetector.new_DataType_bool()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _landmarkDetector.delete_DataType_bool
    __del__ = lambda self: None
DataType_bool_swigregister = _landmarkDetector.DataType_bool_swigregister
DataType_bool_swigregister(DataType_bool)

class DataType_uchar(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, DataType_uchar, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, DataType_uchar, name)
    __repr__ = _swig_repr
    generic_type = _landmarkDetector.DataType_uchar_generic_type
    channels = _landmarkDetector.DataType_uchar_channels
    fmt = _landmarkDetector.DataType_uchar_fmt

    def __init__(self):
        this = _landmarkDetector.new_DataType_uchar()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _landmarkDetector.delete_DataType_uchar
    __del__ = lambda self: None
DataType_uchar_swigregister = _landmarkDetector.DataType_uchar_swigregister
DataType_uchar_swigregister(DataType_uchar)

class DataType_schar(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, DataType_schar, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, DataType_schar, name)
    __repr__ = _swig_repr
    generic_type = _landmarkDetector.DataType_schar_generic_type
    channels = _landmarkDetector.DataType_schar_channels
    fmt = _landmarkDetector.DataType_schar_fmt

    def __init__(self):
        this = _landmarkDetector.new_DataType_schar()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _landmarkDetector.delete_DataType_schar
    __del__ = lambda self: None
DataType_schar_swigregister = _landmarkDetector.DataType_schar_swigregister
DataType_schar_swigregister(DataType_schar)

class DataType_char(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, DataType_char, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, DataType_char, name)
    __repr__ = _swig_repr
    generic_type = _landmarkDetector.DataType_char_generic_type
    channels = _landmarkDetector.DataType_char_channels
    fmt = _landmarkDetector.DataType_char_fmt

    def __init__(self):
        this = _landmarkDetector.new_DataType_char()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _landmarkDetector.delete_DataType_char
    __del__ = lambda self: None
DataType_char_swigregister = _landmarkDetector.DataType_char_swigregister
DataType_char_swigregister(DataType_char)

class DataType_ushort(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, DataType_ushort, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, DataType_ushort, name)
    __repr__ = _swig_repr
    generic_type = _landmarkDetector.DataType_ushort_generic_type
    channels = _landmarkDetector.DataType_ushort_channels
    fmt = _landmarkDetector.DataType_ushort_fmt

    def __init__(self):
        this = _landmarkDetector.new_DataType_ushort()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _landmarkDetector.delete_DataType_ushort
    __del__ = lambda self: None
DataType_ushort_swigregister = _landmarkDetector.DataType_ushort_swigregister
DataType_ushort_swigregister(DataType_ushort)

class DataType_short(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, DataType_short, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, DataType_short, name)
    __repr__ = _swig_repr
    generic_type = _landmarkDetector.DataType_short_generic_type
    channels = _landmarkDetector.DataType_short_channels
    fmt = _landmarkDetector.DataType_short_fmt

    def __init__(self):
        this = _landmarkDetector.new_DataType_short()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _landmarkDetector.delete_DataType_short
    __del__ = lambda self: None
DataType_short_swigregister = _landmarkDetector.DataType_short_swigregister
DataType_short_swigregister(DataType_short)

class DataType_int(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, DataType_int, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, DataType_int, name)
    __repr__ = _swig_repr
    generic_type = _landmarkDetector.DataType_int_generic_type
    channels = _landmarkDetector.DataType_int_channels
    fmt = _landmarkDetector.DataType_int_fmt

    def __init__(self):
        this = _landmarkDetector.new_DataType_int()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _landmarkDetector.delete_DataType_int
    __del__ = lambda self: None
DataType_int_swigregister = _landmarkDetector.DataType_int_swigregister
DataType_int_swigregister(DataType_int)

class DataType_float(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, DataType_float, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, DataType_float, name)
    __repr__ = _swig_repr
    generic_type = _landmarkDetector.DataType_float_generic_type
    channels = _landmarkDetector.DataType_float_channels
    fmt = _landmarkDetector.DataType_float_fmt

    def __init__(self):
        this = _landmarkDetector.new_DataType_float()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _landmarkDetector.delete_DataType_float
    __del__ = lambda self: None
DataType_float_swigregister = _landmarkDetector.DataType_float_swigregister
DataType_float_swigregister(DataType_float)

class DataType_double(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, DataType_double, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, DataType_double, name)
    __repr__ = _swig_repr
    generic_type = _landmarkDetector.DataType_double_generic_type
    channels = _landmarkDetector.DataType_double_channels
    fmt = _landmarkDetector.DataType_double_fmt

    def __init__(self):
        this = _landmarkDetector.new_DataType_double()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _landmarkDetector.delete_DataType_double
    __del__ = lambda self: None
DataType_double_swigregister = _landmarkDetector.DataType_double_swigregister
DataType_double_swigregister(DataType_double)

class Range(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Range, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Range, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _landmarkDetector.new_Range(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def size(self):
        return _landmarkDetector.Range_size(self)

    def empty(self):
        return _landmarkDetector.Range_empty(self)
    if _newclass:
        all = staticmethod(_landmarkDetector.Range_all)
    else:
        all = _landmarkDetector.Range_all
    __swig_setmethods__["start"] = _landmarkDetector.Range_start_set
    __swig_getmethods__["start"] = _landmarkDetector.Range_start_get
    if _newclass:
        start = _swig_property(_landmarkDetector.Range_start_get, _landmarkDetector.Range_start_set)
    __swig_setmethods__["end"] = _landmarkDetector.Range_end_set
    __swig_getmethods__["end"] = _landmarkDetector.Range_end_get
    if _newclass:
        end = _swig_property(_landmarkDetector.Range_end_get, _landmarkDetector.Range_end_set)
    __swig_destroy__ = _landmarkDetector.delete_Range
    __del__ = lambda self: None
Range_swigregister = _landmarkDetector.Range_swigregister
Range_swigregister(Range)

def Range_all():
    return _landmarkDetector.Range_all()
Range_all = _landmarkDetector.Range_all

class SwigPyIterator(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SwigPyIterator, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SwigPyIterator, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _landmarkDetector.delete_SwigPyIterator
    __del__ = lambda self: None

    def value(self):
        return _landmarkDetector.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _landmarkDetector.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _landmarkDetector.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _landmarkDetector.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _landmarkDetector.SwigPyIterator_equal(self, x)

    def copy(self):
        return _landmarkDetector.SwigPyIterator_copy(self)

    def next(self):
        return _landmarkDetector.SwigPyIterator_next(self)

    def __next__(self):
        return _landmarkDetector.SwigPyIterator___next__(self)

    def previous(self):
        return _landmarkDetector.SwigPyIterator_previous(self)

    def advance(self, n):
        return _landmarkDetector.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _landmarkDetector.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _landmarkDetector.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _landmarkDetector.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _landmarkDetector.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _landmarkDetector.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _landmarkDetector.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _landmarkDetector.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)


_array_map = {}

class Matx_AddOp(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Matx_AddOp, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Matx_AddOp, name)
    __repr__ = _swig_repr

    def __init__(self):
        this = _landmarkDetector.new_Matx_AddOp()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _landmarkDetector.delete_Matx_AddOp
    __del__ = lambda self: None
Matx_AddOp_swigregister = _landmarkDetector.Matx_AddOp_swigregister
Matx_AddOp_swigregister(Matx_AddOp)

class Matx_SubOp(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Matx_SubOp, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Matx_SubOp, name)
    __repr__ = _swig_repr

    def __init__(self):
        this = _landmarkDetector.new_Matx_SubOp()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _landmarkDetector.delete_Matx_SubOp
    __del__ = lambda self: None
Matx_SubOp_swigregister = _landmarkDetector.Matx_SubOp_swigregister
Matx_SubOp_swigregister(Matx_SubOp)

class Matx_ScaleOp(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Matx_ScaleOp, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Matx_ScaleOp, name)
    __repr__ = _swig_repr

    def __init__(self):
        this = _landmarkDetector.new_Matx_ScaleOp()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _landmarkDetector.delete_Matx_ScaleOp
    __del__ = lambda self: None
Matx_ScaleOp_swigregister = _landmarkDetector.Matx_ScaleOp_swigregister
Matx_ScaleOp_swigregister(Matx_ScaleOp)

class Matx_MulOp(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Matx_MulOp, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Matx_MulOp, name)
    __repr__ = _swig_repr

    def __init__(self):
        this = _landmarkDetector.new_Matx_MulOp()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _landmarkDetector.delete_Matx_MulOp
    __del__ = lambda self: None
Matx_MulOp_swigregister = _landmarkDetector.Matx_MulOp_swigregister
Matx_MulOp_swigregister(Matx_MulOp)

class Matx_DivOp(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Matx_DivOp, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Matx_DivOp, name)
    __repr__ = _swig_repr

    def __init__(self):
        this = _landmarkDetector.new_Matx_DivOp()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _landmarkDetector.delete_Matx_DivOp
    __del__ = lambda self: None
Matx_DivOp_swigregister = _landmarkDetector.Matx_DivOp_swigregister
Matx_DivOp_swigregister(Matx_DivOp)

class Matx_MatMulOp(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Matx_MatMulOp, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Matx_MatMulOp, name)
    __repr__ = _swig_repr

    def __init__(self):
        this = _landmarkDetector.new_Matx_MatMulOp()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _landmarkDetector.delete_Matx_MatMulOp
    __del__ = lambda self: None
Matx_MatMulOp_swigregister = _landmarkDetector.Matx_MatMulOp_swigregister
Matx_MatMulOp_swigregister(Matx_MatMulOp)

class Matx_TOp(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Matx_TOp, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Matx_TOp, name)
    __repr__ = _swig_repr

    def __init__(self):
        this = _landmarkDetector.new_Matx_TOp()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _landmarkDetector.delete_Matx_TOp
    __del__ = lambda self: None
Matx_TOp_swigregister = _landmarkDetector.Matx_TOp_swigregister
Matx_TOp_swigregister(Matx_TOp)

class Mat(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Mat, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Mat, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _landmarkDetector.delete_Mat
    __del__ = lambda self: None

    def row(self, y):
        return _landmarkDetector.Mat_row(self, y)

    def col(self, x):
        return _landmarkDetector.Mat_col(self, x)

    def rowRange(self, *args):
        return _landmarkDetector.Mat_rowRange(self, *args)

    def colRange(self, *args):
        return _landmarkDetector.Mat_colRange(self, *args)

    def diag(self, d=0):
        return _landmarkDetector.Mat_diag(self, d)

    def clone(self):
        return _landmarkDetector.Mat_clone(self)

    def assignTo(self, m, type=-1):
        return _landmarkDetector.Mat_assignTo(self, m, type)

    def reshape(self, *args):
        return _landmarkDetector.Mat_reshape(self, *args)

    def create(self, *args):
        return _landmarkDetector.Mat_create(self, *args)

    def addref(self):
        return _landmarkDetector.Mat_addref(self)

    def release(self):
        return _landmarkDetector.Mat_release(self)

    def deallocate(self):
        return _landmarkDetector.Mat_deallocate(self)

    def copySize(self, m):
        return _landmarkDetector.Mat_copySize(self, m)

    def reserve(self, sz):
        return _landmarkDetector.Mat_reserve(self, sz)

    def resize(self, *args):
        return _landmarkDetector.Mat_resize(self, *args)

    def push_back_(self, elem):
        return _landmarkDetector.Mat_push_back_(self, elem)

    def push_back(self, m):
        return _landmarkDetector.Mat_push_back(self, m)

    def pop_back(self, nelems=1):
        return _landmarkDetector.Mat_pop_back(self, nelems)

    def locateROI(self, wholeSize, ofs):
        return _landmarkDetector.Mat_locateROI(self, wholeSize, ofs)

    def adjustROI(self, dtop, dbottom, dleft, dright):
        return _landmarkDetector.Mat_adjustROI(self, dtop, dbottom, dleft, dright)

    def __call__(self, *args):
        return _landmarkDetector.Mat___call__(self, *args)

    def isContinuous(self):
        return _landmarkDetector.Mat_isContinuous(self)

    def isSubmatrix(self):
        return _landmarkDetector.Mat_isSubmatrix(self)

    def elemSize(self):
        return _landmarkDetector.Mat_elemSize(self)

    def elemSize1(self):
        return _landmarkDetector.Mat_elemSize1(self)

    def type(self):
        return _landmarkDetector.Mat_type(self)

    def depth(self):
        return _landmarkDetector.Mat_depth(self)

    def channels(self):
        return _landmarkDetector.Mat_channels(self)

    def step1(self, i=0):
        return _landmarkDetector.Mat_step1(self, i)

    def empty(self):
        return _landmarkDetector.Mat_empty(self)

    def total(self):
        return _landmarkDetector.Mat_total(self)

    def checkVector(self, elemChannels, depth=-1, requireContinuous=True):
        return _landmarkDetector.Mat_checkVector(self, elemChannels, depth, requireContinuous)

    def ptr(self, *args):
        return _landmarkDetector.Mat_ptr(self, *args)
    MAGIC_VAL = _landmarkDetector.Mat_MAGIC_VAL
    AUTO_STEP = _landmarkDetector.Mat_AUTO_STEP
    CONTINUOUS_FLAG = _landmarkDetector.Mat_CONTINUOUS_FLAG
    SUBMATRIX_FLAG = _landmarkDetector.Mat_SUBMATRIX_FLAG
    MAGIC_MASK = _landmarkDetector.Mat_MAGIC_MASK
    TYPE_MASK = _landmarkDetector.Mat_TYPE_MASK
    DEPTH_MASK = _landmarkDetector.Mat_DEPTH_MASK
    __swig_setmethods__["flags"] = _landmarkDetector.Mat_flags_set
    __swig_getmethods__["flags"] = _landmarkDetector.Mat_flags_get
    if _newclass:
        flags = _swig_property(_landmarkDetector.Mat_flags_get, _landmarkDetector.Mat_flags_set)
    __swig_setmethods__["dims"] = _landmarkDetector.Mat_dims_set
    __swig_getmethods__["dims"] = _landmarkDetector.Mat_dims_get
    if _newclass:
        dims = _swig_property(_landmarkDetector.Mat_dims_get, _landmarkDetector.Mat_dims_set)
    __swig_setmethods__["rows"] = _landmarkDetector.Mat_rows_set
    __swig_getmethods__["rows"] = _landmarkDetector.Mat_rows_get
    if _newclass:
        rows = _swig_property(_landmarkDetector.Mat_rows_get, _landmarkDetector.Mat_rows_set)
    __swig_setmethods__["cols"] = _landmarkDetector.Mat_cols_set
    __swig_getmethods__["cols"] = _landmarkDetector.Mat_cols_get
    if _newclass:
        cols = _swig_property(_landmarkDetector.Mat_cols_get, _landmarkDetector.Mat_cols_set)
    __swig_setmethods__["data"] = _landmarkDetector.Mat_data_set
    __swig_getmethods__["data"] = _landmarkDetector.Mat_data_get
    if _newclass:
        data = _swig_property(_landmarkDetector.Mat_data_get, _landmarkDetector.Mat_data_set)
    __swig_setmethods__["datastart"] = _landmarkDetector.Mat_datastart_set
    __swig_getmethods__["datastart"] = _landmarkDetector.Mat_datastart_get
    if _newclass:
        datastart = _swig_property(_landmarkDetector.Mat_datastart_get, _landmarkDetector.Mat_datastart_set)
    __swig_setmethods__["dataend"] = _landmarkDetector.Mat_dataend_set
    __swig_getmethods__["dataend"] = _landmarkDetector.Mat_dataend_get
    if _newclass:
        dataend = _swig_property(_landmarkDetector.Mat_dataend_get, _landmarkDetector.Mat_dataend_set)
    __swig_setmethods__["datalimit"] = _landmarkDetector.Mat_datalimit_set
    __swig_getmethods__["datalimit"] = _landmarkDetector.Mat_datalimit_get
    if _newclass:
        datalimit = _swig_property(_landmarkDetector.Mat_datalimit_get, _landmarkDetector.Mat_datalimit_set)

    def __init__(self, *args):
        this = _landmarkDetector.new_Mat(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def _typestr(self):
        typestr = _depthToDtype(self.depth())
        if typestr[-1] == '1':
            typestr = '|' + typestr
        else:
            typestr = _cv_numpy_endianess + typestr

        return typestr


    @classmethod
    def __get_channels(cls, array):
        if len(array.shape) == 3:
            n_channel = array.shape[2]
            if n_channel == 1:
                raise ValueError("{} expects an one channel numpy ndarray be 2-dimensional.".format(cls))
        elif len(array.shape) == 2:
            n_channel = 1
        else:
            raise ValueError("{} supports only 2 or 3-dimensional numpy ndarray.".format(cls))

        return n_channel


    def __getattribute__(self, name):
        if name == "__array_interface__":
            n_channels = self.channels()
            if n_channels == 1:
                shape = (self.rows, self.cols)
            else:
                shape = (self.rows, self.cols, n_channels)

            return {"shape": shape,
                    "typestr": self._typestr(),
                    "data": (int(self.data), False)}

        else:
            return object.__getattribute__(self, name)

    @classmethod
    def from_array(cls, array):
        import numpy as np
        array = np.asarray(array)

        dtype = array.__array_interface__['typestr']
        dtype = dtype[1:]

        n_channel = cls.__get_channels(array)

        new_mat = Mat(array.shape[0],
                      array.shape[1],
                      _toCvType(dtype, n_channel),
                      array.__array_interface__['data'][0])

    # Holds an internal reference to keep the image buffer alive
        new_mat._array = array

        return new_mat


    def __str__(self):
        return _landmarkDetector.Mat___str__(self)
Mat_swigregister = _landmarkDetector.Mat_swigregister
Mat_swigregister(Mat)

class _cv_numpy_sizeof_uint8_t(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, _cv_numpy_sizeof_uint8_t, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, _cv_numpy_sizeof_uint8_t, name)
    __repr__ = _swig_repr
    value = _landmarkDetector._cv_numpy_sizeof_uint8_t_value

    def __init__(self):
        this = _landmarkDetector.new__cv_numpy_sizeof_uint8_t()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _landmarkDetector.delete__cv_numpy_sizeof_uint8_t
    __del__ = lambda self: None
_cv_numpy_sizeof_uint8_t_swigregister = _landmarkDetector._cv_numpy_sizeof_uint8_t_swigregister
_cv_numpy_sizeof_uint8_t_swigregister(_cv_numpy_sizeof_uint8_t)


if _cv_numpy_sizeof_uint8_t.value == 1:
    _cv_numpy_typestr_map["uint8_t"] = "|" +"u" + "1"
else:
    _cv_numpy_typestr_map["uint8_t"] = _cv_numpy_endianess  +"u" + str(_cv_numpy_sizeof_uint8_t.value)

class _uint8_tArray(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, _uint8_tArray, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, _uint8_tArray, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _landmarkDetector._uint8_tArray_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _landmarkDetector._uint8_tArray___nonzero__(self)

    def __bool__(self):
        return _landmarkDetector._uint8_tArray___bool__(self)

    def __len__(self):
        return _landmarkDetector._uint8_tArray___len__(self)

    def __getslice__(self, i, j):
        return _landmarkDetector._uint8_tArray___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _landmarkDetector._uint8_tArray___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _landmarkDetector._uint8_tArray___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _landmarkDetector._uint8_tArray___delitem__(self, *args)

    def __getitem__(self, *args):
        return _landmarkDetector._uint8_tArray___getitem__(self, *args)

    def __setitem__(self, *args):
        return _landmarkDetector._uint8_tArray___setitem__(self, *args)

    def pop(self):
        return _landmarkDetector._uint8_tArray_pop(self)

    def append(self, x):
        return _landmarkDetector._uint8_tArray_append(self, x)

    def empty(self):
        return _landmarkDetector._uint8_tArray_empty(self)

    def size(self):
        return _landmarkDetector._uint8_tArray_size(self)

    def swap(self, v):
        return _landmarkDetector._uint8_tArray_swap(self, v)

    def begin(self):
        return _landmarkDetector._uint8_tArray_begin(self)

    def end(self):
        return _landmarkDetector._uint8_tArray_end(self)

    def rbegin(self):
        return _landmarkDetector._uint8_tArray_rbegin(self)

    def rend(self):
        return _landmarkDetector._uint8_tArray_rend(self)

    def clear(self):
        return _landmarkDetector._uint8_tArray_clear(self)

    def get_allocator(self):
        return _landmarkDetector._uint8_tArray_get_allocator(self)

    def pop_back(self):
        return _landmarkDetector._uint8_tArray_pop_back(self)

    def erase(self, *args):
        return _landmarkDetector._uint8_tArray_erase(self, *args)

    def __init__(self, *args):
        this = _landmarkDetector.new__uint8_tArray(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        return _landmarkDetector._uint8_tArray_push_back(self, x)

    def front(self):
        return _landmarkDetector._uint8_tArray_front(self)

    def back(self):
        return _landmarkDetector._uint8_tArray_back(self)

    def assign(self, n, x):
        return _landmarkDetector._uint8_tArray_assign(self, n, x)

    def resize(self, *args):
        return _landmarkDetector._uint8_tArray_resize(self, *args)

    def insert(self, *args):
        return _landmarkDetector._uint8_tArray_insert(self, *args)

    def reserve(self, n):
        return _landmarkDetector._uint8_tArray_reserve(self, n)

    def capacity(self):
        return _landmarkDetector._uint8_tArray_capacity(self)
    __swig_destroy__ = _landmarkDetector.delete__uint8_tArray
    __del__ = lambda self: None
_uint8_tArray_swigregister = _landmarkDetector._uint8_tArray_swigregister
_uint8_tArray_swigregister(_uint8_tArray)


_array_map["uint8_t"] = _uint8_tArray

class _Matx_uint8_t_2_1(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, _Matx_uint8_t_2_1, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, _Matx_uint8_t_2_1, name)
    __repr__ = _swig_repr
    rows = _landmarkDetector._Matx_uint8_t_2_1_rows
    cols = _landmarkDetector._Matx_uint8_t_2_1_cols
    channels = _landmarkDetector._Matx_uint8_t_2_1_channels
    shortdim = _landmarkDetector._Matx_uint8_t_2_1_shortdim
    if _newclass:
        all = staticmethod(_landmarkDetector._Matx_uint8_t_2_1_all)
    else:
        all = _landmarkDetector._Matx_uint8_t_2_1_all
    if _newclass:
        zeros = staticmethod(_landmarkDetector._Matx_uint8_t_2_1_zeros)
    else:
        zeros = _landmarkDetector._Matx_uint8_t_2_1_zeros
    if _newclass:
        ones = staticmethod(_landmarkDetector._Matx_uint8_t_2_1_ones)
    else:
        ones = _landmarkDetector._Matx_uint8_t_2_1_ones
    if _newclass:
        eye = staticmethod(_landmarkDetector._Matx_uint8_t_2_1_eye)
    else:
        eye = _landmarkDetector._Matx_uint8_t_2_1_eye
    if _newclass:
        randu = staticmethod(_landmarkDetector._Matx_uint8_t_2_1_randu)
    else:
        randu = _landmarkDetector._Matx_uint8_t_2_1_randu
    if _newclass:
        randn = staticmethod(_landmarkDetector._Matx_uint8_t_2_1_randn)
    else:
        randn = _landmarkDetector._Matx_uint8_t_2_1_randn

    def dot(self, v):
        return _landmarkDetector._Matx_uint8_t_2_1_dot(self, v)

    def ddot(self, v):
        return _landmarkDetector._Matx_uint8_t_2_1_ddot(self, v)

    def t(self):
        return _landmarkDetector._Matx_uint8_t_2_1_t(self)

    def mul(self, a):
        return _landmarkDetector._Matx_uint8_t_2_1_mul(self, a)

    def div(self, a):
        return _landmarkDetector._Matx_uint8_t_2_1_div(self, a)

    def __call__(self, i, j):
        return _landmarkDetector._Matx_uint8_t_2_1___call__(self, i, j)
    __swig_setmethods__["val"] = _landmarkDetector._Matx_uint8_t_2_1_val_set
    __swig_getmethods__["val"] = _landmarkDetector._Matx_uint8_t_2_1_val_get
    if _newclass:
        val = _swig_property(_landmarkDetector._Matx_uint8_t_2_1_val_get, _landmarkDetector._Matx_uint8_t_2_1_val_set)

    import re
    _re_pattern = re.compile("^_Matx_(?P<value_type>[a-zA-Z_][a-zA-Z0-9_]*)_(?P<rows>[0-9]+)_(?P<cols>[0-9]+)$")


    def __init__(self, *args):

        ma = self._re_pattern.match(self.__class__.__name__)
        value_type = ma.group("value_type")
        rows = int(ma.group("rows"))
        cols = int(ma.group("cols"))

        array = _array_map[value_type](rows*cols)
        for i in range(len(args)):
            array[i] = args[i]

        args = [array]


        this = _landmarkDetector.new__Matx_uint8_t_2_1(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def __getattribute__(self, name):
        if name == "__array_interface__":
            ma = self._re_pattern.match(self.__class__.__name__)
            value_type = ma.group("value_type")
            rows = int(ma.group("rows"))
            cols = int(ma.group("cols"))
            return {"shape": (rows, cols),
                    "typestr": _cv_numpy_typestr_map[value_type],
                    "data": (int(self.val), False)}
        else:
            return object.__getattribute__(self, name)


    def __getitem__(self, key):
        ma = self._re_pattern.match(self.__class__.__name__)
        rows = int(ma.group("rows"))
        cols = int(ma.group("cols"))

        if isinstance(key, int):
            if rows != 1 and cols != 1:
                raise IndexError
            i = key
            j = 0
        elif isinstance(key, tuple) and len(key) == 2:
            i = key[0]
            j = key[1]
        else:
            raise TypeError

        if i >= rows or j >= cols:
            raise IndexError

        return self(i, j)


    def __str__(self):
        return _landmarkDetector._Matx_uint8_t_2_1___str__(self)
    __swig_destroy__ = _landmarkDetector.delete__Matx_uint8_t_2_1
    __del__ = lambda self: None
_Matx_uint8_t_2_1_swigregister = _landmarkDetector._Matx_uint8_t_2_1_swigregister
_Matx_uint8_t_2_1_swigregister(_Matx_uint8_t_2_1)

def _Matx_uint8_t_2_1_all(alpha):
    return _landmarkDetector._Matx_uint8_t_2_1_all(alpha)
_Matx_uint8_t_2_1_all = _landmarkDetector._Matx_uint8_t_2_1_all

def _Matx_uint8_t_2_1_zeros():
    return _landmarkDetector._Matx_uint8_t_2_1_zeros()
_Matx_uint8_t_2_1_zeros = _landmarkDetector._Matx_uint8_t_2_1_zeros

def _Matx_uint8_t_2_1_ones():
    return _landmarkDetector._Matx_uint8_t_2_1_ones()
_Matx_uint8_t_2_1_ones = _landmarkDetector._Matx_uint8_t_2_1_ones

def _Matx_uint8_t_2_1_eye():
    return _landmarkDetector._Matx_uint8_t_2_1_eye()
_Matx_uint8_t_2_1_eye = _landmarkDetector._Matx_uint8_t_2_1_eye

def _Matx_uint8_t_2_1_randu(a, b):
    return _landmarkDetector._Matx_uint8_t_2_1_randu(a, b)
_Matx_uint8_t_2_1_randu = _landmarkDetector._Matx_uint8_t_2_1_randu

def _Matx_uint8_t_2_1_randn(a, b):
    return _landmarkDetector._Matx_uint8_t_2_1_randn(a, b)
_Matx_uint8_t_2_1_randn = _landmarkDetector._Matx_uint8_t_2_1_randn


Matx21b = _Matx_uint8_t_2_1

class _Vec_uint8_t_2(_Matx_uint8_t_2_1):
    __swig_setmethods__ = {}
    for _s in [_Matx_uint8_t_2_1]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, _Vec_uint8_t_2, name, value)
    __swig_getmethods__ = {}
    for _s in [_Matx_uint8_t_2_1]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, _Vec_uint8_t_2, name)
    __repr__ = _swig_repr
    channels = _landmarkDetector._Vec_uint8_t_2_channels
    if _newclass:
        all = staticmethod(_landmarkDetector._Vec_uint8_t_2_all)
    else:
        all = _landmarkDetector._Vec_uint8_t_2_all

    def mul(self, v):
        return _landmarkDetector._Vec_uint8_t_2_mul(self, v)

    def __call__(self, i):
        return _landmarkDetector._Vec_uint8_t_2___call__(self, i)

    import re
    _re_pattern = re.compile("^_Vec_(?P<value_type>[a-zA-Z_][a-zA-Z0-9_]*)_(?P<rows>[0-9]+)$")


    def __init__(self, *args):

        ma = self._re_pattern.match(self.__class__.__name__)
        value_type = ma.group("value_type")
        rows = int(ma.group("rows"))

        array = _array_map[value_type](rows)
        for i in range(len(args)):
            array[i] = args[i]

        args = [array]


        this = _landmarkDetector.new__Vec_uint8_t_2(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def __getattribute__(self, name):
        if name == "__array_interface__":
            ma = self._re_pattern.match(self.__class__.__name__)
            value_type = ma.group("value_type")
            rows = int(ma.group("rows"))
            return {"shape": (rows, 1),
                    "typestr": _cv_numpy_typestr_map[value_type],
                    "data": (int(self.val), False)}
        else:
            return object.__getattribute__(self, name)

    def __getitem__(self, key):
        ma = self._re_pattern.match(self.__class__.__name__)
        rows = int(ma.group("rows"))

        if not isinstance(key, int):
            raise TypeError

        if key >= rows:
            raise IndexError

        return self(key)


    def __str__(self):
        return _landmarkDetector._Vec_uint8_t_2___str__(self)
    __swig_destroy__ = _landmarkDetector.delete__Vec_uint8_t_2
    __del__ = lambda self: None
_Vec_uint8_t_2_swigregister = _landmarkDetector._Vec_uint8_t_2_swigregister
_Vec_uint8_t_2_swigregister(_Vec_uint8_t_2)

def _Vec_uint8_t_2_all(alpha):
    return _landmarkDetector._Vec_uint8_t_2_all(alpha)
_Vec_uint8_t_2_all = _landmarkDetector._Vec_uint8_t_2_all

class _DataType_Vec_uint8_t_2(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, _DataType_Vec_uint8_t_2, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, _DataType_Vec_uint8_t_2, name)
    __repr__ = _swig_repr
    generic_type = _landmarkDetector._DataType_Vec_uint8_t_2_generic_type
    channels = _landmarkDetector._DataType_Vec_uint8_t_2_channels
    fmt = _landmarkDetector._DataType_Vec_uint8_t_2_fmt

    def __init__(self):
        this = _landmarkDetector.new__DataType_Vec_uint8_t_2()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _landmarkDetector.delete__DataType_Vec_uint8_t_2
    __del__ = lambda self: None
_DataType_Vec_uint8_t_2_swigregister = _landmarkDetector._DataType_Vec_uint8_t_2_swigregister
_DataType_Vec_uint8_t_2_swigregister(_DataType_Vec_uint8_t_2)


Vec2b = _Vec_uint8_t_2
DataType_Vec2b = _DataType_Vec_uint8_t_2

class _Matx_uint8_t_3_1(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, _Matx_uint8_t_3_1, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, _Matx_uint8_t_3_1, name)
    __repr__ = _swig_repr
    rows = _landmarkDetector._Matx_uint8_t_3_1_rows
    cols = _landmarkDetector._Matx_uint8_t_3_1_cols
    channels = _landmarkDetector._Matx_uint8_t_3_1_channels
    shortdim = _landmarkDetector._Matx_uint8_t_3_1_shortdim
    if _newclass:
        all = staticmethod(_landmarkDetector._Matx_uint8_t_3_1_all)
    else:
        all = _landmarkDetector._Matx_uint8_t_3_1_all
    if _newclass:
        zeros = staticmethod(_landmarkDetector._Matx_uint8_t_3_1_zeros)
    else:
        zeros = _landmarkDetector._Matx_uint8_t_3_1_zeros
    if _newclass:
        ones = staticmethod(_landmarkDetector._Matx_uint8_t_3_1_ones)
    else:
        ones = _landmarkDetector._Matx_uint8_t_3_1_ones
    if _newclass:
        eye = staticmethod(_landmarkDetector._Matx_uint8_t_3_1_eye)
    else:
        eye = _landmarkDetector._Matx_uint8_t_3_1_eye
    if _newclass:
        randu = staticmethod(_landmarkDetector._Matx_uint8_t_3_1_randu)
    else:
        randu = _landmarkDetector._Matx_uint8_t_3_1_randu
    if _newclass:
        randn = staticmethod(_landmarkDetector._Matx_uint8_t_3_1_randn)
    else:
        randn = _landmarkDetector._Matx_uint8_t_3_1_randn

    def dot(self, v):
        return _landmarkDetector._Matx_uint8_t_3_1_dot(self, v)

    def ddot(self, v):
        return _landmarkDetector._Matx_uint8_t_3_1_ddot(self, v)

    def t(self):
        return _landmarkDetector._Matx_uint8_t_3_1_t(self)

    def mul(self, a):
        return _landmarkDetector._Matx_uint8_t_3_1_mul(self, a)

    def div(self, a):
        return _landmarkDetector._Matx_uint8_t_3_1_div(self, a)

    def __call__(self, i, j):
        return _landmarkDetector._Matx_uint8_t_3_1___call__(self, i, j)
    __swig_setmethods__["val"] = _landmarkDetector._Matx_uint8_t_3_1_val_set
    __swig_getmethods__["val"] = _landmarkDetector._Matx_uint8_t_3_1_val_get
    if _newclass:
        val = _swig_property(_landmarkDetector._Matx_uint8_t_3_1_val_get, _landmarkDetector._Matx_uint8_t_3_1_val_set)

    import re
    _re_pattern = re.compile("^_Matx_(?P<value_type>[a-zA-Z_][a-zA-Z0-9_]*)_(?P<rows>[0-9]+)_(?P<cols>[0-9]+)$")


    def __init__(self, *args):

        ma = self._re_pattern.match(self.__class__.__name__)
        value_type = ma.group("value_type")
        rows = int(ma.group("rows"))
        cols = int(ma.group("cols"))

        array = _array_map[value_type](rows*cols)
        for i in range(len(args)):
            array[i] = args[i]

        args = [array]


        this = _landmarkDetector.new__Matx_uint8_t_3_1(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def __getattribute__(self, name):
        if name == "__array_interface__":
            ma = self._re_pattern.match(self.__class__.__name__)
            value_type = ma.group("value_type")
            rows = int(ma.group("rows"))
            cols = int(ma.group("cols"))
            return {"shape": (rows, cols),
                    "typestr": _cv_numpy_typestr_map[value_type],
                    "data": (int(self.val), False)}
        else:
            return object.__getattribute__(self, name)


    def __getitem__(self, key):
        ma = self._re_pattern.match(self.__class__.__name__)
        rows = int(ma.group("rows"))
        cols = int(ma.group("cols"))

        if isinstance(key, int):
            if rows != 1 and cols != 1:
                raise IndexError
            i = key
            j = 0
        elif isinstance(key, tuple) and len(key) == 2:
            i = key[0]
            j = key[1]
        else:
            raise TypeError

        if i >= rows or j >= cols:
            raise IndexError

        return self(i, j)


    def __str__(self):
        return _landmarkDetector._Matx_uint8_t_3_1___str__(self)
    __swig_destroy__ = _landmarkDetector.delete__Matx_uint8_t_3_1
    __del__ = lambda self: None
_Matx_uint8_t_3_1_swigregister = _landmarkDetector._Matx_uint8_t_3_1_swigregister
_Matx_uint8_t_3_1_swigregister(_Matx_uint8_t_3_1)

def _Matx_uint8_t_3_1_all(alpha):
    return _landmarkDetector._Matx_uint8_t_3_1_all(alpha)
_Matx_uint8_t_3_1_all = _landmarkDetector._Matx_uint8_t_3_1_all

def _Matx_uint8_t_3_1_zeros():
    return _landmarkDetector._Matx_uint8_t_3_1_zeros()
_Matx_uint8_t_3_1_zeros = _landmarkDetector._Matx_uint8_t_3_1_zeros

def _Matx_uint8_t_3_1_ones():
    return _landmarkDetector._Matx_uint8_t_3_1_ones()
_Matx_uint8_t_3_1_ones = _landmarkDetector._Matx_uint8_t_3_1_ones

def _Matx_uint8_t_3_1_eye():
    return _landmarkDetector._Matx_uint8_t_3_1_eye()
_Matx_uint8_t_3_1_eye = _landmarkDetector._Matx_uint8_t_3_1_eye

def _Matx_uint8_t_3_1_randu(a, b):
    return _landmarkDetector._Matx_uint8_t_3_1_randu(a, b)
_Matx_uint8_t_3_1_randu = _landmarkDetector._Matx_uint8_t_3_1_randu

def _Matx_uint8_t_3_1_randn(a, b):
    return _landmarkDetector._Matx_uint8_t_3_1_randn(a, b)
_Matx_uint8_t_3_1_randn = _landmarkDetector._Matx_uint8_t_3_1_randn


Matx31b = _Matx_uint8_t_3_1

class _Vec_uint8_t_3(_Matx_uint8_t_3_1):
    __swig_setmethods__ = {}
    for _s in [_Matx_uint8_t_3_1]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, _Vec_uint8_t_3, name, value)
    __swig_getmethods__ = {}
    for _s in [_Matx_uint8_t_3_1]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, _Vec_uint8_t_3, name)
    __repr__ = _swig_repr
    channels = _landmarkDetector._Vec_uint8_t_3_channels
    if _newclass:
        all = staticmethod(_landmarkDetector._Vec_uint8_t_3_all)
    else:
        all = _landmarkDetector._Vec_uint8_t_3_all

    def mul(self, v):
        return _landmarkDetector._Vec_uint8_t_3_mul(self, v)

    def __call__(self, i):
        return _landmarkDetector._Vec_uint8_t_3___call__(self, i)

    import re
    _re_pattern = re.compile("^_Vec_(?P<value_type>[a-zA-Z_][a-zA-Z0-9_]*)_(?P<rows>[0-9]+)$")


    def __init__(self, *args):

        ma = self._re_pattern.match(self.__class__.__name__)
        value_type = ma.group("value_type")
        rows = int(ma.group("rows"))

        array = _array_map[value_type](rows)
        for i in range(len(args)):
            array[i] = args[i]

        args = [array]


        this = _landmarkDetector.new__Vec_uint8_t_3(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def __getattribute__(self, name):
        if name == "__array_interface__":
            ma = self._re_pattern.match(self.__class__.__name__)
            value_type = ma.group("value_type")
            rows = int(ma.group("rows"))
            return {"shape": (rows, 1),
                    "typestr": _cv_numpy_typestr_map[value_type],
                    "data": (int(self.val), False)}
        else:
            return object.__getattribute__(self, name)

    def __getitem__(self, key):
        ma = self._re_pattern.match(self.__class__.__name__)
        rows = int(ma.group("rows"))

        if not isinstance(key, int):
            raise TypeError

        if key >= rows:
            raise IndexError

        return self(key)


    def __str__(self):
        return _landmarkDetector._Vec_uint8_t_3___str__(self)
    __swig_destroy__ = _landmarkDetector.delete__Vec_uint8_t_3
    __del__ = lambda self: None
_Vec_uint8_t_3_swigregister = _landmarkDetector._Vec_uint8_t_3_swigregister
_Vec_uint8_t_3_swigregister(_Vec_uint8_t_3)

def _Vec_uint8_t_3_all(alpha):
    return _landmarkDetector._Vec_uint8_t_3_all(alpha)
_Vec_uint8_t_3_all = _landmarkDetector._Vec_uint8_t_3_all

class _DataType_Vec_uint8_t_3(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, _DataType_Vec_uint8_t_3, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, _DataType_Vec_uint8_t_3, name)
    __repr__ = _swig_repr
    generic_type = _landmarkDetector._DataType_Vec_uint8_t_3_generic_type
    channels = _landmarkDetector._DataType_Vec_uint8_t_3_channels
    fmt = _landmarkDetector._DataType_Vec_uint8_t_3_fmt

    def __init__(self):
        this = _landmarkDetector.new__DataType_Vec_uint8_t_3()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _landmarkDetector.delete__DataType_Vec_uint8_t_3
    __del__ = lambda self: None
_DataType_Vec_uint8_t_3_swigregister = _landmarkDetector._DataType_Vec_uint8_t_3_swigregister
_DataType_Vec_uint8_t_3_swigregister(_DataType_Vec_uint8_t_3)


Vec3b = _Vec_uint8_t_3
DataType_Vec3b = _DataType_Vec_uint8_t_3

class _Matx_uint8_t_4_1(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, _Matx_uint8_t_4_1, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, _Matx_uint8_t_4_1, name)
    __repr__ = _swig_repr
    rows = _landmarkDetector._Matx_uint8_t_4_1_rows
    cols = _landmarkDetector._Matx_uint8_t_4_1_cols
    channels = _landmarkDetector._Matx_uint8_t_4_1_channels
    shortdim = _landmarkDetector._Matx_uint8_t_4_1_shortdim
    if _newclass:
        all = staticmethod(_landmarkDetector._Matx_uint8_t_4_1_all)
    else:
        all = _landmarkDetector._Matx_uint8_t_4_1_all
    if _newclass:
        zeros = staticmethod(_landmarkDetector._Matx_uint8_t_4_1_zeros)
    else:
        zeros = _landmarkDetector._Matx_uint8_t_4_1_zeros
    if _newclass:
        ones = staticmethod(_landmarkDetector._Matx_uint8_t_4_1_ones)
    else:
        ones = _landmarkDetector._Matx_uint8_t_4_1_ones
    if _newclass:
        eye = staticmethod(_landmarkDetector._Matx_uint8_t_4_1_eye)
    else:
        eye = _landmarkDetector._Matx_uint8_t_4_1_eye
    if _newclass:
        randu = staticmethod(_landmarkDetector._Matx_uint8_t_4_1_randu)
    else:
        randu = _landmarkDetector._Matx_uint8_t_4_1_randu
    if _newclass:
        randn = staticmethod(_landmarkDetector._Matx_uint8_t_4_1_randn)
    else:
        randn = _landmarkDetector._Matx_uint8_t_4_1_randn

    def dot(self, v):
        return _landmarkDetector._Matx_uint8_t_4_1_dot(self, v)

    def ddot(self, v):
        return _landmarkDetector._Matx_uint8_t_4_1_ddot(self, v)

    def t(self):
        return _landmarkDetector._Matx_uint8_t_4_1_t(self)

    def mul(self, a):
        return _landmarkDetector._Matx_uint8_t_4_1_mul(self, a)

    def div(self, a):
        return _landmarkDetector._Matx_uint8_t_4_1_div(self, a)

    def __call__(self, i, j):
        return _landmarkDetector._Matx_uint8_t_4_1___call__(self, i, j)
    __swig_setmethods__["val"] = _landmarkDetector._Matx_uint8_t_4_1_val_set
    __swig_getmethods__["val"] = _landmarkDetector._Matx_uint8_t_4_1_val_get
    if _newclass:
        val = _swig_property(_landmarkDetector._Matx_uint8_t_4_1_val_get, _landmarkDetector._Matx_uint8_t_4_1_val_set)

    import re
    _re_pattern = re.compile("^_Matx_(?P<value_type>[a-zA-Z_][a-zA-Z0-9_]*)_(?P<rows>[0-9]+)_(?P<cols>[0-9]+)$")


    def __init__(self, *args):

        ma = self._re_pattern.match(self.__class__.__name__)
        value_type = ma.group("value_type")
        rows = int(ma.group("rows"))
        cols = int(ma.group("cols"))

        array = _array_map[value_type](rows*cols)
        for i in range(len(args)):
            array[i] = args[i]

        args = [array]


        this = _landmarkDetector.new__Matx_uint8_t_4_1(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def __getattribute__(self, name):
        if name == "__array_interface__":
            ma = self._re_pattern.match(self.__class__.__name__)
            value_type = ma.group("value_type")
            rows = int(ma.group("rows"))
            cols = int(ma.group("cols"))
            return {"shape": (rows, cols),
                    "typestr": _cv_numpy_typestr_map[value_type],
                    "data": (int(self.val), False)}
        else:
            return object.__getattribute__(self, name)


    def __getitem__(self, key):
        ma = self._re_pattern.match(self.__class__.__name__)
        rows = int(ma.group("rows"))
        cols = int(ma.group("cols"))

        if isinstance(key, int):
            if rows != 1 and cols != 1:
                raise IndexError
            i = key
            j = 0
        elif isinstance(key, tuple) and len(key) == 2:
            i = key[0]
            j = key[1]
        else:
            raise TypeError

        if i >= rows or j >= cols:
            raise IndexError

        return self(i, j)


    def __str__(self):
        return _landmarkDetector._Matx_uint8_t_4_1___str__(self)
    __swig_destroy__ = _landmarkDetector.delete__Matx_uint8_t_4_1
    __del__ = lambda self: None
_Matx_uint8_t_4_1_swigregister = _landmarkDetector._Matx_uint8_t_4_1_swigregister
_Matx_uint8_t_4_1_swigregister(_Matx_uint8_t_4_1)

def _Matx_uint8_t_4_1_all(alpha):
    return _landmarkDetector._Matx_uint8_t_4_1_all(alpha)
_Matx_uint8_t_4_1_all = _landmarkDetector._Matx_uint8_t_4_1_all

def _Matx_uint8_t_4_1_zeros():
    return _landmarkDetector._Matx_uint8_t_4_1_zeros()
_Matx_uint8_t_4_1_zeros = _landmarkDetector._Matx_uint8_t_4_1_zeros

def _Matx_uint8_t_4_1_ones():
    return _landmarkDetector._Matx_uint8_t_4_1_ones()
_Matx_uint8_t_4_1_ones = _landmarkDetector._Matx_uint8_t_4_1_ones

def _Matx_uint8_t_4_1_eye():
    return _landmarkDetector._Matx_uint8_t_4_1_eye()
_Matx_uint8_t_4_1_eye = _landmarkDetector._Matx_uint8_t_4_1_eye

def _Matx_uint8_t_4_1_randu(a, b):
    return _landmarkDetector._Matx_uint8_t_4_1_randu(a, b)
_Matx_uint8_t_4_1_randu = _landmarkDetector._Matx_uint8_t_4_1_randu

def _Matx_uint8_t_4_1_randn(a, b):
    return _landmarkDetector._Matx_uint8_t_4_1_randn(a, b)
_Matx_uint8_t_4_1_randn = _landmarkDetector._Matx_uint8_t_4_1_randn


Matx41b = _Matx_uint8_t_4_1

class _Vec_uint8_t_4(_Matx_uint8_t_4_1):
    __swig_setmethods__ = {}
    for _s in [_Matx_uint8_t_4_1]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, _Vec_uint8_t_4, name, value)
    __swig_getmethods__ = {}
    for _s in [_Matx_uint8_t_4_1]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, _Vec_uint8_t_4, name)
    __repr__ = _swig_repr
    channels = _landmarkDetector._Vec_uint8_t_4_channels
    if _newclass:
        all = staticmethod(_landmarkDetector._Vec_uint8_t_4_all)
    else:
        all = _landmarkDetector._Vec_uint8_t_4_all

    def mul(self, v):
        return _landmarkDetector._Vec_uint8_t_4_mul(self, v)

    def __call__(self, i):
        return _landmarkDetector._Vec_uint8_t_4___call__(self, i)

    import re
    _re_pattern = re.compile("^_Vec_(?P<value_type>[a-zA-Z_][a-zA-Z0-9_]*)_(?P<rows>[0-9]+)$")


    def __init__(self, *args):

        ma = self._re_pattern.match(self.__class__.__name__)
        value_type = ma.group("value_type")
        rows = int(ma.group("rows"))

        array = _array_map[value_type](rows)
        for i in range(len(args)):
            array[i] = args[i]

        args = [array]


        this = _landmarkDetector.new__Vec_uint8_t_4(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def __getattribute__(self, name):
        if name == "__array_interface__":
            ma = self._re_pattern.match(self.__class__.__name__)
            value_type = ma.group("value_type")
            rows = int(ma.group("rows"))
            return {"shape": (rows, 1),
                    "typestr": _cv_numpy_typestr_map[value_type],
                    "data": (int(self.val), False)}
        else:
            return object.__getattribute__(self, name)

    def __getitem__(self, key):
        ma = self._re_pattern.match(self.__class__.__name__)
        rows = int(ma.group("rows"))

        if not isinstance(key, int):
            raise TypeError

        if key >= rows:
            raise IndexError

        return self(key)


    def __str__(self):
        return _landmarkDetector._Vec_uint8_t_4___str__(self)
    __swig_destroy__ = _landmarkDetector.delete__Vec_uint8_t_4
    __del__ = lambda self: None
_Vec_uint8_t_4_swigregister = _landmarkDetector._Vec_uint8_t_4_swigregister
_Vec_uint8_t_4_swigregister(_Vec_uint8_t_4)

def _Vec_uint8_t_4_all(alpha):
    return _landmarkDetector._Vec_uint8_t_4_all(alpha)
_Vec_uint8_t_4_all = _landmarkDetector._Vec_uint8_t_4_all

class _DataType_Vec_uint8_t_4(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, _DataType_Vec_uint8_t_4, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, _DataType_Vec_uint8_t_4, name)
    __repr__ = _swig_repr
    generic_type = _landmarkDetector._DataType_Vec_uint8_t_4_generic_type
    channels = _landmarkDetector._DataType_Vec_uint8_t_4_channels
    fmt = _landmarkDetector._DataType_Vec_uint8_t_4_fmt

    def __init__(self):
        this = _landmarkDetector.new__DataType_Vec_uint8_t_4()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _landmarkDetector.delete__DataType_Vec_uint8_t_4
    __del__ = lambda self: None
_DataType_Vec_uint8_t_4_swigregister = _landmarkDetector._DataType_Vec_uint8_t_4_swigregister
_DataType_Vec_uint8_t_4_swigregister(_DataType_Vec_uint8_t_4)


Vec4b = _Vec_uint8_t_4
DataType_Vec4b = _DataType_Vec_uint8_t_4

class _cv_numpy_sizeof_short(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, _cv_numpy_sizeof_short, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, _cv_numpy_sizeof_short, name)
    __repr__ = _swig_repr
    value = _landmarkDetector._cv_numpy_sizeof_short_value

    def __init__(self):
        this = _landmarkDetector.new__cv_numpy_sizeof_short()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _landmarkDetector.delete__cv_numpy_sizeof_short
    __del__ = lambda self: None
_cv_numpy_sizeof_short_swigregister = _landmarkDetector._cv_numpy_sizeof_short_swigregister
_cv_numpy_sizeof_short_swigregister(_cv_numpy_sizeof_short)


if _cv_numpy_sizeof_short.value == 1:
    _cv_numpy_typestr_map["short"] = "|" +"i" + "1"
else:
    _cv_numpy_typestr_map["short"] = _cv_numpy_endianess  +"i" + str(_cv_numpy_sizeof_short.value)

class _shortArray(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, _shortArray, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, _shortArray, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _landmarkDetector._shortArray_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _landmarkDetector._shortArray___nonzero__(self)

    def __bool__(self):
        return _landmarkDetector._shortArray___bool__(self)

    def __len__(self):
        return _landmarkDetector._shortArray___len__(self)

    def __getslice__(self, i, j):
        return _landmarkDetector._shortArray___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _landmarkDetector._shortArray___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _landmarkDetector._shortArray___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _landmarkDetector._shortArray___delitem__(self, *args)

    def __getitem__(self, *args):
        return _landmarkDetector._shortArray___getitem__(self, *args)

    def __setitem__(self, *args):
        return _landmarkDetector._shortArray___setitem__(self, *args)

    def pop(self):
        return _landmarkDetector._shortArray_pop(self)

    def append(self, x):
        return _landmarkDetector._shortArray_append(self, x)

    def empty(self):
        return _landmarkDetector._shortArray_empty(self)

    def size(self):
        return _landmarkDetector._shortArray_size(self)

    def swap(self, v):
        return _landmarkDetector._shortArray_swap(self, v)

    def begin(self):
        return _landmarkDetector._shortArray_begin(self)

    def end(self):
        return _landmarkDetector._shortArray_end(self)

    def rbegin(self):
        return _landmarkDetector._shortArray_rbegin(self)

    def rend(self):
        return _landmarkDetector._shortArray_rend(self)

    def clear(self):
        return _landmarkDetector._shortArray_clear(self)

    def get_allocator(self):
        return _landmarkDetector._shortArray_get_allocator(self)

    def pop_back(self):
        return _landmarkDetector._shortArray_pop_back(self)

    def erase(self, *args):
        return _landmarkDetector._shortArray_erase(self, *args)

    def __init__(self, *args):
        this = _landmarkDetector.new__shortArray(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        return _landmarkDetector._shortArray_push_back(self, x)

    def front(self):
        return _landmarkDetector._shortArray_front(self)

    def back(self):
        return _landmarkDetector._shortArray_back(self)

    def assign(self, n, x):
        return _landmarkDetector._shortArray_assign(self, n, x)

    def resize(self, *args):
        return _landmarkDetector._shortArray_resize(self, *args)

    def insert(self, *args):
        return _landmarkDetector._shortArray_insert(self, *args)

    def reserve(self, n):
        return _landmarkDetector._shortArray_reserve(self, n)

    def capacity(self):
        return _landmarkDetector._shortArray_capacity(self)
    __swig_destroy__ = _landmarkDetector.delete__shortArray
    __del__ = lambda self: None
_shortArray_swigregister = _landmarkDetector._shortArray_swigregister
_shortArray_swigregister(_shortArray)


_array_map["short"] = _shortArray

class _Matx_short_2_1(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, _Matx_short_2_1, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, _Matx_short_2_1, name)
    __repr__ = _swig_repr
    rows = _landmarkDetector._Matx_short_2_1_rows
    cols = _landmarkDetector._Matx_short_2_1_cols
    channels = _landmarkDetector._Matx_short_2_1_channels
    shortdim = _landmarkDetector._Matx_short_2_1_shortdim
    if _newclass:
        all = staticmethod(_landmarkDetector._Matx_short_2_1_all)
    else:
        all = _landmarkDetector._Matx_short_2_1_all
    if _newclass:
        zeros = staticmethod(_landmarkDetector._Matx_short_2_1_zeros)
    else:
        zeros = _landmarkDetector._Matx_short_2_1_zeros
    if _newclass:
        ones = staticmethod(_landmarkDetector._Matx_short_2_1_ones)
    else:
        ones = _landmarkDetector._Matx_short_2_1_ones
    if _newclass:
        eye = staticmethod(_landmarkDetector._Matx_short_2_1_eye)
    else:
        eye = _landmarkDetector._Matx_short_2_1_eye
    if _newclass:
        randu = staticmethod(_landmarkDetector._Matx_short_2_1_randu)
    else:
        randu = _landmarkDetector._Matx_short_2_1_randu
    if _newclass:
        randn = staticmethod(_landmarkDetector._Matx_short_2_1_randn)
    else:
        randn = _landmarkDetector._Matx_short_2_1_randn

    def dot(self, v):
        return _landmarkDetector._Matx_short_2_1_dot(self, v)

    def ddot(self, v):
        return _landmarkDetector._Matx_short_2_1_ddot(self, v)

    def t(self):
        return _landmarkDetector._Matx_short_2_1_t(self)

    def mul(self, a):
        return _landmarkDetector._Matx_short_2_1_mul(self, a)

    def div(self, a):
        return _landmarkDetector._Matx_short_2_1_div(self, a)

    def __call__(self, i, j):
        return _landmarkDetector._Matx_short_2_1___call__(self, i, j)
    __swig_setmethods__["val"] = _landmarkDetector._Matx_short_2_1_val_set
    __swig_getmethods__["val"] = _landmarkDetector._Matx_short_2_1_val_get
    if _newclass:
        val = _swig_property(_landmarkDetector._Matx_short_2_1_val_get, _landmarkDetector._Matx_short_2_1_val_set)

    import re
    _re_pattern = re.compile("^_Matx_(?P<value_type>[a-zA-Z_][a-zA-Z0-9_]*)_(?P<rows>[0-9]+)_(?P<cols>[0-9]+)$")


    def __init__(self, *args):

        ma = self._re_pattern.match(self.__class__.__name__)
        value_type = ma.group("value_type")
        rows = int(ma.group("rows"))
        cols = int(ma.group("cols"))

        array = _array_map[value_type](rows*cols)
        for i in range(len(args)):
            array[i] = args[i]

        args = [array]


        this = _landmarkDetector.new__Matx_short_2_1(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def __getattribute__(self, name):
        if name == "__array_interface__":
            ma = self._re_pattern.match(self.__class__.__name__)
            value_type = ma.group("value_type")
            rows = int(ma.group("rows"))
            cols = int(ma.group("cols"))
            return {"shape": (rows, cols),
                    "typestr": _cv_numpy_typestr_map[value_type],
                    "data": (int(self.val), False)}
        else:
            return object.__getattribute__(self, name)


    def __getitem__(self, key):
        ma = self._re_pattern.match(self.__class__.__name__)
        rows = int(ma.group("rows"))
        cols = int(ma.group("cols"))

        if isinstance(key, int):
            if rows != 1 and cols != 1:
                raise IndexError
            i = key
            j = 0
        elif isinstance(key, tuple) and len(key) == 2:
            i = key[0]
            j = key[1]
        else:
            raise TypeError

        if i >= rows or j >= cols:
            raise IndexError

        return self(i, j)


    def __str__(self):
        return _landmarkDetector._Matx_short_2_1___str__(self)
    __swig_destroy__ = _landmarkDetector.delete__Matx_short_2_1
    __del__ = lambda self: None
_Matx_short_2_1_swigregister = _landmarkDetector._Matx_short_2_1_swigregister
_Matx_short_2_1_swigregister(_Matx_short_2_1)

def _Matx_short_2_1_all(alpha):
    return _landmarkDetector._Matx_short_2_1_all(alpha)
_Matx_short_2_1_all = _landmarkDetector._Matx_short_2_1_all

def _Matx_short_2_1_zeros():
    return _landmarkDetector._Matx_short_2_1_zeros()
_Matx_short_2_1_zeros = _landmarkDetector._Matx_short_2_1_zeros

def _Matx_short_2_1_ones():
    return _landmarkDetector._Matx_short_2_1_ones()
_Matx_short_2_1_ones = _landmarkDetector._Matx_short_2_1_ones

def _Matx_short_2_1_eye():
    return _landmarkDetector._Matx_short_2_1_eye()
_Matx_short_2_1_eye = _landmarkDetector._Matx_short_2_1_eye

def _Matx_short_2_1_randu(a, b):
    return _landmarkDetector._Matx_short_2_1_randu(a, b)
_Matx_short_2_1_randu = _landmarkDetector._Matx_short_2_1_randu

def _Matx_short_2_1_randn(a, b):
    return _landmarkDetector._Matx_short_2_1_randn(a, b)
_Matx_short_2_1_randn = _landmarkDetector._Matx_short_2_1_randn


Matx21s = _Matx_short_2_1

class _Vec_short_2(_Matx_short_2_1):
    __swig_setmethods__ = {}
    for _s in [_Matx_short_2_1]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, _Vec_short_2, name, value)
    __swig_getmethods__ = {}
    for _s in [_Matx_short_2_1]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, _Vec_short_2, name)
    __repr__ = _swig_repr
    channels = _landmarkDetector._Vec_short_2_channels
    if _newclass:
        all = staticmethod(_landmarkDetector._Vec_short_2_all)
    else:
        all = _landmarkDetector._Vec_short_2_all

    def mul(self, v):
        return _landmarkDetector._Vec_short_2_mul(self, v)

    def __call__(self, i):
        return _landmarkDetector._Vec_short_2___call__(self, i)

    import re
    _re_pattern = re.compile("^_Vec_(?P<value_type>[a-zA-Z_][a-zA-Z0-9_]*)_(?P<rows>[0-9]+)$")


    def __init__(self, *args):

        ma = self._re_pattern.match(self.__class__.__name__)
        value_type = ma.group("value_type")
        rows = int(ma.group("rows"))

        array = _array_map[value_type](rows)
        for i in range(len(args)):
            array[i] = args[i]

        args = [array]


        this = _landmarkDetector.new__Vec_short_2(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def __getattribute__(self, name):
        if name == "__array_interface__":
            ma = self._re_pattern.match(self.__class__.__name__)
            value_type = ma.group("value_type")
            rows = int(ma.group("rows"))
            return {"shape": (rows, 1),
                    "typestr": _cv_numpy_typestr_map[value_type],
                    "data": (int(self.val), False)}
        else:
            return object.__getattribute__(self, name)

    def __getitem__(self, key):
        ma = self._re_pattern.match(self.__class__.__name__)
        rows = int(ma.group("rows"))

        if not isinstance(key, int):
            raise TypeError

        if key >= rows:
            raise IndexError

        return self(key)


    def __str__(self):
        return _landmarkDetector._Vec_short_2___str__(self)
    __swig_destroy__ = _landmarkDetector.delete__Vec_short_2
    __del__ = lambda self: None
_Vec_short_2_swigregister = _landmarkDetector._Vec_short_2_swigregister
_Vec_short_2_swigregister(_Vec_short_2)

def _Vec_short_2_all(alpha):
    return _landmarkDetector._Vec_short_2_all(alpha)
_Vec_short_2_all = _landmarkDetector._Vec_short_2_all

class _DataType_Vec_short_2(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, _DataType_Vec_short_2, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, _DataType_Vec_short_2, name)
    __repr__ = _swig_repr
    generic_type = _landmarkDetector._DataType_Vec_short_2_generic_type
    channels = _landmarkDetector._DataType_Vec_short_2_channels
    fmt = _landmarkDetector._DataType_Vec_short_2_fmt

    def __init__(self):
        this = _landmarkDetector.new__DataType_Vec_short_2()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _landmarkDetector.delete__DataType_Vec_short_2
    __del__ = lambda self: None
_DataType_Vec_short_2_swigregister = _landmarkDetector._DataType_Vec_short_2_swigregister
_DataType_Vec_short_2_swigregister(_DataType_Vec_short_2)


Vec2s = _Vec_short_2
DataType_Vec2s = _DataType_Vec_short_2

class _Matx_short_3_1(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, _Matx_short_3_1, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, _Matx_short_3_1, name)
    __repr__ = _swig_repr
    rows = _landmarkDetector._Matx_short_3_1_rows
    cols = _landmarkDetector._Matx_short_3_1_cols
    channels = _landmarkDetector._Matx_short_3_1_channels
    shortdim = _landmarkDetector._Matx_short_3_1_shortdim
    if _newclass:
        all = staticmethod(_landmarkDetector._Matx_short_3_1_all)
    else:
        all = _landmarkDetector._Matx_short_3_1_all
    if _newclass:
        zeros = staticmethod(_landmarkDetector._Matx_short_3_1_zeros)
    else:
        zeros = _landmarkDetector._Matx_short_3_1_zeros
    if _newclass:
        ones = staticmethod(_landmarkDetector._Matx_short_3_1_ones)
    else:
        ones = _landmarkDetector._Matx_short_3_1_ones
    if _newclass:
        eye = staticmethod(_landmarkDetector._Matx_short_3_1_eye)
    else:
        eye = _landmarkDetector._Matx_short_3_1_eye
    if _newclass:
        randu = staticmethod(_landmarkDetector._Matx_short_3_1_randu)
    else:
        randu = _landmarkDetector._Matx_short_3_1_randu
    if _newclass:
        randn = staticmethod(_landmarkDetector._Matx_short_3_1_randn)
    else:
        randn = _landmarkDetector._Matx_short_3_1_randn

    def dot(self, v):
        return _landmarkDetector._Matx_short_3_1_dot(self, v)

    def ddot(self, v):
        return _landmarkDetector._Matx_short_3_1_ddot(self, v)

    def t(self):
        return _landmarkDetector._Matx_short_3_1_t(self)

    def mul(self, a):
        return _landmarkDetector._Matx_short_3_1_mul(self, a)

    def div(self, a):
        return _landmarkDetector._Matx_short_3_1_div(self, a)

    def __call__(self, i, j):
        return _landmarkDetector._Matx_short_3_1___call__(self, i, j)
    __swig_setmethods__["val"] = _landmarkDetector._Matx_short_3_1_val_set
    __swig_getmethods__["val"] = _landmarkDetector._Matx_short_3_1_val_get
    if _newclass:
        val = _swig_property(_landmarkDetector._Matx_short_3_1_val_get, _landmarkDetector._Matx_short_3_1_val_set)

    import re
    _re_pattern = re.compile("^_Matx_(?P<value_type>[a-zA-Z_][a-zA-Z0-9_]*)_(?P<rows>[0-9]+)_(?P<cols>[0-9]+)$")


    def __init__(self, *args):

        ma = self._re_pattern.match(self.__class__.__name__)
        value_type = ma.group("value_type")
        rows = int(ma.group("rows"))
        cols = int(ma.group("cols"))

        array = _array_map[value_type](rows*cols)
        for i in range(len(args)):
            array[i] = args[i]

        args = [array]


        this = _landmarkDetector.new__Matx_short_3_1(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def __getattribute__(self, name):
        if name == "__array_interface__":
            ma = self._re_pattern.match(self.__class__.__name__)
            value_type = ma.group("value_type")
            rows = int(ma.group("rows"))
            cols = int(ma.group("cols"))
            return {"shape": (rows, cols),
                    "typestr": _cv_numpy_typestr_map[value_type],
                    "data": (int(self.val), False)}
        else:
            return object.__getattribute__(self, name)


    def __getitem__(self, key):
        ma = self._re_pattern.match(self.__class__.__name__)
        rows = int(ma.group("rows"))
        cols = int(ma.group("cols"))

        if isinstance(key, int):
            if rows != 1 and cols != 1:
                raise IndexError
            i = key
            j = 0
        elif isinstance(key, tuple) and len(key) == 2:
            i = key[0]
            j = key[1]
        else:
            raise TypeError

        if i >= rows or j >= cols:
            raise IndexError

        return self(i, j)


    def __str__(self):
        return _landmarkDetector._Matx_short_3_1___str__(self)
    __swig_destroy__ = _landmarkDetector.delete__Matx_short_3_1
    __del__ = lambda self: None
_Matx_short_3_1_swigregister = _landmarkDetector._Matx_short_3_1_swigregister
_Matx_short_3_1_swigregister(_Matx_short_3_1)

def _Matx_short_3_1_all(alpha):
    return _landmarkDetector._Matx_short_3_1_all(alpha)
_Matx_short_3_1_all = _landmarkDetector._Matx_short_3_1_all

def _Matx_short_3_1_zeros():
    return _landmarkDetector._Matx_short_3_1_zeros()
_Matx_short_3_1_zeros = _landmarkDetector._Matx_short_3_1_zeros

def _Matx_short_3_1_ones():
    return _landmarkDetector._Matx_short_3_1_ones()
_Matx_short_3_1_ones = _landmarkDetector._Matx_short_3_1_ones

def _Matx_short_3_1_eye():
    return _landmarkDetector._Matx_short_3_1_eye()
_Matx_short_3_1_eye = _landmarkDetector._Matx_short_3_1_eye

def _Matx_short_3_1_randu(a, b):
    return _landmarkDetector._Matx_short_3_1_randu(a, b)
_Matx_short_3_1_randu = _landmarkDetector._Matx_short_3_1_randu

def _Matx_short_3_1_randn(a, b):
    return _landmarkDetector._Matx_short_3_1_randn(a, b)
_Matx_short_3_1_randn = _landmarkDetector._Matx_short_3_1_randn


Matx31s = _Matx_short_3_1

class _Vec_short_3(_Matx_short_3_1):
    __swig_setmethods__ = {}
    for _s in [_Matx_short_3_1]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, _Vec_short_3, name, value)
    __swig_getmethods__ = {}
    for _s in [_Matx_short_3_1]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, _Vec_short_3, name)
    __repr__ = _swig_repr
    channels = _landmarkDetector._Vec_short_3_channels
    if _newclass:
        all = staticmethod(_landmarkDetector._Vec_short_3_all)
    else:
        all = _landmarkDetector._Vec_short_3_all

    def mul(self, v):
        return _landmarkDetector._Vec_short_3_mul(self, v)

    def __call__(self, i):
        return _landmarkDetector._Vec_short_3___call__(self, i)

    import re
    _re_pattern = re.compile("^_Vec_(?P<value_type>[a-zA-Z_][a-zA-Z0-9_]*)_(?P<rows>[0-9]+)$")


    def __init__(self, *args):

        ma = self._re_pattern.match(self.__class__.__name__)
        value_type = ma.group("value_type")
        rows = int(ma.group("rows"))

        array = _array_map[value_type](rows)
        for i in range(len(args)):
            array[i] = args[i]

        args = [array]


        this = _landmarkDetector.new__Vec_short_3(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def __getattribute__(self, name):
        if name == "__array_interface__":
            ma = self._re_pattern.match(self.__class__.__name__)
            value_type = ma.group("value_type")
            rows = int(ma.group("rows"))
            return {"shape": (rows, 1),
                    "typestr": _cv_numpy_typestr_map[value_type],
                    "data": (int(self.val), False)}
        else:
            return object.__getattribute__(self, name)

    def __getitem__(self, key):
        ma = self._re_pattern.match(self.__class__.__name__)
        rows = int(ma.group("rows"))

        if not isinstance(key, int):
            raise TypeError

        if key >= rows:
            raise IndexError

        return self(key)


    def __str__(self):
        return _landmarkDetector._Vec_short_3___str__(self)
    __swig_destroy__ = _landmarkDetector.delete__Vec_short_3
    __del__ = lambda self: None
_Vec_short_3_swigregister = _landmarkDetector._Vec_short_3_swigregister
_Vec_short_3_swigregister(_Vec_short_3)

def _Vec_short_3_all(alpha):
    return _landmarkDetector._Vec_short_3_all(alpha)
_Vec_short_3_all = _landmarkDetector._Vec_short_3_all

class _DataType_Vec_short_3(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, _DataType_Vec_short_3, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, _DataType_Vec_short_3, name)
    __repr__ = _swig_repr
    generic_type = _landmarkDetector._DataType_Vec_short_3_generic_type
    channels = _landmarkDetector._DataType_Vec_short_3_channels
    fmt = _landmarkDetector._DataType_Vec_short_3_fmt

    def __init__(self):
        this = _landmarkDetector.new__DataType_Vec_short_3()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _landmarkDetector.delete__DataType_Vec_short_3
    __del__ = lambda self: None
_DataType_Vec_short_3_swigregister = _landmarkDetector._DataType_Vec_short_3_swigregister
_DataType_Vec_short_3_swigregister(_DataType_Vec_short_3)


Vec3s = _Vec_short_3
DataType_Vec3s = _DataType_Vec_short_3

class _Matx_short_4_1(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, _Matx_short_4_1, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, _Matx_short_4_1, name)
    __repr__ = _swig_repr
    rows = _landmarkDetector._Matx_short_4_1_rows
    cols = _landmarkDetector._Matx_short_4_1_cols
    channels = _landmarkDetector._Matx_short_4_1_channels
    shortdim = _landmarkDetector._Matx_short_4_1_shortdim
    if _newclass:
        all = staticmethod(_landmarkDetector._Matx_short_4_1_all)
    else:
        all = _landmarkDetector._Matx_short_4_1_all
    if _newclass:
        zeros = staticmethod(_landmarkDetector._Matx_short_4_1_zeros)
    else:
        zeros = _landmarkDetector._Matx_short_4_1_zeros
    if _newclass:
        ones = staticmethod(_landmarkDetector._Matx_short_4_1_ones)
    else:
        ones = _landmarkDetector._Matx_short_4_1_ones
    if _newclass:
        eye = staticmethod(_landmarkDetector._Matx_short_4_1_eye)
    else:
        eye = _landmarkDetector._Matx_short_4_1_eye
    if _newclass:
        randu = staticmethod(_landmarkDetector._Matx_short_4_1_randu)
    else:
        randu = _landmarkDetector._Matx_short_4_1_randu
    if _newclass:
        randn = staticmethod(_landmarkDetector._Matx_short_4_1_randn)
    else:
        randn = _landmarkDetector._Matx_short_4_1_randn

    def dot(self, v):
        return _landmarkDetector._Matx_short_4_1_dot(self, v)

    def ddot(self, v):
        return _landmarkDetector._Matx_short_4_1_ddot(self, v)

    def t(self):
        return _landmarkDetector._Matx_short_4_1_t(self)

    def mul(self, a):
        return _landmarkDetector._Matx_short_4_1_mul(self, a)

    def div(self, a):
        return _landmarkDetector._Matx_short_4_1_div(self, a)

    def __call__(self, i, j):
        return _landmarkDetector._Matx_short_4_1___call__(self, i, j)
    __swig_setmethods__["val"] = _landmarkDetector._Matx_short_4_1_val_set
    __swig_getmethods__["val"] = _landmarkDetector._Matx_short_4_1_val_get
    if _newclass:
        val = _swig_property(_landmarkDetector._Matx_short_4_1_val_get, _landmarkDetector._Matx_short_4_1_val_set)

    import re
    _re_pattern = re.compile("^_Matx_(?P<value_type>[a-zA-Z_][a-zA-Z0-9_]*)_(?P<rows>[0-9]+)_(?P<cols>[0-9]+)$")


    def __init__(self, *args):

        ma = self._re_pattern.match(self.__class__.__name__)
        value_type = ma.group("value_type")
        rows = int(ma.group("rows"))
        cols = int(ma.group("cols"))

        array = _array_map[value_type](rows*cols)
        for i in range(len(args)):
            array[i] = args[i]

        args = [array]


        this = _landmarkDetector.new__Matx_short_4_1(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def __getattribute__(self, name):
        if name == "__array_interface__":
            ma = self._re_pattern.match(self.__class__.__name__)
            value_type = ma.group("value_type")
            rows = int(ma.group("rows"))
            cols = int(ma.group("cols"))
            return {"shape": (rows, cols),
                    "typestr": _cv_numpy_typestr_map[value_type],
                    "data": (int(self.val), False)}
        else:
            return object.__getattribute__(self, name)


    def __getitem__(self, key):
        ma = self._re_pattern.match(self.__class__.__name__)
        rows = int(ma.group("rows"))
        cols = int(ma.group("cols"))

        if isinstance(key, int):
            if rows != 1 and cols != 1:
                raise IndexError
            i = key
            j = 0
        elif isinstance(key, tuple) and len(key) == 2:
            i = key[0]
            j = key[1]
        else:
            raise TypeError

        if i >= rows or j >= cols:
            raise IndexError

        return self(i, j)


    def __str__(self):
        return _landmarkDetector._Matx_short_4_1___str__(self)
    __swig_destroy__ = _landmarkDetector.delete__Matx_short_4_1
    __del__ = lambda self: None
_Matx_short_4_1_swigregister = _landmarkDetector._Matx_short_4_1_swigregister
_Matx_short_4_1_swigregister(_Matx_short_4_1)

def _Matx_short_4_1_all(alpha):
    return _landmarkDetector._Matx_short_4_1_all(alpha)
_Matx_short_4_1_all = _landmarkDetector._Matx_short_4_1_all

def _Matx_short_4_1_zeros():
    return _landmarkDetector._Matx_short_4_1_zeros()
_Matx_short_4_1_zeros = _landmarkDetector._Matx_short_4_1_zeros

def _Matx_short_4_1_ones():
    return _landmarkDetector._Matx_short_4_1_ones()
_Matx_short_4_1_ones = _landmarkDetector._Matx_short_4_1_ones

def _Matx_short_4_1_eye():
    return _landmarkDetector._Matx_short_4_1_eye()
_Matx_short_4_1_eye = _landmarkDetector._Matx_short_4_1_eye

def _Matx_short_4_1_randu(a, b):
    return _landmarkDetector._Matx_short_4_1_randu(a, b)
_Matx_short_4_1_randu = _landmarkDetector._Matx_short_4_1_randu

def _Matx_short_4_1_randn(a, b):
    return _landmarkDetector._Matx_short_4_1_randn(a, b)
_Matx_short_4_1_randn = _landmarkDetector._Matx_short_4_1_randn


Matx41s = _Matx_short_4_1

class _Vec_short_4(_Matx_short_4_1):
    __swig_setmethods__ = {}
    for _s in [_Matx_short_4_1]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, _Vec_short_4, name, value)
    __swig_getmethods__ = {}
    for _s in [_Matx_short_4_1]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, _Vec_short_4, name)
    __repr__ = _swig_repr
    channels = _landmarkDetector._Vec_short_4_channels
    if _newclass:
        all = staticmethod(_landmarkDetector._Vec_short_4_all)
    else:
        all = _landmarkDetector._Vec_short_4_all

    def mul(self, v):
        return _landmarkDetector._Vec_short_4_mul(self, v)

    def __call__(self, i):
        return _landmarkDetector._Vec_short_4___call__(self, i)

    import re
    _re_pattern = re.compile("^_Vec_(?P<value_type>[a-zA-Z_][a-zA-Z0-9_]*)_(?P<rows>[0-9]+)$")


    def __init__(self, *args):

        ma = self._re_pattern.match(self.__class__.__name__)
        value_type = ma.group("value_type")
        rows = int(ma.group("rows"))

        array = _array_map[value_type](rows)
        for i in range(len(args)):
            array[i] = args[i]

        args = [array]


        this = _landmarkDetector.new__Vec_short_4(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def __getattribute__(self, name):
        if name == "__array_interface__":
            ma = self._re_pattern.match(self.__class__.__name__)
            value_type = ma.group("value_type")
            rows = int(ma.group("rows"))
            return {"shape": (rows, 1),
                    "typestr": _cv_numpy_typestr_map[value_type],
                    "data": (int(self.val), False)}
        else:
            return object.__getattribute__(self, name)

    def __getitem__(self, key):
        ma = self._re_pattern.match(self.__class__.__name__)
        rows = int(ma.group("rows"))

        if not isinstance(key, int):
            raise TypeError

        if key >= rows:
            raise IndexError

        return self(key)


    def __str__(self):
        return _landmarkDetector._Vec_short_4___str__(self)
    __swig_destroy__ = _landmarkDetector.delete__Vec_short_4
    __del__ = lambda self: None
_Vec_short_4_swigregister = _landmarkDetector._Vec_short_4_swigregister
_Vec_short_4_swigregister(_Vec_short_4)

def _Vec_short_4_all(alpha):
    return _landmarkDetector._Vec_short_4_all(alpha)
_Vec_short_4_all = _landmarkDetector._Vec_short_4_all

class _DataType_Vec_short_4(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, _DataType_Vec_short_4, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, _DataType_Vec_short_4, name)
    __repr__ = _swig_repr
    generic_type = _landmarkDetector._DataType_Vec_short_4_generic_type
    channels = _landmarkDetector._DataType_Vec_short_4_channels
    fmt = _landmarkDetector._DataType_Vec_short_4_fmt

    def __init__(self):
        this = _landmarkDetector.new__DataType_Vec_short_4()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _landmarkDetector.delete__DataType_Vec_short_4
    __del__ = lambda self: None
_DataType_Vec_short_4_swigregister = _landmarkDetector._DataType_Vec_short_4_swigregister
_DataType_Vec_short_4_swigregister(_DataType_Vec_short_4)


Vec4s = _Vec_short_4
DataType_Vec4s = _DataType_Vec_short_4

class _cv_numpy_sizeof_ushort(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, _cv_numpy_sizeof_ushort, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, _cv_numpy_sizeof_ushort, name)
    __repr__ = _swig_repr
    value = _landmarkDetector._cv_numpy_sizeof_ushort_value

    def __init__(self):
        this = _landmarkDetector.new__cv_numpy_sizeof_ushort()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _landmarkDetector.delete__cv_numpy_sizeof_ushort
    __del__ = lambda self: None
_cv_numpy_sizeof_ushort_swigregister = _landmarkDetector._cv_numpy_sizeof_ushort_swigregister
_cv_numpy_sizeof_ushort_swigregister(_cv_numpy_sizeof_ushort)


if _cv_numpy_sizeof_ushort.value == 1:
    _cv_numpy_typestr_map["ushort"] = "|" +"u" + "1"
else:
    _cv_numpy_typestr_map["ushort"] = _cv_numpy_endianess  +"u" + str(_cv_numpy_sizeof_ushort.value)

class _ushortArray(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, _ushortArray, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, _ushortArray, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _landmarkDetector._ushortArray_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _landmarkDetector._ushortArray___nonzero__(self)

    def __bool__(self):
        return _landmarkDetector._ushortArray___bool__(self)

    def __len__(self):
        return _landmarkDetector._ushortArray___len__(self)

    def __getslice__(self, i, j):
        return _landmarkDetector._ushortArray___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _landmarkDetector._ushortArray___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _landmarkDetector._ushortArray___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _landmarkDetector._ushortArray___delitem__(self, *args)

    def __getitem__(self, *args):
        return _landmarkDetector._ushortArray___getitem__(self, *args)

    def __setitem__(self, *args):
        return _landmarkDetector._ushortArray___setitem__(self, *args)

    def pop(self):
        return _landmarkDetector._ushortArray_pop(self)

    def append(self, x):
        return _landmarkDetector._ushortArray_append(self, x)

    def empty(self):
        return _landmarkDetector._ushortArray_empty(self)

    def size(self):
        return _landmarkDetector._ushortArray_size(self)

    def swap(self, v):
        return _landmarkDetector._ushortArray_swap(self, v)

    def begin(self):
        return _landmarkDetector._ushortArray_begin(self)

    def end(self):
        return _landmarkDetector._ushortArray_end(self)

    def rbegin(self):
        return _landmarkDetector._ushortArray_rbegin(self)

    def rend(self):
        return _landmarkDetector._ushortArray_rend(self)

    def clear(self):
        return _landmarkDetector._ushortArray_clear(self)

    def get_allocator(self):
        return _landmarkDetector._ushortArray_get_allocator(self)

    def pop_back(self):
        return _landmarkDetector._ushortArray_pop_back(self)

    def erase(self, *args):
        return _landmarkDetector._ushortArray_erase(self, *args)

    def __init__(self, *args):
        this = _landmarkDetector.new__ushortArray(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        return _landmarkDetector._ushortArray_push_back(self, x)

    def front(self):
        return _landmarkDetector._ushortArray_front(self)

    def back(self):
        return _landmarkDetector._ushortArray_back(self)

    def assign(self, n, x):
        return _landmarkDetector._ushortArray_assign(self, n, x)

    def resize(self, *args):
        return _landmarkDetector._ushortArray_resize(self, *args)

    def insert(self, *args):
        return _landmarkDetector._ushortArray_insert(self, *args)

    def reserve(self, n):
        return _landmarkDetector._ushortArray_reserve(self, n)

    def capacity(self):
        return _landmarkDetector._ushortArray_capacity(self)
    __swig_destroy__ = _landmarkDetector.delete__ushortArray
    __del__ = lambda self: None
_ushortArray_swigregister = _landmarkDetector._ushortArray_swigregister
_ushortArray_swigregister(_ushortArray)


_array_map["ushort"] = _ushortArray

class _Matx_ushort_2_1(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, _Matx_ushort_2_1, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, _Matx_ushort_2_1, name)
    __repr__ = _swig_repr
    rows = _landmarkDetector._Matx_ushort_2_1_rows
    cols = _landmarkDetector._Matx_ushort_2_1_cols
    channels = _landmarkDetector._Matx_ushort_2_1_channels
    shortdim = _landmarkDetector._Matx_ushort_2_1_shortdim
    if _newclass:
        all = staticmethod(_landmarkDetector._Matx_ushort_2_1_all)
    else:
        all = _landmarkDetector._Matx_ushort_2_1_all
    if _newclass:
        zeros = staticmethod(_landmarkDetector._Matx_ushort_2_1_zeros)
    else:
        zeros = _landmarkDetector._Matx_ushort_2_1_zeros
    if _newclass:
        ones = staticmethod(_landmarkDetector._Matx_ushort_2_1_ones)
    else:
        ones = _landmarkDetector._Matx_ushort_2_1_ones
    if _newclass:
        eye = staticmethod(_landmarkDetector._Matx_ushort_2_1_eye)
    else:
        eye = _landmarkDetector._Matx_ushort_2_1_eye
    if _newclass:
        randu = staticmethod(_landmarkDetector._Matx_ushort_2_1_randu)
    else:
        randu = _landmarkDetector._Matx_ushort_2_1_randu
    if _newclass:
        randn = staticmethod(_landmarkDetector._Matx_ushort_2_1_randn)
    else:
        randn = _landmarkDetector._Matx_ushort_2_1_randn

    def dot(self, v):
        return _landmarkDetector._Matx_ushort_2_1_dot(self, v)

    def ddot(self, v):
        return _landmarkDetector._Matx_ushort_2_1_ddot(self, v)

    def t(self):
        return _landmarkDetector._Matx_ushort_2_1_t(self)

    def mul(self, a):
        return _landmarkDetector._Matx_ushort_2_1_mul(self, a)

    def div(self, a):
        return _landmarkDetector._Matx_ushort_2_1_div(self, a)

    def __call__(self, i, j):
        return _landmarkDetector._Matx_ushort_2_1___call__(self, i, j)
    __swig_setmethods__["val"] = _landmarkDetector._Matx_ushort_2_1_val_set
    __swig_getmethods__["val"] = _landmarkDetector._Matx_ushort_2_1_val_get
    if _newclass:
        val = _swig_property(_landmarkDetector._Matx_ushort_2_1_val_get, _landmarkDetector._Matx_ushort_2_1_val_set)

    import re
    _re_pattern = re.compile("^_Matx_(?P<value_type>[a-zA-Z_][a-zA-Z0-9_]*)_(?P<rows>[0-9]+)_(?P<cols>[0-9]+)$")


    def __init__(self, *args):

        ma = self._re_pattern.match(self.__class__.__name__)
        value_type = ma.group("value_type")
        rows = int(ma.group("rows"))
        cols = int(ma.group("cols"))

        array = _array_map[value_type](rows*cols)
        for i in range(len(args)):
            array[i] = args[i]

        args = [array]


        this = _landmarkDetector.new__Matx_ushort_2_1(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def __getattribute__(self, name):
        if name == "__array_interface__":
            ma = self._re_pattern.match(self.__class__.__name__)
            value_type = ma.group("value_type")
            rows = int(ma.group("rows"))
            cols = int(ma.group("cols"))
            return {"shape": (rows, cols),
                    "typestr": _cv_numpy_typestr_map[value_type],
                    "data": (int(self.val), False)}
        else:
            return object.__getattribute__(self, name)


    def __getitem__(self, key):
        ma = self._re_pattern.match(self.__class__.__name__)
        rows = int(ma.group("rows"))
        cols = int(ma.group("cols"))

        if isinstance(key, int):
            if rows != 1 and cols != 1:
                raise IndexError
            i = key
            j = 0
        elif isinstance(key, tuple) and len(key) == 2:
            i = key[0]
            j = key[1]
        else:
            raise TypeError

        if i >= rows or j >= cols:
            raise IndexError

        return self(i, j)


    def __str__(self):
        return _landmarkDetector._Matx_ushort_2_1___str__(self)
    __swig_destroy__ = _landmarkDetector.delete__Matx_ushort_2_1
    __del__ = lambda self: None
_Matx_ushort_2_1_swigregister = _landmarkDetector._Matx_ushort_2_1_swigregister
_Matx_ushort_2_1_swigregister(_Matx_ushort_2_1)

def _Matx_ushort_2_1_all(alpha):
    return _landmarkDetector._Matx_ushort_2_1_all(alpha)
_Matx_ushort_2_1_all = _landmarkDetector._Matx_ushort_2_1_all

def _Matx_ushort_2_1_zeros():
    return _landmarkDetector._Matx_ushort_2_1_zeros()
_Matx_ushort_2_1_zeros = _landmarkDetector._Matx_ushort_2_1_zeros

def _Matx_ushort_2_1_ones():
    return _landmarkDetector._Matx_ushort_2_1_ones()
_Matx_ushort_2_1_ones = _landmarkDetector._Matx_ushort_2_1_ones

def _Matx_ushort_2_1_eye():
    return _landmarkDetector._Matx_ushort_2_1_eye()
_Matx_ushort_2_1_eye = _landmarkDetector._Matx_ushort_2_1_eye

def _Matx_ushort_2_1_randu(a, b):
    return _landmarkDetector._Matx_ushort_2_1_randu(a, b)
_Matx_ushort_2_1_randu = _landmarkDetector._Matx_ushort_2_1_randu

def _Matx_ushort_2_1_randn(a, b):
    return _landmarkDetector._Matx_ushort_2_1_randn(a, b)
_Matx_ushort_2_1_randn = _landmarkDetector._Matx_ushort_2_1_randn


Matx21w = _Matx_ushort_2_1

class _Vec_ushort_2(_Matx_ushort_2_1):
    __swig_setmethods__ = {}
    for _s in [_Matx_ushort_2_1]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, _Vec_ushort_2, name, value)
    __swig_getmethods__ = {}
    for _s in [_Matx_ushort_2_1]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, _Vec_ushort_2, name)
    __repr__ = _swig_repr
    channels = _landmarkDetector._Vec_ushort_2_channels
    if _newclass:
        all = staticmethod(_landmarkDetector._Vec_ushort_2_all)
    else:
        all = _landmarkDetector._Vec_ushort_2_all

    def mul(self, v):
        return _landmarkDetector._Vec_ushort_2_mul(self, v)

    def __call__(self, i):
        return _landmarkDetector._Vec_ushort_2___call__(self, i)

    import re
    _re_pattern = re.compile("^_Vec_(?P<value_type>[a-zA-Z_][a-zA-Z0-9_]*)_(?P<rows>[0-9]+)$")


    def __init__(self, *args):

        ma = self._re_pattern.match(self.__class__.__name__)
        value_type = ma.group("value_type")
        rows = int(ma.group("rows"))

        array = _array_map[value_type](rows)
        for i in range(len(args)):
            array[i] = args[i]

        args = [array]


        this = _landmarkDetector.new__Vec_ushort_2(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def __getattribute__(self, name):
        if name == "__array_interface__":
            ma = self._re_pattern.match(self.__class__.__name__)
            value_type = ma.group("value_type")
            rows = int(ma.group("rows"))
            return {"shape": (rows, 1),
                    "typestr": _cv_numpy_typestr_map[value_type],
                    "data": (int(self.val), False)}
        else:
            return object.__getattribute__(self, name)

    def __getitem__(self, key):
        ma = self._re_pattern.match(self.__class__.__name__)
        rows = int(ma.group("rows"))

        if not isinstance(key, int):
            raise TypeError

        if key >= rows:
            raise IndexError

        return self(key)


    def __str__(self):
        return _landmarkDetector._Vec_ushort_2___str__(self)
    __swig_destroy__ = _landmarkDetector.delete__Vec_ushort_2
    __del__ = lambda self: None
_Vec_ushort_2_swigregister = _landmarkDetector._Vec_ushort_2_swigregister
_Vec_ushort_2_swigregister(_Vec_ushort_2)

def _Vec_ushort_2_all(alpha):
    return _landmarkDetector._Vec_ushort_2_all(alpha)
_Vec_ushort_2_all = _landmarkDetector._Vec_ushort_2_all

class _DataType_Vec_ushort_2(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, _DataType_Vec_ushort_2, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, _DataType_Vec_ushort_2, name)
    __repr__ = _swig_repr
    generic_type = _landmarkDetector._DataType_Vec_ushort_2_generic_type
    channels = _landmarkDetector._DataType_Vec_ushort_2_channels
    fmt = _landmarkDetector._DataType_Vec_ushort_2_fmt

    def __init__(self):
        this = _landmarkDetector.new__DataType_Vec_ushort_2()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _landmarkDetector.delete__DataType_Vec_ushort_2
    __del__ = lambda self: None
_DataType_Vec_ushort_2_swigregister = _landmarkDetector._DataType_Vec_ushort_2_swigregister
_DataType_Vec_ushort_2_swigregister(_DataType_Vec_ushort_2)


Vec2w = _Vec_ushort_2
DataType_Vec2w = _DataType_Vec_ushort_2

class _Matx_ushort_3_1(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, _Matx_ushort_3_1, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, _Matx_ushort_3_1, name)
    __repr__ = _swig_repr
    rows = _landmarkDetector._Matx_ushort_3_1_rows
    cols = _landmarkDetector._Matx_ushort_3_1_cols
    channels = _landmarkDetector._Matx_ushort_3_1_channels
    shortdim = _landmarkDetector._Matx_ushort_3_1_shortdim
    if _newclass:
        all = staticmethod(_landmarkDetector._Matx_ushort_3_1_all)
    else:
        all = _landmarkDetector._Matx_ushort_3_1_all
    if _newclass:
        zeros = staticmethod(_landmarkDetector._Matx_ushort_3_1_zeros)
    else:
        zeros = _landmarkDetector._Matx_ushort_3_1_zeros
    if _newclass:
        ones = staticmethod(_landmarkDetector._Matx_ushort_3_1_ones)
    else:
        ones = _landmarkDetector._Matx_ushort_3_1_ones
    if _newclass:
        eye = staticmethod(_landmarkDetector._Matx_ushort_3_1_eye)
    else:
        eye = _landmarkDetector._Matx_ushort_3_1_eye
    if _newclass:
        randu = staticmethod(_landmarkDetector._Matx_ushort_3_1_randu)
    else:
        randu = _landmarkDetector._Matx_ushort_3_1_randu
    if _newclass:
        randn = staticmethod(_landmarkDetector._Matx_ushort_3_1_randn)
    else:
        randn = _landmarkDetector._Matx_ushort_3_1_randn

    def dot(self, v):
        return _landmarkDetector._Matx_ushort_3_1_dot(self, v)

    def ddot(self, v):
        return _landmarkDetector._Matx_ushort_3_1_ddot(self, v)

    def t(self):
        return _landmarkDetector._Matx_ushort_3_1_t(self)

    def mul(self, a):
        return _landmarkDetector._Matx_ushort_3_1_mul(self, a)

    def div(self, a):
        return _landmarkDetector._Matx_ushort_3_1_div(self, a)

    def __call__(self, i, j):
        return _landmarkDetector._Matx_ushort_3_1___call__(self, i, j)
    __swig_setmethods__["val"] = _landmarkDetector._Matx_ushort_3_1_val_set
    __swig_getmethods__["val"] = _landmarkDetector._Matx_ushort_3_1_val_get
    if _newclass:
        val = _swig_property(_landmarkDetector._Matx_ushort_3_1_val_get, _landmarkDetector._Matx_ushort_3_1_val_set)

    import re
    _re_pattern = re.compile("^_Matx_(?P<value_type>[a-zA-Z_][a-zA-Z0-9_]*)_(?P<rows>[0-9]+)_(?P<cols>[0-9]+)$")


    def __init__(self, *args):

        ma = self._re_pattern.match(self.__class__.__name__)
        value_type = ma.group("value_type")
        rows = int(ma.group("rows"))
        cols = int(ma.group("cols"))

        array = _array_map[value_type](rows*cols)
        for i in range(len(args)):
            array[i] = args[i]

        args = [array]


        this = _landmarkDetector.new__Matx_ushort_3_1(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def __getattribute__(self, name):
        if name == "__array_interface__":
            ma = self._re_pattern.match(self.__class__.__name__)
            value_type = ma.group("value_type")
            rows = int(ma.group("rows"))
            cols = int(ma.group("cols"))
            return {"shape": (rows, cols),
                    "typestr": _cv_numpy_typestr_map[value_type],
                    "data": (int(self.val), False)}
        else:
            return object.__getattribute__(self, name)


    def __getitem__(self, key):
        ma = self._re_pattern.match(self.__class__.__name__)
        rows = int(ma.group("rows"))
        cols = int(ma.group("cols"))

        if isinstance(key, int):
            if rows != 1 and cols != 1:
                raise IndexError
            i = key
            j = 0
        elif isinstance(key, tuple) and len(key) == 2:
            i = key[0]
            j = key[1]
        else:
            raise TypeError

        if i >= rows or j >= cols:
            raise IndexError

        return self(i, j)


    def __str__(self):
        return _landmarkDetector._Matx_ushort_3_1___str__(self)
    __swig_destroy__ = _landmarkDetector.delete__Matx_ushort_3_1
    __del__ = lambda self: None
_Matx_ushort_3_1_swigregister = _landmarkDetector._Matx_ushort_3_1_swigregister
_Matx_ushort_3_1_swigregister(_Matx_ushort_3_1)

def _Matx_ushort_3_1_all(alpha):
    return _landmarkDetector._Matx_ushort_3_1_all(alpha)
_Matx_ushort_3_1_all = _landmarkDetector._Matx_ushort_3_1_all

def _Matx_ushort_3_1_zeros():
    return _landmarkDetector._Matx_ushort_3_1_zeros()
_Matx_ushort_3_1_zeros = _landmarkDetector._Matx_ushort_3_1_zeros

def _Matx_ushort_3_1_ones():
    return _landmarkDetector._Matx_ushort_3_1_ones()
_Matx_ushort_3_1_ones = _landmarkDetector._Matx_ushort_3_1_ones

def _Matx_ushort_3_1_eye():
    return _landmarkDetector._Matx_ushort_3_1_eye()
_Matx_ushort_3_1_eye = _landmarkDetector._Matx_ushort_3_1_eye

def _Matx_ushort_3_1_randu(a, b):
    return _landmarkDetector._Matx_ushort_3_1_randu(a, b)
_Matx_ushort_3_1_randu = _landmarkDetector._Matx_ushort_3_1_randu

def _Matx_ushort_3_1_randn(a, b):
    return _landmarkDetector._Matx_ushort_3_1_randn(a, b)
_Matx_ushort_3_1_randn = _landmarkDetector._Matx_ushort_3_1_randn


Matx31w = _Matx_ushort_3_1

class _Vec_ushort_3(_Matx_ushort_3_1):
    __swig_setmethods__ = {}
    for _s in [_Matx_ushort_3_1]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, _Vec_ushort_3, name, value)
    __swig_getmethods__ = {}
    for _s in [_Matx_ushort_3_1]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, _Vec_ushort_3, name)
    __repr__ = _swig_repr
    channels = _landmarkDetector._Vec_ushort_3_channels
    if _newclass:
        all = staticmethod(_landmarkDetector._Vec_ushort_3_all)
    else:
        all = _landmarkDetector._Vec_ushort_3_all

    def mul(self, v):
        return _landmarkDetector._Vec_ushort_3_mul(self, v)

    def __call__(self, i):
        return _landmarkDetector._Vec_ushort_3___call__(self, i)

    import re
    _re_pattern = re.compile("^_Vec_(?P<value_type>[a-zA-Z_][a-zA-Z0-9_]*)_(?P<rows>[0-9]+)$")


    def __init__(self, *args):

        ma = self._re_pattern.match(self.__class__.__name__)
        value_type = ma.group("value_type")
        rows = int(ma.group("rows"))

        array = _array_map[value_type](rows)
        for i in range(len(args)):
            array[i] = args[i]

        args = [array]


        this = _landmarkDetector.new__Vec_ushort_3(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def __getattribute__(self, name):
        if name == "__array_interface__":
            ma = self._re_pattern.match(self.__class__.__name__)
            value_type = ma.group("value_type")
            rows = int(ma.group("rows"))
            return {"shape": (rows, 1),
                    "typestr": _cv_numpy_typestr_map[value_type],
                    "data": (int(self.val), False)}
        else:
            return object.__getattribute__(self, name)

    def __getitem__(self, key):
        ma = self._re_pattern.match(self.__class__.__name__)
        rows = int(ma.group("rows"))

        if not isinstance(key, int):
            raise TypeError

        if key >= rows:
            raise IndexError

        return self(key)


    def __str__(self):
        return _landmarkDetector._Vec_ushort_3___str__(self)
    __swig_destroy__ = _landmarkDetector.delete__Vec_ushort_3
    __del__ = lambda self: None
_Vec_ushort_3_swigregister = _landmarkDetector._Vec_ushort_3_swigregister
_Vec_ushort_3_swigregister(_Vec_ushort_3)

def _Vec_ushort_3_all(alpha):
    return _landmarkDetector._Vec_ushort_3_all(alpha)
_Vec_ushort_3_all = _landmarkDetector._Vec_ushort_3_all

class _DataType_Vec_ushort_3(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, _DataType_Vec_ushort_3, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, _DataType_Vec_ushort_3, name)
    __repr__ = _swig_repr
    generic_type = _landmarkDetector._DataType_Vec_ushort_3_generic_type
    channels = _landmarkDetector._DataType_Vec_ushort_3_channels
    fmt = _landmarkDetector._DataType_Vec_ushort_3_fmt

    def __init__(self):
        this = _landmarkDetector.new__DataType_Vec_ushort_3()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _landmarkDetector.delete__DataType_Vec_ushort_3
    __del__ = lambda self: None
_DataType_Vec_ushort_3_swigregister = _landmarkDetector._DataType_Vec_ushort_3_swigregister
_DataType_Vec_ushort_3_swigregister(_DataType_Vec_ushort_3)


Vec3w = _Vec_ushort_3
DataType_Vec3w = _DataType_Vec_ushort_3

class _Matx_ushort_4_1(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, _Matx_ushort_4_1, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, _Matx_ushort_4_1, name)
    __repr__ = _swig_repr
    rows = _landmarkDetector._Matx_ushort_4_1_rows
    cols = _landmarkDetector._Matx_ushort_4_1_cols
    channels = _landmarkDetector._Matx_ushort_4_1_channels
    shortdim = _landmarkDetector._Matx_ushort_4_1_shortdim
    if _newclass:
        all = staticmethod(_landmarkDetector._Matx_ushort_4_1_all)
    else:
        all = _landmarkDetector._Matx_ushort_4_1_all
    if _newclass:
        zeros = staticmethod(_landmarkDetector._Matx_ushort_4_1_zeros)
    else:
        zeros = _landmarkDetector._Matx_ushort_4_1_zeros
    if _newclass:
        ones = staticmethod(_landmarkDetector._Matx_ushort_4_1_ones)
    else:
        ones = _landmarkDetector._Matx_ushort_4_1_ones
    if _newclass:
        eye = staticmethod(_landmarkDetector._Matx_ushort_4_1_eye)
    else:
        eye = _landmarkDetector._Matx_ushort_4_1_eye
    if _newclass:
        randu = staticmethod(_landmarkDetector._Matx_ushort_4_1_randu)
    else:
        randu = _landmarkDetector._Matx_ushort_4_1_randu
    if _newclass:
        randn = staticmethod(_landmarkDetector._Matx_ushort_4_1_randn)
    else:
        randn = _landmarkDetector._Matx_ushort_4_1_randn

    def dot(self, v):
        return _landmarkDetector._Matx_ushort_4_1_dot(self, v)

    def ddot(self, v):
        return _landmarkDetector._Matx_ushort_4_1_ddot(self, v)

    def t(self):
        return _landmarkDetector._Matx_ushort_4_1_t(self)

    def mul(self, a):
        return _landmarkDetector._Matx_ushort_4_1_mul(self, a)

    def div(self, a):
        return _landmarkDetector._Matx_ushort_4_1_div(self, a)

    def __call__(self, i, j):
        return _landmarkDetector._Matx_ushort_4_1___call__(self, i, j)
    __swig_setmethods__["val"] = _landmarkDetector._Matx_ushort_4_1_val_set
    __swig_getmethods__["val"] = _landmarkDetector._Matx_ushort_4_1_val_get
    if _newclass:
        val = _swig_property(_landmarkDetector._Matx_ushort_4_1_val_get, _landmarkDetector._Matx_ushort_4_1_val_set)

    import re
    _re_pattern = re.compile("^_Matx_(?P<value_type>[a-zA-Z_][a-zA-Z0-9_]*)_(?P<rows>[0-9]+)_(?P<cols>[0-9]+)$")


    def __init__(self, *args):

        ma = self._re_pattern.match(self.__class__.__name__)
        value_type = ma.group("value_type")
        rows = int(ma.group("rows"))
        cols = int(ma.group("cols"))

        array = _array_map[value_type](rows*cols)
        for i in range(len(args)):
            array[i] = args[i]

        args = [array]


        this = _landmarkDetector.new__Matx_ushort_4_1(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def __getattribute__(self, name):
        if name == "__array_interface__":
            ma = self._re_pattern.match(self.__class__.__name__)
            value_type = ma.group("value_type")
            rows = int(ma.group("rows"))
            cols = int(ma.group("cols"))
            return {"shape": (rows, cols),
                    "typestr": _cv_numpy_typestr_map[value_type],
                    "data": (int(self.val), False)}
        else:
            return object.__getattribute__(self, name)


    def __getitem__(self, key):
        ma = self._re_pattern.match(self.__class__.__name__)
        rows = int(ma.group("rows"))
        cols = int(ma.group("cols"))

        if isinstance(key, int):
            if rows != 1 and cols != 1:
                raise IndexError
            i = key
            j = 0
        elif isinstance(key, tuple) and len(key) == 2:
            i = key[0]
            j = key[1]
        else:
            raise TypeError

        if i >= rows or j >= cols:
            raise IndexError

        return self(i, j)


    def __str__(self):
        return _landmarkDetector._Matx_ushort_4_1___str__(self)
    __swig_destroy__ = _landmarkDetector.delete__Matx_ushort_4_1
    __del__ = lambda self: None
_Matx_ushort_4_1_swigregister = _landmarkDetector._Matx_ushort_4_1_swigregister
_Matx_ushort_4_1_swigregister(_Matx_ushort_4_1)

def _Matx_ushort_4_1_all(alpha):
    return _landmarkDetector._Matx_ushort_4_1_all(alpha)
_Matx_ushort_4_1_all = _landmarkDetector._Matx_ushort_4_1_all

def _Matx_ushort_4_1_zeros():
    return _landmarkDetector._Matx_ushort_4_1_zeros()
_Matx_ushort_4_1_zeros = _landmarkDetector._Matx_ushort_4_1_zeros

def _Matx_ushort_4_1_ones():
    return _landmarkDetector._Matx_ushort_4_1_ones()
_Matx_ushort_4_1_ones = _landmarkDetector._Matx_ushort_4_1_ones

def _Matx_ushort_4_1_eye():
    return _landmarkDetector._Matx_ushort_4_1_eye()
_Matx_ushort_4_1_eye = _landmarkDetector._Matx_ushort_4_1_eye

def _Matx_ushort_4_1_randu(a, b):
    return _landmarkDetector._Matx_ushort_4_1_randu(a, b)
_Matx_ushort_4_1_randu = _landmarkDetector._Matx_ushort_4_1_randu

def _Matx_ushort_4_1_randn(a, b):
    return _landmarkDetector._Matx_ushort_4_1_randn(a, b)
_Matx_ushort_4_1_randn = _landmarkDetector._Matx_ushort_4_1_randn


Matx41w = _Matx_ushort_4_1

class _Vec_ushort_4(_Matx_ushort_4_1):
    __swig_setmethods__ = {}
    for _s in [_Matx_ushort_4_1]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, _Vec_ushort_4, name, value)
    __swig_getmethods__ = {}
    for _s in [_Matx_ushort_4_1]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, _Vec_ushort_4, name)
    __repr__ = _swig_repr
    channels = _landmarkDetector._Vec_ushort_4_channels
    if _newclass:
        all = staticmethod(_landmarkDetector._Vec_ushort_4_all)
    else:
        all = _landmarkDetector._Vec_ushort_4_all

    def mul(self, v):
        return _landmarkDetector._Vec_ushort_4_mul(self, v)

    def __call__(self, i):
        return _landmarkDetector._Vec_ushort_4___call__(self, i)

    import re
    _re_pattern = re.compile("^_Vec_(?P<value_type>[a-zA-Z_][a-zA-Z0-9_]*)_(?P<rows>[0-9]+)$")


    def __init__(self, *args):

        ma = self._re_pattern.match(self.__class__.__name__)
        value_type = ma.group("value_type")
        rows = int(ma.group("rows"))

        array = _array_map[value_type](rows)
        for i in range(len(args)):
            array[i] = args[i]

        args = [array]


        this = _landmarkDetector.new__Vec_ushort_4(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def __getattribute__(self, name):
        if name == "__array_interface__":
            ma = self._re_pattern.match(self.__class__.__name__)
            value_type = ma.group("value_type")
            rows = int(ma.group("rows"))
            return {"shape": (rows, 1),
                    "typestr": _cv_numpy_typestr_map[value_type],
                    "data": (int(self.val), False)}
        else:
            return object.__getattribute__(self, name)

    def __getitem__(self, key):
        ma = self._re_pattern.match(self.__class__.__name__)
        rows = int(ma.group("rows"))

        if not isinstance(key, int):
            raise TypeError

        if key >= rows:
            raise IndexError

        return self(key)


    def __str__(self):
        return _landmarkDetector._Vec_ushort_4___str__(self)
    __swig_destroy__ = _landmarkDetector.delete__Vec_ushort_4
    __del__ = lambda self: None
_Vec_ushort_4_swigregister = _landmarkDetector._Vec_ushort_4_swigregister
_Vec_ushort_4_swigregister(_Vec_ushort_4)

def _Vec_ushort_4_all(alpha):
    return _landmarkDetector._Vec_ushort_4_all(alpha)
_Vec_ushort_4_all = _landmarkDetector._Vec_ushort_4_all

class _DataType_Vec_ushort_4(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, _DataType_Vec_ushort_4, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, _DataType_Vec_ushort_4, name)
    __repr__ = _swig_repr
    generic_type = _landmarkDetector._DataType_Vec_ushort_4_generic_type
    channels = _landmarkDetector._DataType_Vec_ushort_4_channels
    fmt = _landmarkDetector._DataType_Vec_ushort_4_fmt

    def __init__(self):
        this = _landmarkDetector.new__DataType_Vec_ushort_4()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _landmarkDetector.delete__DataType_Vec_ushort_4
    __del__ = lambda self: None
_DataType_Vec_ushort_4_swigregister = _landmarkDetector._DataType_Vec_ushort_4_swigregister
_DataType_Vec_ushort_4_swigregister(_DataType_Vec_ushort_4)


Vec4w = _Vec_ushort_4
DataType_Vec4w = _DataType_Vec_ushort_4

class _cv_numpy_sizeof_int(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, _cv_numpy_sizeof_int, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, _cv_numpy_sizeof_int, name)
    __repr__ = _swig_repr
    value = _landmarkDetector._cv_numpy_sizeof_int_value

    def __init__(self):
        this = _landmarkDetector.new__cv_numpy_sizeof_int()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _landmarkDetector.delete__cv_numpy_sizeof_int
    __del__ = lambda self: None
_cv_numpy_sizeof_int_swigregister = _landmarkDetector._cv_numpy_sizeof_int_swigregister
_cv_numpy_sizeof_int_swigregister(_cv_numpy_sizeof_int)


if _cv_numpy_sizeof_int.value == 1:
    _cv_numpy_typestr_map["int"] = "|" +"i" + "1"
else:
    _cv_numpy_typestr_map["int"] = _cv_numpy_endianess  +"i" + str(_cv_numpy_sizeof_int.value)

class _intArray(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, _intArray, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, _intArray, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _landmarkDetector._intArray_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _landmarkDetector._intArray___nonzero__(self)

    def __bool__(self):
        return _landmarkDetector._intArray___bool__(self)

    def __len__(self):
        return _landmarkDetector._intArray___len__(self)

    def __getslice__(self, i, j):
        return _landmarkDetector._intArray___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _landmarkDetector._intArray___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _landmarkDetector._intArray___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _landmarkDetector._intArray___delitem__(self, *args)

    def __getitem__(self, *args):
        return _landmarkDetector._intArray___getitem__(self, *args)

    def __setitem__(self, *args):
        return _landmarkDetector._intArray___setitem__(self, *args)

    def pop(self):
        return _landmarkDetector._intArray_pop(self)

    def append(self, x):
        return _landmarkDetector._intArray_append(self, x)

    def empty(self):
        return _landmarkDetector._intArray_empty(self)

    def size(self):
        return _landmarkDetector._intArray_size(self)

    def swap(self, v):
        return _landmarkDetector._intArray_swap(self, v)

    def begin(self):
        return _landmarkDetector._intArray_begin(self)

    def end(self):
        return _landmarkDetector._intArray_end(self)

    def rbegin(self):
        return _landmarkDetector._intArray_rbegin(self)

    def rend(self):
        return _landmarkDetector._intArray_rend(self)

    def clear(self):
        return _landmarkDetector._intArray_clear(self)

    def get_allocator(self):
        return _landmarkDetector._intArray_get_allocator(self)

    def pop_back(self):
        return _landmarkDetector._intArray_pop_back(self)

    def erase(self, *args):
        return _landmarkDetector._intArray_erase(self, *args)

    def __init__(self, *args):
        this = _landmarkDetector.new__intArray(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        return _landmarkDetector._intArray_push_back(self, x)

    def front(self):
        return _landmarkDetector._intArray_front(self)

    def back(self):
        return _landmarkDetector._intArray_back(self)

    def assign(self, n, x):
        return _landmarkDetector._intArray_assign(self, n, x)

    def resize(self, *args):
        return _landmarkDetector._intArray_resize(self, *args)

    def insert(self, *args):
        return _landmarkDetector._intArray_insert(self, *args)

    def reserve(self, n):
        return _landmarkDetector._intArray_reserve(self, n)

    def capacity(self):
        return _landmarkDetector._intArray_capacity(self)
    __swig_destroy__ = _landmarkDetector.delete__intArray
    __del__ = lambda self: None
_intArray_swigregister = _landmarkDetector._intArray_swigregister
_intArray_swigregister(_intArray)


_array_map["int"] = _intArray

class _Matx_int_2_1(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, _Matx_int_2_1, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, _Matx_int_2_1, name)
    __repr__ = _swig_repr
    rows = _landmarkDetector._Matx_int_2_1_rows
    cols = _landmarkDetector._Matx_int_2_1_cols
    channels = _landmarkDetector._Matx_int_2_1_channels
    shortdim = _landmarkDetector._Matx_int_2_1_shortdim
    if _newclass:
        all = staticmethod(_landmarkDetector._Matx_int_2_1_all)
    else:
        all = _landmarkDetector._Matx_int_2_1_all
    if _newclass:
        zeros = staticmethod(_landmarkDetector._Matx_int_2_1_zeros)
    else:
        zeros = _landmarkDetector._Matx_int_2_1_zeros
    if _newclass:
        ones = staticmethod(_landmarkDetector._Matx_int_2_1_ones)
    else:
        ones = _landmarkDetector._Matx_int_2_1_ones
    if _newclass:
        eye = staticmethod(_landmarkDetector._Matx_int_2_1_eye)
    else:
        eye = _landmarkDetector._Matx_int_2_1_eye
    if _newclass:
        randu = staticmethod(_landmarkDetector._Matx_int_2_1_randu)
    else:
        randu = _landmarkDetector._Matx_int_2_1_randu
    if _newclass:
        randn = staticmethod(_landmarkDetector._Matx_int_2_1_randn)
    else:
        randn = _landmarkDetector._Matx_int_2_1_randn

    def dot(self, v):
        return _landmarkDetector._Matx_int_2_1_dot(self, v)

    def ddot(self, v):
        return _landmarkDetector._Matx_int_2_1_ddot(self, v)

    def t(self):
        return _landmarkDetector._Matx_int_2_1_t(self)

    def mul(self, a):
        return _landmarkDetector._Matx_int_2_1_mul(self, a)

    def div(self, a):
        return _landmarkDetector._Matx_int_2_1_div(self, a)

    def __call__(self, i, j):
        return _landmarkDetector._Matx_int_2_1___call__(self, i, j)
    __swig_setmethods__["val"] = _landmarkDetector._Matx_int_2_1_val_set
    __swig_getmethods__["val"] = _landmarkDetector._Matx_int_2_1_val_get
    if _newclass:
        val = _swig_property(_landmarkDetector._Matx_int_2_1_val_get, _landmarkDetector._Matx_int_2_1_val_set)

    import re
    _re_pattern = re.compile("^_Matx_(?P<value_type>[a-zA-Z_][a-zA-Z0-9_]*)_(?P<rows>[0-9]+)_(?P<cols>[0-9]+)$")


    def __init__(self, *args):

        ma = self._re_pattern.match(self.__class__.__name__)
        value_type = ma.group("value_type")
        rows = int(ma.group("rows"))
        cols = int(ma.group("cols"))

        array = _array_map[value_type](rows*cols)
        for i in range(len(args)):
            array[i] = args[i]

        args = [array]


        this = _landmarkDetector.new__Matx_int_2_1(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def __getattribute__(self, name):
        if name == "__array_interface__":
            ma = self._re_pattern.match(self.__class__.__name__)
            value_type = ma.group("value_type")
            rows = int(ma.group("rows"))
            cols = int(ma.group("cols"))
            return {"shape": (rows, cols),
                    "typestr": _cv_numpy_typestr_map[value_type],
                    "data": (int(self.val), False)}
        else:
            return object.__getattribute__(self, name)


    def __getitem__(self, key):
        ma = self._re_pattern.match(self.__class__.__name__)
        rows = int(ma.group("rows"))
        cols = int(ma.group("cols"))

        if isinstance(key, int):
            if rows != 1 and cols != 1:
                raise IndexError
            i = key
            j = 0
        elif isinstance(key, tuple) and len(key) == 2:
            i = key[0]
            j = key[1]
        else:
            raise TypeError

        if i >= rows or j >= cols:
            raise IndexError

        return self(i, j)


    def __str__(self):
        return _landmarkDetector._Matx_int_2_1___str__(self)
    __swig_destroy__ = _landmarkDetector.delete__Matx_int_2_1
    __del__ = lambda self: None
_Matx_int_2_1_swigregister = _landmarkDetector._Matx_int_2_1_swigregister
_Matx_int_2_1_swigregister(_Matx_int_2_1)

def _Matx_int_2_1_all(alpha):
    return _landmarkDetector._Matx_int_2_1_all(alpha)
_Matx_int_2_1_all = _landmarkDetector._Matx_int_2_1_all

def _Matx_int_2_1_zeros():
    return _landmarkDetector._Matx_int_2_1_zeros()
_Matx_int_2_1_zeros = _landmarkDetector._Matx_int_2_1_zeros

def _Matx_int_2_1_ones():
    return _landmarkDetector._Matx_int_2_1_ones()
_Matx_int_2_1_ones = _landmarkDetector._Matx_int_2_1_ones

def _Matx_int_2_1_eye():
    return _landmarkDetector._Matx_int_2_1_eye()
_Matx_int_2_1_eye = _landmarkDetector._Matx_int_2_1_eye

def _Matx_int_2_1_randu(a, b):
    return _landmarkDetector._Matx_int_2_1_randu(a, b)
_Matx_int_2_1_randu = _landmarkDetector._Matx_int_2_1_randu

def _Matx_int_2_1_randn(a, b):
    return _landmarkDetector._Matx_int_2_1_randn(a, b)
_Matx_int_2_1_randn = _landmarkDetector._Matx_int_2_1_randn


Matx21i = _Matx_int_2_1

class _Vec_int_2(_Matx_int_2_1):
    __swig_setmethods__ = {}
    for _s in [_Matx_int_2_1]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, _Vec_int_2, name, value)
    __swig_getmethods__ = {}
    for _s in [_Matx_int_2_1]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, _Vec_int_2, name)
    __repr__ = _swig_repr
    channels = _landmarkDetector._Vec_int_2_channels
    if _newclass:
        all = staticmethod(_landmarkDetector._Vec_int_2_all)
    else:
        all = _landmarkDetector._Vec_int_2_all

    def mul(self, v):
        return _landmarkDetector._Vec_int_2_mul(self, v)

    def __call__(self, i):
        return _landmarkDetector._Vec_int_2___call__(self, i)

    import re
    _re_pattern = re.compile("^_Vec_(?P<value_type>[a-zA-Z_][a-zA-Z0-9_]*)_(?P<rows>[0-9]+)$")


    def __init__(self, *args):

        ma = self._re_pattern.match(self.__class__.__name__)
        value_type = ma.group("value_type")
        rows = int(ma.group("rows"))

        array = _array_map[value_type](rows)
        for i in range(len(args)):
            array[i] = args[i]

        args = [array]


        this = _landmarkDetector.new__Vec_int_2(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def __getattribute__(self, name):
        if name == "__array_interface__":
            ma = self._re_pattern.match(self.__class__.__name__)
            value_type = ma.group("value_type")
            rows = int(ma.group("rows"))
            return {"shape": (rows, 1),
                    "typestr": _cv_numpy_typestr_map[value_type],
                    "data": (int(self.val), False)}
        else:
            return object.__getattribute__(self, name)

    def __getitem__(self, key):
        ma = self._re_pattern.match(self.__class__.__name__)
        rows = int(ma.group("rows"))

        if not isinstance(key, int):
            raise TypeError

        if key >= rows:
            raise IndexError

        return self(key)


    def __str__(self):
        return _landmarkDetector._Vec_int_2___str__(self)
    __swig_destroy__ = _landmarkDetector.delete__Vec_int_2
    __del__ = lambda self: None
_Vec_int_2_swigregister = _landmarkDetector._Vec_int_2_swigregister
_Vec_int_2_swigregister(_Vec_int_2)

def _Vec_int_2_all(alpha):
    return _landmarkDetector._Vec_int_2_all(alpha)
_Vec_int_2_all = _landmarkDetector._Vec_int_2_all

class _DataType_Vec_int_2(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, _DataType_Vec_int_2, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, _DataType_Vec_int_2, name)
    __repr__ = _swig_repr
    generic_type = _landmarkDetector._DataType_Vec_int_2_generic_type
    channels = _landmarkDetector._DataType_Vec_int_2_channels
    fmt = _landmarkDetector._DataType_Vec_int_2_fmt

    def __init__(self):
        this = _landmarkDetector.new__DataType_Vec_int_2()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _landmarkDetector.delete__DataType_Vec_int_2
    __del__ = lambda self: None
_DataType_Vec_int_2_swigregister = _landmarkDetector._DataType_Vec_int_2_swigregister
_DataType_Vec_int_2_swigregister(_DataType_Vec_int_2)


Vec2i = _Vec_int_2
DataType_Vec2i = _DataType_Vec_int_2

class _Matx_int_3_1(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, _Matx_int_3_1, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, _Matx_int_3_1, name)
    __repr__ = _swig_repr
    rows = _landmarkDetector._Matx_int_3_1_rows
    cols = _landmarkDetector._Matx_int_3_1_cols
    channels = _landmarkDetector._Matx_int_3_1_channels
    shortdim = _landmarkDetector._Matx_int_3_1_shortdim
    if _newclass:
        all = staticmethod(_landmarkDetector._Matx_int_3_1_all)
    else:
        all = _landmarkDetector._Matx_int_3_1_all
    if _newclass:
        zeros = staticmethod(_landmarkDetector._Matx_int_3_1_zeros)
    else:
        zeros = _landmarkDetector._Matx_int_3_1_zeros
    if _newclass:
        ones = staticmethod(_landmarkDetector._Matx_int_3_1_ones)
    else:
        ones = _landmarkDetector._Matx_int_3_1_ones
    if _newclass:
        eye = staticmethod(_landmarkDetector._Matx_int_3_1_eye)
    else:
        eye = _landmarkDetector._Matx_int_3_1_eye
    if _newclass:
        randu = staticmethod(_landmarkDetector._Matx_int_3_1_randu)
    else:
        randu = _landmarkDetector._Matx_int_3_1_randu
    if _newclass:
        randn = staticmethod(_landmarkDetector._Matx_int_3_1_randn)
    else:
        randn = _landmarkDetector._Matx_int_3_1_randn

    def dot(self, v):
        return _landmarkDetector._Matx_int_3_1_dot(self, v)

    def ddot(self, v):
        return _landmarkDetector._Matx_int_3_1_ddot(self, v)

    def t(self):
        return _landmarkDetector._Matx_int_3_1_t(self)

    def mul(self, a):
        return _landmarkDetector._Matx_int_3_1_mul(self, a)

    def div(self, a):
        return _landmarkDetector._Matx_int_3_1_div(self, a)

    def __call__(self, i, j):
        return _landmarkDetector._Matx_int_3_1___call__(self, i, j)
    __swig_setmethods__["val"] = _landmarkDetector._Matx_int_3_1_val_set
    __swig_getmethods__["val"] = _landmarkDetector._Matx_int_3_1_val_get
    if _newclass:
        val = _swig_property(_landmarkDetector._Matx_int_3_1_val_get, _landmarkDetector._Matx_int_3_1_val_set)

    import re
    _re_pattern = re.compile("^_Matx_(?P<value_type>[a-zA-Z_][a-zA-Z0-9_]*)_(?P<rows>[0-9]+)_(?P<cols>[0-9]+)$")


    def __init__(self, *args):

        ma = self._re_pattern.match(self.__class__.__name__)
        value_type = ma.group("value_type")
        rows = int(ma.group("rows"))
        cols = int(ma.group("cols"))

        array = _array_map[value_type](rows*cols)
        for i in range(len(args)):
            array[i] = args[i]

        args = [array]


        this = _landmarkDetector.new__Matx_int_3_1(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def __getattribute__(self, name):
        if name == "__array_interface__":
            ma = self._re_pattern.match(self.__class__.__name__)
            value_type = ma.group("value_type")
            rows = int(ma.group("rows"))
            cols = int(ma.group("cols"))
            return {"shape": (rows, cols),
                    "typestr": _cv_numpy_typestr_map[value_type],
                    "data": (int(self.val), False)}
        else:
            return object.__getattribute__(self, name)


    def __getitem__(self, key):
        ma = self._re_pattern.match(self.__class__.__name__)
        rows = int(ma.group("rows"))
        cols = int(ma.group("cols"))

        if isinstance(key, int):
            if rows != 1 and cols != 1:
                raise IndexError
            i = key
            j = 0
        elif isinstance(key, tuple) and len(key) == 2:
            i = key[0]
            j = key[1]
        else:
            raise TypeError

        if i >= rows or j >= cols:
            raise IndexError

        return self(i, j)


    def __str__(self):
        return _landmarkDetector._Matx_int_3_1___str__(self)
    __swig_destroy__ = _landmarkDetector.delete__Matx_int_3_1
    __del__ = lambda self: None
_Matx_int_3_1_swigregister = _landmarkDetector._Matx_int_3_1_swigregister
_Matx_int_3_1_swigregister(_Matx_int_3_1)

def _Matx_int_3_1_all(alpha):
    return _landmarkDetector._Matx_int_3_1_all(alpha)
_Matx_int_3_1_all = _landmarkDetector._Matx_int_3_1_all

def _Matx_int_3_1_zeros():
    return _landmarkDetector._Matx_int_3_1_zeros()
_Matx_int_3_1_zeros = _landmarkDetector._Matx_int_3_1_zeros

def _Matx_int_3_1_ones():
    return _landmarkDetector._Matx_int_3_1_ones()
_Matx_int_3_1_ones = _landmarkDetector._Matx_int_3_1_ones

def _Matx_int_3_1_eye():
    return _landmarkDetector._Matx_int_3_1_eye()
_Matx_int_3_1_eye = _landmarkDetector._Matx_int_3_1_eye

def _Matx_int_3_1_randu(a, b):
    return _landmarkDetector._Matx_int_3_1_randu(a, b)
_Matx_int_3_1_randu = _landmarkDetector._Matx_int_3_1_randu

def _Matx_int_3_1_randn(a, b):
    return _landmarkDetector._Matx_int_3_1_randn(a, b)
_Matx_int_3_1_randn = _landmarkDetector._Matx_int_3_1_randn


Matx31i = _Matx_int_3_1

class _Vec_int_3(_Matx_int_3_1):
    __swig_setmethods__ = {}
    for _s in [_Matx_int_3_1]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, _Vec_int_3, name, value)
    __swig_getmethods__ = {}
    for _s in [_Matx_int_3_1]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, _Vec_int_3, name)
    __repr__ = _swig_repr
    channels = _landmarkDetector._Vec_int_3_channels
    if _newclass:
        all = staticmethod(_landmarkDetector._Vec_int_3_all)
    else:
        all = _landmarkDetector._Vec_int_3_all

    def mul(self, v):
        return _landmarkDetector._Vec_int_3_mul(self, v)

    def __call__(self, i):
        return _landmarkDetector._Vec_int_3___call__(self, i)

    import re
    _re_pattern = re.compile("^_Vec_(?P<value_type>[a-zA-Z_][a-zA-Z0-9_]*)_(?P<rows>[0-9]+)$")


    def __init__(self, *args):

        ma = self._re_pattern.match(self.__class__.__name__)
        value_type = ma.group("value_type")
        rows = int(ma.group("rows"))

        array = _array_map[value_type](rows)
        for i in range(len(args)):
            array[i] = args[i]

        args = [array]


        this = _landmarkDetector.new__Vec_int_3(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def __getattribute__(self, name):
        if name == "__array_interface__":
            ma = self._re_pattern.match(self.__class__.__name__)
            value_type = ma.group("value_type")
            rows = int(ma.group("rows"))
            return {"shape": (rows, 1),
                    "typestr": _cv_numpy_typestr_map[value_type],
                    "data": (int(self.val), False)}
        else:
            return object.__getattribute__(self, name)

    def __getitem__(self, key):
        ma = self._re_pattern.match(self.__class__.__name__)
        rows = int(ma.group("rows"))

        if not isinstance(key, int):
            raise TypeError

        if key >= rows:
            raise IndexError

        return self(key)


    def __str__(self):
        return _landmarkDetector._Vec_int_3___str__(self)
    __swig_destroy__ = _landmarkDetector.delete__Vec_int_3
    __del__ = lambda self: None
_Vec_int_3_swigregister = _landmarkDetector._Vec_int_3_swigregister
_Vec_int_3_swigregister(_Vec_int_3)

def _Vec_int_3_all(alpha):
    return _landmarkDetector._Vec_int_3_all(alpha)
_Vec_int_3_all = _landmarkDetector._Vec_int_3_all

class _DataType_Vec_int_3(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, _DataType_Vec_int_3, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, _DataType_Vec_int_3, name)
    __repr__ = _swig_repr
    generic_type = _landmarkDetector._DataType_Vec_int_3_generic_type
    channels = _landmarkDetector._DataType_Vec_int_3_channels
    fmt = _landmarkDetector._DataType_Vec_int_3_fmt

    def __init__(self):
        this = _landmarkDetector.new__DataType_Vec_int_3()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _landmarkDetector.delete__DataType_Vec_int_3
    __del__ = lambda self: None
_DataType_Vec_int_3_swigregister = _landmarkDetector._DataType_Vec_int_3_swigregister
_DataType_Vec_int_3_swigregister(_DataType_Vec_int_3)


Vec3i = _Vec_int_3
DataType_Vec3i = _DataType_Vec_int_3

class _Matx_int_4_1(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, _Matx_int_4_1, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, _Matx_int_4_1, name)
    __repr__ = _swig_repr
    rows = _landmarkDetector._Matx_int_4_1_rows
    cols = _landmarkDetector._Matx_int_4_1_cols
    channels = _landmarkDetector._Matx_int_4_1_channels
    shortdim = _landmarkDetector._Matx_int_4_1_shortdim
    if _newclass:
        all = staticmethod(_landmarkDetector._Matx_int_4_1_all)
    else:
        all = _landmarkDetector._Matx_int_4_1_all
    if _newclass:
        zeros = staticmethod(_landmarkDetector._Matx_int_4_1_zeros)
    else:
        zeros = _landmarkDetector._Matx_int_4_1_zeros
    if _newclass:
        ones = staticmethod(_landmarkDetector._Matx_int_4_1_ones)
    else:
        ones = _landmarkDetector._Matx_int_4_1_ones
    if _newclass:
        eye = staticmethod(_landmarkDetector._Matx_int_4_1_eye)
    else:
        eye = _landmarkDetector._Matx_int_4_1_eye
    if _newclass:
        randu = staticmethod(_landmarkDetector._Matx_int_4_1_randu)
    else:
        randu = _landmarkDetector._Matx_int_4_1_randu
    if _newclass:
        randn = staticmethod(_landmarkDetector._Matx_int_4_1_randn)
    else:
        randn = _landmarkDetector._Matx_int_4_1_randn

    def dot(self, v):
        return _landmarkDetector._Matx_int_4_1_dot(self, v)

    def ddot(self, v):
        return _landmarkDetector._Matx_int_4_1_ddot(self, v)

    def t(self):
        return _landmarkDetector._Matx_int_4_1_t(self)

    def mul(self, a):
        return _landmarkDetector._Matx_int_4_1_mul(self, a)

    def div(self, a):
        return _landmarkDetector._Matx_int_4_1_div(self, a)

    def __call__(self, i, j):
        return _landmarkDetector._Matx_int_4_1___call__(self, i, j)
    __swig_setmethods__["val"] = _landmarkDetector._Matx_int_4_1_val_set
    __swig_getmethods__["val"] = _landmarkDetector._Matx_int_4_1_val_get
    if _newclass:
        val = _swig_property(_landmarkDetector._Matx_int_4_1_val_get, _landmarkDetector._Matx_int_4_1_val_set)

    import re
    _re_pattern = re.compile("^_Matx_(?P<value_type>[a-zA-Z_][a-zA-Z0-9_]*)_(?P<rows>[0-9]+)_(?P<cols>[0-9]+)$")


    def __init__(self, *args):

        ma = self._re_pattern.match(self.__class__.__name__)
        value_type = ma.group("value_type")
        rows = int(ma.group("rows"))
        cols = int(ma.group("cols"))

        array = _array_map[value_type](rows*cols)
        for i in range(len(args)):
            array[i] = args[i]

        args = [array]


        this = _landmarkDetector.new__Matx_int_4_1(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def __getattribute__(self, name):
        if name == "__array_interface__":
            ma = self._re_pattern.match(self.__class__.__name__)
            value_type = ma.group("value_type")
            rows = int(ma.group("rows"))
            cols = int(ma.group("cols"))
            return {"shape": (rows, cols),
                    "typestr": _cv_numpy_typestr_map[value_type],
                    "data": (int(self.val), False)}
        else:
            return object.__getattribute__(self, name)


    def __getitem__(self, key):
        ma = self._re_pattern.match(self.__class__.__name__)
        rows = int(ma.group("rows"))
        cols = int(ma.group("cols"))

        if isinstance(key, int):
            if rows != 1 and cols != 1:
                raise IndexError
            i = key
            j = 0
        elif isinstance(key, tuple) and len(key) == 2:
            i = key[0]
            j = key[1]
        else:
            raise TypeError

        if i >= rows or j >= cols:
            raise IndexError

        return self(i, j)


    def __str__(self):
        return _landmarkDetector._Matx_int_4_1___str__(self)
    __swig_destroy__ = _landmarkDetector.delete__Matx_int_4_1
    __del__ = lambda self: None
_Matx_int_4_1_swigregister = _landmarkDetector._Matx_int_4_1_swigregister
_Matx_int_4_1_swigregister(_Matx_int_4_1)

def _Matx_int_4_1_all(alpha):
    return _landmarkDetector._Matx_int_4_1_all(alpha)
_Matx_int_4_1_all = _landmarkDetector._Matx_int_4_1_all

def _Matx_int_4_1_zeros():
    return _landmarkDetector._Matx_int_4_1_zeros()
_Matx_int_4_1_zeros = _landmarkDetector._Matx_int_4_1_zeros

def _Matx_int_4_1_ones():
    return _landmarkDetector._Matx_int_4_1_ones()
_Matx_int_4_1_ones = _landmarkDetector._Matx_int_4_1_ones

def _Matx_int_4_1_eye():
    return _landmarkDetector._Matx_int_4_1_eye()
_Matx_int_4_1_eye = _landmarkDetector._Matx_int_4_1_eye

def _Matx_int_4_1_randu(a, b):
    return _landmarkDetector._Matx_int_4_1_randu(a, b)
_Matx_int_4_1_randu = _landmarkDetector._Matx_int_4_1_randu

def _Matx_int_4_1_randn(a, b):
    return _landmarkDetector._Matx_int_4_1_randn(a, b)
_Matx_int_4_1_randn = _landmarkDetector._Matx_int_4_1_randn


Matx41i = _Matx_int_4_1

class _Vec_int_4(_Matx_int_4_1):
    __swig_setmethods__ = {}
    for _s in [_Matx_int_4_1]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, _Vec_int_4, name, value)
    __swig_getmethods__ = {}
    for _s in [_Matx_int_4_1]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, _Vec_int_4, name)
    __repr__ = _swig_repr
    channels = _landmarkDetector._Vec_int_4_channels
    if _newclass:
        all = staticmethod(_landmarkDetector._Vec_int_4_all)
    else:
        all = _landmarkDetector._Vec_int_4_all

    def mul(self, v):
        return _landmarkDetector._Vec_int_4_mul(self, v)

    def __call__(self, i):
        return _landmarkDetector._Vec_int_4___call__(self, i)

    import re
    _re_pattern = re.compile("^_Vec_(?P<value_type>[a-zA-Z_][a-zA-Z0-9_]*)_(?P<rows>[0-9]+)$")


    def __init__(self, *args):

        ma = self._re_pattern.match(self.__class__.__name__)
        value_type = ma.group("value_type")
        rows = int(ma.group("rows"))

        array = _array_map[value_type](rows)
        for i in range(len(args)):
            array[i] = args[i]

        args = [array]


        this = _landmarkDetector.new__Vec_int_4(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def __getattribute__(self, name):
        if name == "__array_interface__":
            ma = self._re_pattern.match(self.__class__.__name__)
            value_type = ma.group("value_type")
            rows = int(ma.group("rows"))
            return {"shape": (rows, 1),
                    "typestr": _cv_numpy_typestr_map[value_type],
                    "data": (int(self.val), False)}
        else:
            return object.__getattribute__(self, name)

    def __getitem__(self, key):
        ma = self._re_pattern.match(self.__class__.__name__)
        rows = int(ma.group("rows"))

        if not isinstance(key, int):
            raise TypeError

        if key >= rows:
            raise IndexError

        return self(key)


    def __str__(self):
        return _landmarkDetector._Vec_int_4___str__(self)
    __swig_destroy__ = _landmarkDetector.delete__Vec_int_4
    __del__ = lambda self: None
_Vec_int_4_swigregister = _landmarkDetector._Vec_int_4_swigregister
_Vec_int_4_swigregister(_Vec_int_4)

def _Vec_int_4_all(alpha):
    return _landmarkDetector._Vec_int_4_all(alpha)
_Vec_int_4_all = _landmarkDetector._Vec_int_4_all

class _DataType_Vec_int_4(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, _DataType_Vec_int_4, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, _DataType_Vec_int_4, name)
    __repr__ = _swig_repr
    generic_type = _landmarkDetector._DataType_Vec_int_4_generic_type
    channels = _landmarkDetector._DataType_Vec_int_4_channels
    fmt = _landmarkDetector._DataType_Vec_int_4_fmt

    def __init__(self):
        this = _landmarkDetector.new__DataType_Vec_int_4()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _landmarkDetector.delete__DataType_Vec_int_4
    __del__ = lambda self: None
_DataType_Vec_int_4_swigregister = _landmarkDetector._DataType_Vec_int_4_swigregister
_DataType_Vec_int_4_swigregister(_DataType_Vec_int_4)


Vec4i = _Vec_int_4
DataType_Vec4i = _DataType_Vec_int_4

class _Matx_int_6_1(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, _Matx_int_6_1, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, _Matx_int_6_1, name)
    __repr__ = _swig_repr
    rows = _landmarkDetector._Matx_int_6_1_rows
    cols = _landmarkDetector._Matx_int_6_1_cols
    channels = _landmarkDetector._Matx_int_6_1_channels
    shortdim = _landmarkDetector._Matx_int_6_1_shortdim
    if _newclass:
        all = staticmethod(_landmarkDetector._Matx_int_6_1_all)
    else:
        all = _landmarkDetector._Matx_int_6_1_all
    if _newclass:
        zeros = staticmethod(_landmarkDetector._Matx_int_6_1_zeros)
    else:
        zeros = _landmarkDetector._Matx_int_6_1_zeros
    if _newclass:
        ones = staticmethod(_landmarkDetector._Matx_int_6_1_ones)
    else:
        ones = _landmarkDetector._Matx_int_6_1_ones
    if _newclass:
        eye = staticmethod(_landmarkDetector._Matx_int_6_1_eye)
    else:
        eye = _landmarkDetector._Matx_int_6_1_eye
    if _newclass:
        randu = staticmethod(_landmarkDetector._Matx_int_6_1_randu)
    else:
        randu = _landmarkDetector._Matx_int_6_1_randu
    if _newclass:
        randn = staticmethod(_landmarkDetector._Matx_int_6_1_randn)
    else:
        randn = _landmarkDetector._Matx_int_6_1_randn

    def dot(self, v):
        return _landmarkDetector._Matx_int_6_1_dot(self, v)

    def ddot(self, v):
        return _landmarkDetector._Matx_int_6_1_ddot(self, v)

    def t(self):
        return _landmarkDetector._Matx_int_6_1_t(self)

    def mul(self, a):
        return _landmarkDetector._Matx_int_6_1_mul(self, a)

    def div(self, a):
        return _landmarkDetector._Matx_int_6_1_div(self, a)

    def __call__(self, i, j):
        return _landmarkDetector._Matx_int_6_1___call__(self, i, j)
    __swig_setmethods__["val"] = _landmarkDetector._Matx_int_6_1_val_set
    __swig_getmethods__["val"] = _landmarkDetector._Matx_int_6_1_val_get
    if _newclass:
        val = _swig_property(_landmarkDetector._Matx_int_6_1_val_get, _landmarkDetector._Matx_int_6_1_val_set)

    import re
    _re_pattern = re.compile("^_Matx_(?P<value_type>[a-zA-Z_][a-zA-Z0-9_]*)_(?P<rows>[0-9]+)_(?P<cols>[0-9]+)$")


    def __init__(self, *args):

        ma = self._re_pattern.match(self.__class__.__name__)
        value_type = ma.group("value_type")
        rows = int(ma.group("rows"))
        cols = int(ma.group("cols"))

        array = _array_map[value_type](rows*cols)
        for i in range(len(args)):
            array[i] = args[i]

        args = [array]


        this = _landmarkDetector.new__Matx_int_6_1(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def __getattribute__(self, name):
        if name == "__array_interface__":
            ma = self._re_pattern.match(self.__class__.__name__)
            value_type = ma.group("value_type")
            rows = int(ma.group("rows"))
            cols = int(ma.group("cols"))
            return {"shape": (rows, cols),
                    "typestr": _cv_numpy_typestr_map[value_type],
                    "data": (int(self.val), False)}
        else:
            return object.__getattribute__(self, name)


    def __getitem__(self, key):
        ma = self._re_pattern.match(self.__class__.__name__)
        rows = int(ma.group("rows"))
        cols = int(ma.group("cols"))

        if isinstance(key, int):
            if rows != 1 and cols != 1:
                raise IndexError
            i = key
            j = 0
        elif isinstance(key, tuple) and len(key) == 2:
            i = key[0]
            j = key[1]
        else:
            raise TypeError

        if i >= rows or j >= cols:
            raise IndexError

        return self(i, j)


    def __str__(self):
        return _landmarkDetector._Matx_int_6_1___str__(self)
    __swig_destroy__ = _landmarkDetector.delete__Matx_int_6_1
    __del__ = lambda self: None
_Matx_int_6_1_swigregister = _landmarkDetector._Matx_int_6_1_swigregister
_Matx_int_6_1_swigregister(_Matx_int_6_1)

def _Matx_int_6_1_all(alpha):
    return _landmarkDetector._Matx_int_6_1_all(alpha)
_Matx_int_6_1_all = _landmarkDetector._Matx_int_6_1_all

def _Matx_int_6_1_zeros():
    return _landmarkDetector._Matx_int_6_1_zeros()
_Matx_int_6_1_zeros = _landmarkDetector._Matx_int_6_1_zeros

def _Matx_int_6_1_ones():
    return _landmarkDetector._Matx_int_6_1_ones()
_Matx_int_6_1_ones = _landmarkDetector._Matx_int_6_1_ones

def _Matx_int_6_1_eye():
    return _landmarkDetector._Matx_int_6_1_eye()
_Matx_int_6_1_eye = _landmarkDetector._Matx_int_6_1_eye

def _Matx_int_6_1_randu(a, b):
    return _landmarkDetector._Matx_int_6_1_randu(a, b)
_Matx_int_6_1_randu = _landmarkDetector._Matx_int_6_1_randu

def _Matx_int_6_1_randn(a, b):
    return _landmarkDetector._Matx_int_6_1_randn(a, b)
_Matx_int_6_1_randn = _landmarkDetector._Matx_int_6_1_randn


Matx61i = _Matx_int_6_1

class _Vec_int_6(_Matx_int_6_1):
    __swig_setmethods__ = {}
    for _s in [_Matx_int_6_1]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, _Vec_int_6, name, value)
    __swig_getmethods__ = {}
    for _s in [_Matx_int_6_1]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, _Vec_int_6, name)
    __repr__ = _swig_repr
    channels = _landmarkDetector._Vec_int_6_channels
    if _newclass:
        all = staticmethod(_landmarkDetector._Vec_int_6_all)
    else:
        all = _landmarkDetector._Vec_int_6_all

    def mul(self, v):
        return _landmarkDetector._Vec_int_6_mul(self, v)

    def __call__(self, i):
        return _landmarkDetector._Vec_int_6___call__(self, i)

    import re
    _re_pattern = re.compile("^_Vec_(?P<value_type>[a-zA-Z_][a-zA-Z0-9_]*)_(?P<rows>[0-9]+)$")


    def __init__(self, *args):

        ma = self._re_pattern.match(self.__class__.__name__)
        value_type = ma.group("value_type")
        rows = int(ma.group("rows"))

        array = _array_map[value_type](rows)
        for i in range(len(args)):
            array[i] = args[i]

        args = [array]


        this = _landmarkDetector.new__Vec_int_6(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def __getattribute__(self, name):
        if name == "__array_interface__":
            ma = self._re_pattern.match(self.__class__.__name__)
            value_type = ma.group("value_type")
            rows = int(ma.group("rows"))
            return {"shape": (rows, 1),
                    "typestr": _cv_numpy_typestr_map[value_type],
                    "data": (int(self.val), False)}
        else:
            return object.__getattribute__(self, name)

    def __getitem__(self, key):
        ma = self._re_pattern.match(self.__class__.__name__)
        rows = int(ma.group("rows"))

        if not isinstance(key, int):
            raise TypeError

        if key >= rows:
            raise IndexError

        return self(key)


    def __str__(self):
        return _landmarkDetector._Vec_int_6___str__(self)
    __swig_destroy__ = _landmarkDetector.delete__Vec_int_6
    __del__ = lambda self: None
_Vec_int_6_swigregister = _landmarkDetector._Vec_int_6_swigregister
_Vec_int_6_swigregister(_Vec_int_6)

def _Vec_int_6_all(alpha):
    return _landmarkDetector._Vec_int_6_all(alpha)
_Vec_int_6_all = _landmarkDetector._Vec_int_6_all

class _DataType_Vec_int_6(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, _DataType_Vec_int_6, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, _DataType_Vec_int_6, name)
    __repr__ = _swig_repr
    generic_type = _landmarkDetector._DataType_Vec_int_6_generic_type
    channels = _landmarkDetector._DataType_Vec_int_6_channels
    fmt = _landmarkDetector._DataType_Vec_int_6_fmt

    def __init__(self):
        this = _landmarkDetector.new__DataType_Vec_int_6()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _landmarkDetector.delete__DataType_Vec_int_6
    __del__ = lambda self: None
_DataType_Vec_int_6_swigregister = _landmarkDetector._DataType_Vec_int_6_swigregister
_DataType_Vec_int_6_swigregister(_DataType_Vec_int_6)


Vec6i = _Vec_int_6
DataType_Vec6i = _DataType_Vec_int_6

class _Matx_int_8_1(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, _Matx_int_8_1, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, _Matx_int_8_1, name)
    __repr__ = _swig_repr
    rows = _landmarkDetector._Matx_int_8_1_rows
    cols = _landmarkDetector._Matx_int_8_1_cols
    channels = _landmarkDetector._Matx_int_8_1_channels
    shortdim = _landmarkDetector._Matx_int_8_1_shortdim
    if _newclass:
        all = staticmethod(_landmarkDetector._Matx_int_8_1_all)
    else:
        all = _landmarkDetector._Matx_int_8_1_all
    if _newclass:
        zeros = staticmethod(_landmarkDetector._Matx_int_8_1_zeros)
    else:
        zeros = _landmarkDetector._Matx_int_8_1_zeros
    if _newclass:
        ones = staticmethod(_landmarkDetector._Matx_int_8_1_ones)
    else:
        ones = _landmarkDetector._Matx_int_8_1_ones
    if _newclass:
        eye = staticmethod(_landmarkDetector._Matx_int_8_1_eye)
    else:
        eye = _landmarkDetector._Matx_int_8_1_eye
    if _newclass:
        randu = staticmethod(_landmarkDetector._Matx_int_8_1_randu)
    else:
        randu = _landmarkDetector._Matx_int_8_1_randu
    if _newclass:
        randn = staticmethod(_landmarkDetector._Matx_int_8_1_randn)
    else:
        randn = _landmarkDetector._Matx_int_8_1_randn

    def dot(self, v):
        return _landmarkDetector._Matx_int_8_1_dot(self, v)

    def ddot(self, v):
        return _landmarkDetector._Matx_int_8_1_ddot(self, v)

    def t(self):
        return _landmarkDetector._Matx_int_8_1_t(self)

    def mul(self, a):
        return _landmarkDetector._Matx_int_8_1_mul(self, a)

    def div(self, a):
        return _landmarkDetector._Matx_int_8_1_div(self, a)

    def __call__(self, i, j):
        return _landmarkDetector._Matx_int_8_1___call__(self, i, j)
    __swig_setmethods__["val"] = _landmarkDetector._Matx_int_8_1_val_set
    __swig_getmethods__["val"] = _landmarkDetector._Matx_int_8_1_val_get
    if _newclass:
        val = _swig_property(_landmarkDetector._Matx_int_8_1_val_get, _landmarkDetector._Matx_int_8_1_val_set)

    import re
    _re_pattern = re.compile("^_Matx_(?P<value_type>[a-zA-Z_][a-zA-Z0-9_]*)_(?P<rows>[0-9]+)_(?P<cols>[0-9]+)$")


    def __init__(self, *args):

        ma = self._re_pattern.match(self.__class__.__name__)
        value_type = ma.group("value_type")
        rows = int(ma.group("rows"))
        cols = int(ma.group("cols"))

        array = _array_map[value_type](rows*cols)
        for i in range(len(args)):
            array[i] = args[i]

        args = [array]


        this = _landmarkDetector.new__Matx_int_8_1(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def __getattribute__(self, name):
        if name == "__array_interface__":
            ma = self._re_pattern.match(self.__class__.__name__)
            value_type = ma.group("value_type")
            rows = int(ma.group("rows"))
            cols = int(ma.group("cols"))
            return {"shape": (rows, cols),
                    "typestr": _cv_numpy_typestr_map[value_type],
                    "data": (int(self.val), False)}
        else:
            return object.__getattribute__(self, name)


    def __getitem__(self, key):
        ma = self._re_pattern.match(self.__class__.__name__)
        rows = int(ma.group("rows"))
        cols = int(ma.group("cols"))

        if isinstance(key, int):
            if rows != 1 and cols != 1:
                raise IndexError
            i = key
            j = 0
        elif isinstance(key, tuple) and len(key) == 2:
            i = key[0]
            j = key[1]
        else:
            raise TypeError

        if i >= rows or j >= cols:
            raise IndexError

        return self(i, j)


    def __str__(self):
        return _landmarkDetector._Matx_int_8_1___str__(self)
    __swig_destroy__ = _landmarkDetector.delete__Matx_int_8_1
    __del__ = lambda self: None
_Matx_int_8_1_swigregister = _landmarkDetector._Matx_int_8_1_swigregister
_Matx_int_8_1_swigregister(_Matx_int_8_1)

def _Matx_int_8_1_all(alpha):
    return _landmarkDetector._Matx_int_8_1_all(alpha)
_Matx_int_8_1_all = _landmarkDetector._Matx_int_8_1_all

def _Matx_int_8_1_zeros():
    return _landmarkDetector._Matx_int_8_1_zeros()
_Matx_int_8_1_zeros = _landmarkDetector._Matx_int_8_1_zeros

def _Matx_int_8_1_ones():
    return _landmarkDetector._Matx_int_8_1_ones()
_Matx_int_8_1_ones = _landmarkDetector._Matx_int_8_1_ones

def _Matx_int_8_1_eye():
    return _landmarkDetector._Matx_int_8_1_eye()
_Matx_int_8_1_eye = _landmarkDetector._Matx_int_8_1_eye

def _Matx_int_8_1_randu(a, b):
    return _landmarkDetector._Matx_int_8_1_randu(a, b)
_Matx_int_8_1_randu = _landmarkDetector._Matx_int_8_1_randu

def _Matx_int_8_1_randn(a, b):
    return _landmarkDetector._Matx_int_8_1_randn(a, b)
_Matx_int_8_1_randn = _landmarkDetector._Matx_int_8_1_randn


Matx81i = _Matx_int_8_1

class _Vec_int_8(_Matx_int_8_1):
    __swig_setmethods__ = {}
    for _s in [_Matx_int_8_1]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, _Vec_int_8, name, value)
    __swig_getmethods__ = {}
    for _s in [_Matx_int_8_1]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, _Vec_int_8, name)
    __repr__ = _swig_repr
    channels = _landmarkDetector._Vec_int_8_channels
    if _newclass:
        all = staticmethod(_landmarkDetector._Vec_int_8_all)
    else:
        all = _landmarkDetector._Vec_int_8_all

    def mul(self, v):
        return _landmarkDetector._Vec_int_8_mul(self, v)

    def __call__(self, i):
        return _landmarkDetector._Vec_int_8___call__(self, i)

    import re
    _re_pattern = re.compile("^_Vec_(?P<value_type>[a-zA-Z_][a-zA-Z0-9_]*)_(?P<rows>[0-9]+)$")


    def __init__(self, *args):

        ma = self._re_pattern.match(self.__class__.__name__)
        value_type = ma.group("value_type")
        rows = int(ma.group("rows"))

        array = _array_map[value_type](rows)
        for i in range(len(args)):
            array[i] = args[i]

        args = [array]


        this = _landmarkDetector.new__Vec_int_8(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def __getattribute__(self, name):
        if name == "__array_interface__":
            ma = self._re_pattern.match(self.__class__.__name__)
            value_type = ma.group("value_type")
            rows = int(ma.group("rows"))
            return {"shape": (rows, 1),
                    "typestr": _cv_numpy_typestr_map[value_type],
                    "data": (int(self.val), False)}
        else:
            return object.__getattribute__(self, name)

    def __getitem__(self, key):
        ma = self._re_pattern.match(self.__class__.__name__)
        rows = int(ma.group("rows"))

        if not isinstance(key, int):
            raise TypeError

        if key >= rows:
            raise IndexError

        return self(key)


    def __str__(self):
        return _landmarkDetector._Vec_int_8___str__(self)
    __swig_destroy__ = _landmarkDetector.delete__Vec_int_8
    __del__ = lambda self: None
_Vec_int_8_swigregister = _landmarkDetector._Vec_int_8_swigregister
_Vec_int_8_swigregister(_Vec_int_8)

def _Vec_int_8_all(alpha):
    return _landmarkDetector._Vec_int_8_all(alpha)
_Vec_int_8_all = _landmarkDetector._Vec_int_8_all

class _DataType_Vec_int_8(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, _DataType_Vec_int_8, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, _DataType_Vec_int_8, name)
    __repr__ = _swig_repr
    generic_type = _landmarkDetector._DataType_Vec_int_8_generic_type
    channels = _landmarkDetector._DataType_Vec_int_8_channels
    fmt = _landmarkDetector._DataType_Vec_int_8_fmt

    def __init__(self):
        this = _landmarkDetector.new__DataType_Vec_int_8()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _landmarkDetector.delete__DataType_Vec_int_8
    __del__ = lambda self: None
_DataType_Vec_int_8_swigregister = _landmarkDetector._DataType_Vec_int_8_swigregister
_DataType_Vec_int_8_swigregister(_DataType_Vec_int_8)


Vec8i = _Vec_int_8
DataType_Vec8i = _DataType_Vec_int_8

class _cv_numpy_sizeof_float(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, _cv_numpy_sizeof_float, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, _cv_numpy_sizeof_float, name)
    __repr__ = _swig_repr
    value = _landmarkDetector._cv_numpy_sizeof_float_value

    def __init__(self):
        this = _landmarkDetector.new__cv_numpy_sizeof_float()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _landmarkDetector.delete__cv_numpy_sizeof_float
    __del__ = lambda self: None
_cv_numpy_sizeof_float_swigregister = _landmarkDetector._cv_numpy_sizeof_float_swigregister
_cv_numpy_sizeof_float_swigregister(_cv_numpy_sizeof_float)


if _cv_numpy_sizeof_float.value == 1:
    _cv_numpy_typestr_map["float"] = "|" +"f" + "1"
else:
    _cv_numpy_typestr_map["float"] = _cv_numpy_endianess  +"f" + str(_cv_numpy_sizeof_float.value)

class _floatArray(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, _floatArray, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, _floatArray, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _landmarkDetector._floatArray_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _landmarkDetector._floatArray___nonzero__(self)

    def __bool__(self):
        return _landmarkDetector._floatArray___bool__(self)

    def __len__(self):
        return _landmarkDetector._floatArray___len__(self)

    def __getslice__(self, i, j):
        return _landmarkDetector._floatArray___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _landmarkDetector._floatArray___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _landmarkDetector._floatArray___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _landmarkDetector._floatArray___delitem__(self, *args)

    def __getitem__(self, *args):
        return _landmarkDetector._floatArray___getitem__(self, *args)

    def __setitem__(self, *args):
        return _landmarkDetector._floatArray___setitem__(self, *args)

    def pop(self):
        return _landmarkDetector._floatArray_pop(self)

    def append(self, x):
        return _landmarkDetector._floatArray_append(self, x)

    def empty(self):
        return _landmarkDetector._floatArray_empty(self)

    def size(self):
        return _landmarkDetector._floatArray_size(self)

    def swap(self, v):
        return _landmarkDetector._floatArray_swap(self, v)

    def begin(self):
        return _landmarkDetector._floatArray_begin(self)

    def end(self):
        return _landmarkDetector._floatArray_end(self)

    def rbegin(self):
        return _landmarkDetector._floatArray_rbegin(self)

    def rend(self):
        return _landmarkDetector._floatArray_rend(self)

    def clear(self):
        return _landmarkDetector._floatArray_clear(self)

    def get_allocator(self):
        return _landmarkDetector._floatArray_get_allocator(self)

    def pop_back(self):
        return _landmarkDetector._floatArray_pop_back(self)

    def erase(self, *args):
        return _landmarkDetector._floatArray_erase(self, *args)

    def __init__(self, *args):
        this = _landmarkDetector.new__floatArray(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        return _landmarkDetector._floatArray_push_back(self, x)

    def front(self):
        return _landmarkDetector._floatArray_front(self)

    def back(self):
        return _landmarkDetector._floatArray_back(self)

    def assign(self, n, x):
        return _landmarkDetector._floatArray_assign(self, n, x)

    def resize(self, *args):
        return _landmarkDetector._floatArray_resize(self, *args)

    def insert(self, *args):
        return _landmarkDetector._floatArray_insert(self, *args)

    def reserve(self, n):
        return _landmarkDetector._floatArray_reserve(self, n)

    def capacity(self):
        return _landmarkDetector._floatArray_capacity(self)
    __swig_destroy__ = _landmarkDetector.delete__floatArray
    __del__ = lambda self: None
_floatArray_swigregister = _landmarkDetector._floatArray_swigregister
_floatArray_swigregister(_floatArray)


_array_map["float"] = _floatArray

class _Matx_float_2_1(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, _Matx_float_2_1, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, _Matx_float_2_1, name)
    __repr__ = _swig_repr
    rows = _landmarkDetector._Matx_float_2_1_rows
    cols = _landmarkDetector._Matx_float_2_1_cols
    channels = _landmarkDetector._Matx_float_2_1_channels
    shortdim = _landmarkDetector._Matx_float_2_1_shortdim
    if _newclass:
        all = staticmethod(_landmarkDetector._Matx_float_2_1_all)
    else:
        all = _landmarkDetector._Matx_float_2_1_all
    if _newclass:
        zeros = staticmethod(_landmarkDetector._Matx_float_2_1_zeros)
    else:
        zeros = _landmarkDetector._Matx_float_2_1_zeros
    if _newclass:
        ones = staticmethod(_landmarkDetector._Matx_float_2_1_ones)
    else:
        ones = _landmarkDetector._Matx_float_2_1_ones
    if _newclass:
        eye = staticmethod(_landmarkDetector._Matx_float_2_1_eye)
    else:
        eye = _landmarkDetector._Matx_float_2_1_eye
    if _newclass:
        randu = staticmethod(_landmarkDetector._Matx_float_2_1_randu)
    else:
        randu = _landmarkDetector._Matx_float_2_1_randu
    if _newclass:
        randn = staticmethod(_landmarkDetector._Matx_float_2_1_randn)
    else:
        randn = _landmarkDetector._Matx_float_2_1_randn

    def dot(self, v):
        return _landmarkDetector._Matx_float_2_1_dot(self, v)

    def ddot(self, v):
        return _landmarkDetector._Matx_float_2_1_ddot(self, v)

    def t(self):
        return _landmarkDetector._Matx_float_2_1_t(self)

    def mul(self, a):
        return _landmarkDetector._Matx_float_2_1_mul(self, a)

    def div(self, a):
        return _landmarkDetector._Matx_float_2_1_div(self, a)

    def __call__(self, i, j):
        return _landmarkDetector._Matx_float_2_1___call__(self, i, j)
    __swig_setmethods__["val"] = _landmarkDetector._Matx_float_2_1_val_set
    __swig_getmethods__["val"] = _landmarkDetector._Matx_float_2_1_val_get
    if _newclass:
        val = _swig_property(_landmarkDetector._Matx_float_2_1_val_get, _landmarkDetector._Matx_float_2_1_val_set)

    import re
    _re_pattern = re.compile("^_Matx_(?P<value_type>[a-zA-Z_][a-zA-Z0-9_]*)_(?P<rows>[0-9]+)_(?P<cols>[0-9]+)$")


    def __init__(self, *args):

        ma = self._re_pattern.match(self.__class__.__name__)
        value_type = ma.group("value_type")
        rows = int(ma.group("rows"))
        cols = int(ma.group("cols"))

        array = _array_map[value_type](rows*cols)
        for i in range(len(args)):
            array[i] = args[i]

        args = [array]


        this = _landmarkDetector.new__Matx_float_2_1(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def __getattribute__(self, name):
        if name == "__array_interface__":
            ma = self._re_pattern.match(self.__class__.__name__)
            value_type = ma.group("value_type")
            rows = int(ma.group("rows"))
            cols = int(ma.group("cols"))
            return {"shape": (rows, cols),
                    "typestr": _cv_numpy_typestr_map[value_type],
                    "data": (int(self.val), False)}
        else:
            return object.__getattribute__(self, name)


    def __getitem__(self, key):
        ma = self._re_pattern.match(self.__class__.__name__)
        rows = int(ma.group("rows"))
        cols = int(ma.group("cols"))

        if isinstance(key, int):
            if rows != 1 and cols != 1:
                raise IndexError
            i = key
            j = 0
        elif isinstance(key, tuple) and len(key) == 2:
            i = key[0]
            j = key[1]
        else:
            raise TypeError

        if i >= rows or j >= cols:
            raise IndexError

        return self(i, j)


    def __str__(self):
        return _landmarkDetector._Matx_float_2_1___str__(self)
    __swig_destroy__ = _landmarkDetector.delete__Matx_float_2_1
    __del__ = lambda self: None
_Matx_float_2_1_swigregister = _landmarkDetector._Matx_float_2_1_swigregister
_Matx_float_2_1_swigregister(_Matx_float_2_1)

def _Matx_float_2_1_all(alpha):
    return _landmarkDetector._Matx_float_2_1_all(alpha)
_Matx_float_2_1_all = _landmarkDetector._Matx_float_2_1_all

def _Matx_float_2_1_zeros():
    return _landmarkDetector._Matx_float_2_1_zeros()
_Matx_float_2_1_zeros = _landmarkDetector._Matx_float_2_1_zeros

def _Matx_float_2_1_ones():
    return _landmarkDetector._Matx_float_2_1_ones()
_Matx_float_2_1_ones = _landmarkDetector._Matx_float_2_1_ones

def _Matx_float_2_1_eye():
    return _landmarkDetector._Matx_float_2_1_eye()
_Matx_float_2_1_eye = _landmarkDetector._Matx_float_2_1_eye

def _Matx_float_2_1_randu(a, b):
    return _landmarkDetector._Matx_float_2_1_randu(a, b)
_Matx_float_2_1_randu = _landmarkDetector._Matx_float_2_1_randu

def _Matx_float_2_1_randn(a, b):
    return _landmarkDetector._Matx_float_2_1_randn(a, b)
_Matx_float_2_1_randn = _landmarkDetector._Matx_float_2_1_randn


Matx21f = _Matx_float_2_1

class _Vec_float_2(_Matx_float_2_1):
    __swig_setmethods__ = {}
    for _s in [_Matx_float_2_1]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, _Vec_float_2, name, value)
    __swig_getmethods__ = {}
    for _s in [_Matx_float_2_1]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, _Vec_float_2, name)
    __repr__ = _swig_repr
    channels = _landmarkDetector._Vec_float_2_channels
    if _newclass:
        all = staticmethod(_landmarkDetector._Vec_float_2_all)
    else:
        all = _landmarkDetector._Vec_float_2_all

    def mul(self, v):
        return _landmarkDetector._Vec_float_2_mul(self, v)

    def __call__(self, i):
        return _landmarkDetector._Vec_float_2___call__(self, i)

    import re
    _re_pattern = re.compile("^_Vec_(?P<value_type>[a-zA-Z_][a-zA-Z0-9_]*)_(?P<rows>[0-9]+)$")


    def __init__(self, *args):

        ma = self._re_pattern.match(self.__class__.__name__)
        value_type = ma.group("value_type")
        rows = int(ma.group("rows"))

        array = _array_map[value_type](rows)
        for i in range(len(args)):
            array[i] = args[i]

        args = [array]


        this = _landmarkDetector.new__Vec_float_2(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def __getattribute__(self, name):
        if name == "__array_interface__":
            ma = self._re_pattern.match(self.__class__.__name__)
            value_type = ma.group("value_type")
            rows = int(ma.group("rows"))
            return {"shape": (rows, 1),
                    "typestr": _cv_numpy_typestr_map[value_type],
                    "data": (int(self.val), False)}
        else:
            return object.__getattribute__(self, name)

    def __getitem__(self, key):
        ma = self._re_pattern.match(self.__class__.__name__)
        rows = int(ma.group("rows"))

        if not isinstance(key, int):
            raise TypeError

        if key >= rows:
            raise IndexError

        return self(key)


    def __str__(self):
        return _landmarkDetector._Vec_float_2___str__(self)
    __swig_destroy__ = _landmarkDetector.delete__Vec_float_2
    __del__ = lambda self: None
_Vec_float_2_swigregister = _landmarkDetector._Vec_float_2_swigregister
_Vec_float_2_swigregister(_Vec_float_2)

def _Vec_float_2_all(alpha):
    return _landmarkDetector._Vec_float_2_all(alpha)
_Vec_float_2_all = _landmarkDetector._Vec_float_2_all

class _DataType_Vec_float_2(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, _DataType_Vec_float_2, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, _DataType_Vec_float_2, name)
    __repr__ = _swig_repr
    generic_type = _landmarkDetector._DataType_Vec_float_2_generic_type
    channels = _landmarkDetector._DataType_Vec_float_2_channels
    fmt = _landmarkDetector._DataType_Vec_float_2_fmt

    def __init__(self):
        this = _landmarkDetector.new__DataType_Vec_float_2()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _landmarkDetector.delete__DataType_Vec_float_2
    __del__ = lambda self: None
_DataType_Vec_float_2_swigregister = _landmarkDetector._DataType_Vec_float_2_swigregister
_DataType_Vec_float_2_swigregister(_DataType_Vec_float_2)


Vec2f = _Vec_float_2
DataType_Vec2f = _DataType_Vec_float_2

class _Matx_float_3_1(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, _Matx_float_3_1, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, _Matx_float_3_1, name)
    __repr__ = _swig_repr
    rows = _landmarkDetector._Matx_float_3_1_rows
    cols = _landmarkDetector._Matx_float_3_1_cols
    channels = _landmarkDetector._Matx_float_3_1_channels
    shortdim = _landmarkDetector._Matx_float_3_1_shortdim
    if _newclass:
        all = staticmethod(_landmarkDetector._Matx_float_3_1_all)
    else:
        all = _landmarkDetector._Matx_float_3_1_all
    if _newclass:
        zeros = staticmethod(_landmarkDetector._Matx_float_3_1_zeros)
    else:
        zeros = _landmarkDetector._Matx_float_3_1_zeros
    if _newclass:
        ones = staticmethod(_landmarkDetector._Matx_float_3_1_ones)
    else:
        ones = _landmarkDetector._Matx_float_3_1_ones
    if _newclass:
        eye = staticmethod(_landmarkDetector._Matx_float_3_1_eye)
    else:
        eye = _landmarkDetector._Matx_float_3_1_eye
    if _newclass:
        randu = staticmethod(_landmarkDetector._Matx_float_3_1_randu)
    else:
        randu = _landmarkDetector._Matx_float_3_1_randu
    if _newclass:
        randn = staticmethod(_landmarkDetector._Matx_float_3_1_randn)
    else:
        randn = _landmarkDetector._Matx_float_3_1_randn

    def dot(self, v):
        return _landmarkDetector._Matx_float_3_1_dot(self, v)

    def ddot(self, v):
        return _landmarkDetector._Matx_float_3_1_ddot(self, v)

    def t(self):
        return _landmarkDetector._Matx_float_3_1_t(self)

    def mul(self, a):
        return _landmarkDetector._Matx_float_3_1_mul(self, a)

    def div(self, a):
        return _landmarkDetector._Matx_float_3_1_div(self, a)

    def __call__(self, i, j):
        return _landmarkDetector._Matx_float_3_1___call__(self, i, j)
    __swig_setmethods__["val"] = _landmarkDetector._Matx_float_3_1_val_set
    __swig_getmethods__["val"] = _landmarkDetector._Matx_float_3_1_val_get
    if _newclass:
        val = _swig_property(_landmarkDetector._Matx_float_3_1_val_get, _landmarkDetector._Matx_float_3_1_val_set)

    import re
    _re_pattern = re.compile("^_Matx_(?P<value_type>[a-zA-Z_][a-zA-Z0-9_]*)_(?P<rows>[0-9]+)_(?P<cols>[0-9]+)$")


    def __init__(self, *args):

        ma = self._re_pattern.match(self.__class__.__name__)
        value_type = ma.group("value_type")
        rows = int(ma.group("rows"))
        cols = int(ma.group("cols"))

        array = _array_map[value_type](rows*cols)
        for i in range(len(args)):
            array[i] = args[i]

        args = [array]


        this = _landmarkDetector.new__Matx_float_3_1(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def __getattribute__(self, name):
        if name == "__array_interface__":
            ma = self._re_pattern.match(self.__class__.__name__)
            value_type = ma.group("value_type")
            rows = int(ma.group("rows"))
            cols = int(ma.group("cols"))
            return {"shape": (rows, cols),
                    "typestr": _cv_numpy_typestr_map[value_type],
                    "data": (int(self.val), False)}
        else:
            return object.__getattribute__(self, name)


    def __getitem__(self, key):
        ma = self._re_pattern.match(self.__class__.__name__)
        rows = int(ma.group("rows"))
        cols = int(ma.group("cols"))

        if isinstance(key, int):
            if rows != 1 and cols != 1:
                raise IndexError
            i = key
            j = 0
        elif isinstance(key, tuple) and len(key) == 2:
            i = key[0]
            j = key[1]
        else:
            raise TypeError

        if i >= rows or j >= cols:
            raise IndexError

        return self(i, j)


    def __str__(self):
        return _landmarkDetector._Matx_float_3_1___str__(self)
    __swig_destroy__ = _landmarkDetector.delete__Matx_float_3_1
    __del__ = lambda self: None
_Matx_float_3_1_swigregister = _landmarkDetector._Matx_float_3_1_swigregister
_Matx_float_3_1_swigregister(_Matx_float_3_1)

def _Matx_float_3_1_all(alpha):
    return _landmarkDetector._Matx_float_3_1_all(alpha)
_Matx_float_3_1_all = _landmarkDetector._Matx_float_3_1_all

def _Matx_float_3_1_zeros():
    return _landmarkDetector._Matx_float_3_1_zeros()
_Matx_float_3_1_zeros = _landmarkDetector._Matx_float_3_1_zeros

def _Matx_float_3_1_ones():
    return _landmarkDetector._Matx_float_3_1_ones()
_Matx_float_3_1_ones = _landmarkDetector._Matx_float_3_1_ones

def _Matx_float_3_1_eye():
    return _landmarkDetector._Matx_float_3_1_eye()
_Matx_float_3_1_eye = _landmarkDetector._Matx_float_3_1_eye

def _Matx_float_3_1_randu(a, b):
    return _landmarkDetector._Matx_float_3_1_randu(a, b)
_Matx_float_3_1_randu = _landmarkDetector._Matx_float_3_1_randu

def _Matx_float_3_1_randn(a, b):
    return _landmarkDetector._Matx_float_3_1_randn(a, b)
_Matx_float_3_1_randn = _landmarkDetector._Matx_float_3_1_randn


Matx31f = _Matx_float_3_1

class _Vec_float_3(_Matx_float_3_1):
    __swig_setmethods__ = {}
    for _s in [_Matx_float_3_1]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, _Vec_float_3, name, value)
    __swig_getmethods__ = {}
    for _s in [_Matx_float_3_1]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, _Vec_float_3, name)
    __repr__ = _swig_repr
    channels = _landmarkDetector._Vec_float_3_channels
    if _newclass:
        all = staticmethod(_landmarkDetector._Vec_float_3_all)
    else:
        all = _landmarkDetector._Vec_float_3_all

    def mul(self, v):
        return _landmarkDetector._Vec_float_3_mul(self, v)

    def __call__(self, i):
        return _landmarkDetector._Vec_float_3___call__(self, i)

    import re
    _re_pattern = re.compile("^_Vec_(?P<value_type>[a-zA-Z_][a-zA-Z0-9_]*)_(?P<rows>[0-9]+)$")


    def __init__(self, *args):

        ma = self._re_pattern.match(self.__class__.__name__)
        value_type = ma.group("value_type")
        rows = int(ma.group("rows"))

        array = _array_map[value_type](rows)
        for i in range(len(args)):
            array[i] = args[i]

        args = [array]


        this = _landmarkDetector.new__Vec_float_3(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def __getattribute__(self, name):
        if name == "__array_interface__":
            ma = self._re_pattern.match(self.__class__.__name__)
            value_type = ma.group("value_type")
            rows = int(ma.group("rows"))
            return {"shape": (rows, 1),
                    "typestr": _cv_numpy_typestr_map[value_type],
                    "data": (int(self.val), False)}
        else:
            return object.__getattribute__(self, name)

    def __getitem__(self, key):
        ma = self._re_pattern.match(self.__class__.__name__)
        rows = int(ma.group("rows"))

        if not isinstance(key, int):
            raise TypeError

        if key >= rows:
            raise IndexError

        return self(key)


    def __str__(self):
        return _landmarkDetector._Vec_float_3___str__(self)
    __swig_destroy__ = _landmarkDetector.delete__Vec_float_3
    __del__ = lambda self: None
_Vec_float_3_swigregister = _landmarkDetector._Vec_float_3_swigregister
_Vec_float_3_swigregister(_Vec_float_3)

def _Vec_float_3_all(alpha):
    return _landmarkDetector._Vec_float_3_all(alpha)
_Vec_float_3_all = _landmarkDetector._Vec_float_3_all

class _DataType_Vec_float_3(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, _DataType_Vec_float_3, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, _DataType_Vec_float_3, name)
    __repr__ = _swig_repr
    generic_type = _landmarkDetector._DataType_Vec_float_3_generic_type
    channels = _landmarkDetector._DataType_Vec_float_3_channels
    fmt = _landmarkDetector._DataType_Vec_float_3_fmt

    def __init__(self):
        this = _landmarkDetector.new__DataType_Vec_float_3()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _landmarkDetector.delete__DataType_Vec_float_3
    __del__ = lambda self: None
_DataType_Vec_float_3_swigregister = _landmarkDetector._DataType_Vec_float_3_swigregister
_DataType_Vec_float_3_swigregister(_DataType_Vec_float_3)


Vec3f = _Vec_float_3
DataType_Vec3f = _DataType_Vec_float_3

class _Matx_float_4_1(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, _Matx_float_4_1, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, _Matx_float_4_1, name)
    __repr__ = _swig_repr
    rows = _landmarkDetector._Matx_float_4_1_rows
    cols = _landmarkDetector._Matx_float_4_1_cols
    channels = _landmarkDetector._Matx_float_4_1_channels
    shortdim = _landmarkDetector._Matx_float_4_1_shortdim
    if _newclass:
        all = staticmethod(_landmarkDetector._Matx_float_4_1_all)
    else:
        all = _landmarkDetector._Matx_float_4_1_all
    if _newclass:
        zeros = staticmethod(_landmarkDetector._Matx_float_4_1_zeros)
    else:
        zeros = _landmarkDetector._Matx_float_4_1_zeros
    if _newclass:
        ones = staticmethod(_landmarkDetector._Matx_float_4_1_ones)
    else:
        ones = _landmarkDetector._Matx_float_4_1_ones
    if _newclass:
        eye = staticmethod(_landmarkDetector._Matx_float_4_1_eye)
    else:
        eye = _landmarkDetector._Matx_float_4_1_eye
    if _newclass:
        randu = staticmethod(_landmarkDetector._Matx_float_4_1_randu)
    else:
        randu = _landmarkDetector._Matx_float_4_1_randu
    if _newclass:
        randn = staticmethod(_landmarkDetector._Matx_float_4_1_randn)
    else:
        randn = _landmarkDetector._Matx_float_4_1_randn

    def dot(self, v):
        return _landmarkDetector._Matx_float_4_1_dot(self, v)

    def ddot(self, v):
        return _landmarkDetector._Matx_float_4_1_ddot(self, v)

    def t(self):
        return _landmarkDetector._Matx_float_4_1_t(self)

    def mul(self, a):
        return _landmarkDetector._Matx_float_4_1_mul(self, a)

    def div(self, a):
        return _landmarkDetector._Matx_float_4_1_div(self, a)

    def __call__(self, i, j):
        return _landmarkDetector._Matx_float_4_1___call__(self, i, j)
    __swig_setmethods__["val"] = _landmarkDetector._Matx_float_4_1_val_set
    __swig_getmethods__["val"] = _landmarkDetector._Matx_float_4_1_val_get
    if _newclass:
        val = _swig_property(_landmarkDetector._Matx_float_4_1_val_get, _landmarkDetector._Matx_float_4_1_val_set)

    import re
    _re_pattern = re.compile("^_Matx_(?P<value_type>[a-zA-Z_][a-zA-Z0-9_]*)_(?P<rows>[0-9]+)_(?P<cols>[0-9]+)$")


    def __init__(self, *args):

        ma = self._re_pattern.match(self.__class__.__name__)
        value_type = ma.group("value_type")
        rows = int(ma.group("rows"))
        cols = int(ma.group("cols"))

        array = _array_map[value_type](rows*cols)
        for i in range(len(args)):
            array[i] = args[i]

        args = [array]


        this = _landmarkDetector.new__Matx_float_4_1(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def __getattribute__(self, name):
        if name == "__array_interface__":
            ma = self._re_pattern.match(self.__class__.__name__)
            value_type = ma.group("value_type")
            rows = int(ma.group("rows"))
            cols = int(ma.group("cols"))
            return {"shape": (rows, cols),
                    "typestr": _cv_numpy_typestr_map[value_type],
                    "data": (int(self.val), False)}
        else:
            return object.__getattribute__(self, name)


    def __getitem__(self, key):
        ma = self._re_pattern.match(self.__class__.__name__)
        rows = int(ma.group("rows"))
        cols = int(ma.group("cols"))

        if isinstance(key, int):
            if rows != 1 and cols != 1:
                raise IndexError
            i = key
            j = 0
        elif isinstance(key, tuple) and len(key) == 2:
            i = key[0]
            j = key[1]
        else:
            raise TypeError

        if i >= rows or j >= cols:
            raise IndexError

        return self(i, j)


    def __str__(self):
        return _landmarkDetector._Matx_float_4_1___str__(self)
    __swig_destroy__ = _landmarkDetector.delete__Matx_float_4_1
    __del__ = lambda self: None
_Matx_float_4_1_swigregister = _landmarkDetector._Matx_float_4_1_swigregister
_Matx_float_4_1_swigregister(_Matx_float_4_1)

def _Matx_float_4_1_all(alpha):
    return _landmarkDetector._Matx_float_4_1_all(alpha)
_Matx_float_4_1_all = _landmarkDetector._Matx_float_4_1_all

def _Matx_float_4_1_zeros():
    return _landmarkDetector._Matx_float_4_1_zeros()
_Matx_float_4_1_zeros = _landmarkDetector._Matx_float_4_1_zeros

def _Matx_float_4_1_ones():
    return _landmarkDetector._Matx_float_4_1_ones()
_Matx_float_4_1_ones = _landmarkDetector._Matx_float_4_1_ones

def _Matx_float_4_1_eye():
    return _landmarkDetector._Matx_float_4_1_eye()
_Matx_float_4_1_eye = _landmarkDetector._Matx_float_4_1_eye

def _Matx_float_4_1_randu(a, b):
    return _landmarkDetector._Matx_float_4_1_randu(a, b)
_Matx_float_4_1_randu = _landmarkDetector._Matx_float_4_1_randu

def _Matx_float_4_1_randn(a, b):
    return _landmarkDetector._Matx_float_4_1_randn(a, b)
_Matx_float_4_1_randn = _landmarkDetector._Matx_float_4_1_randn


Matx41f = _Matx_float_4_1

class _Vec_float_4(_Matx_float_4_1):
    __swig_setmethods__ = {}
    for _s in [_Matx_float_4_1]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, _Vec_float_4, name, value)
    __swig_getmethods__ = {}
    for _s in [_Matx_float_4_1]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, _Vec_float_4, name)
    __repr__ = _swig_repr
    channels = _landmarkDetector._Vec_float_4_channels
    if _newclass:
        all = staticmethod(_landmarkDetector._Vec_float_4_all)
    else:
        all = _landmarkDetector._Vec_float_4_all

    def mul(self, v):
        return _landmarkDetector._Vec_float_4_mul(self, v)

    def __call__(self, i):
        return _landmarkDetector._Vec_float_4___call__(self, i)

    import re
    _re_pattern = re.compile("^_Vec_(?P<value_type>[a-zA-Z_][a-zA-Z0-9_]*)_(?P<rows>[0-9]+)$")


    def __init__(self, *args):

        ma = self._re_pattern.match(self.__class__.__name__)
        value_type = ma.group("value_type")
        rows = int(ma.group("rows"))

        array = _array_map[value_type](rows)
        for i in range(len(args)):
            array[i] = args[i]

        args = [array]


        this = _landmarkDetector.new__Vec_float_4(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def __getattribute__(self, name):
        if name == "__array_interface__":
            ma = self._re_pattern.match(self.__class__.__name__)
            value_type = ma.group("value_type")
            rows = int(ma.group("rows"))
            return {"shape": (rows, 1),
                    "typestr": _cv_numpy_typestr_map[value_type],
                    "data": (int(self.val), False)}
        else:
            return object.__getattribute__(self, name)

    def __getitem__(self, key):
        ma = self._re_pattern.match(self.__class__.__name__)
        rows = int(ma.group("rows"))

        if not isinstance(key, int):
            raise TypeError

        if key >= rows:
            raise IndexError

        return self(key)


    def __str__(self):
        return _landmarkDetector._Vec_float_4___str__(self)
    __swig_destroy__ = _landmarkDetector.delete__Vec_float_4
    __del__ = lambda self: None
_Vec_float_4_swigregister = _landmarkDetector._Vec_float_4_swigregister
_Vec_float_4_swigregister(_Vec_float_4)

def _Vec_float_4_all(alpha):
    return _landmarkDetector._Vec_float_4_all(alpha)
_Vec_float_4_all = _landmarkDetector._Vec_float_4_all

class _DataType_Vec_float_4(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, _DataType_Vec_float_4, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, _DataType_Vec_float_4, name)
    __repr__ = _swig_repr
    generic_type = _landmarkDetector._DataType_Vec_float_4_generic_type
    channels = _landmarkDetector._DataType_Vec_float_4_channels
    fmt = _landmarkDetector._DataType_Vec_float_4_fmt

    def __init__(self):
        this = _landmarkDetector.new__DataType_Vec_float_4()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _landmarkDetector.delete__DataType_Vec_float_4
    __del__ = lambda self: None
_DataType_Vec_float_4_swigregister = _landmarkDetector._DataType_Vec_float_4_swigregister
_DataType_Vec_float_4_swigregister(_DataType_Vec_float_4)


Vec4f = _Vec_float_4
DataType_Vec4f = _DataType_Vec_float_4

class _Matx_float_6_1(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, _Matx_float_6_1, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, _Matx_float_6_1, name)
    __repr__ = _swig_repr
    rows = _landmarkDetector._Matx_float_6_1_rows
    cols = _landmarkDetector._Matx_float_6_1_cols
    channels = _landmarkDetector._Matx_float_6_1_channels
    shortdim = _landmarkDetector._Matx_float_6_1_shortdim
    if _newclass:
        all = staticmethod(_landmarkDetector._Matx_float_6_1_all)
    else:
        all = _landmarkDetector._Matx_float_6_1_all
    if _newclass:
        zeros = staticmethod(_landmarkDetector._Matx_float_6_1_zeros)
    else:
        zeros = _landmarkDetector._Matx_float_6_1_zeros
    if _newclass:
        ones = staticmethod(_landmarkDetector._Matx_float_6_1_ones)
    else:
        ones = _landmarkDetector._Matx_float_6_1_ones
    if _newclass:
        eye = staticmethod(_landmarkDetector._Matx_float_6_1_eye)
    else:
        eye = _landmarkDetector._Matx_float_6_1_eye
    if _newclass:
        randu = staticmethod(_landmarkDetector._Matx_float_6_1_randu)
    else:
        randu = _landmarkDetector._Matx_float_6_1_randu
    if _newclass:
        randn = staticmethod(_landmarkDetector._Matx_float_6_1_randn)
    else:
        randn = _landmarkDetector._Matx_float_6_1_randn

    def dot(self, v):
        return _landmarkDetector._Matx_float_6_1_dot(self, v)

    def ddot(self, v):
        return _landmarkDetector._Matx_float_6_1_ddot(self, v)

    def t(self):
        return _landmarkDetector._Matx_float_6_1_t(self)

    def mul(self, a):
        return _landmarkDetector._Matx_float_6_1_mul(self, a)

    def div(self, a):
        return _landmarkDetector._Matx_float_6_1_div(self, a)

    def __call__(self, i, j):
        return _landmarkDetector._Matx_float_6_1___call__(self, i, j)
    __swig_setmethods__["val"] = _landmarkDetector._Matx_float_6_1_val_set
    __swig_getmethods__["val"] = _landmarkDetector._Matx_float_6_1_val_get
    if _newclass:
        val = _swig_property(_landmarkDetector._Matx_float_6_1_val_get, _landmarkDetector._Matx_float_6_1_val_set)

    import re
    _re_pattern = re.compile("^_Matx_(?P<value_type>[a-zA-Z_][a-zA-Z0-9_]*)_(?P<rows>[0-9]+)_(?P<cols>[0-9]+)$")


    def __init__(self, *args):

        ma = self._re_pattern.match(self.__class__.__name__)
        value_type = ma.group("value_type")
        rows = int(ma.group("rows"))
        cols = int(ma.group("cols"))

        array = _array_map[value_type](rows*cols)
        for i in range(len(args)):
            array[i] = args[i]

        args = [array]


        this = _landmarkDetector.new__Matx_float_6_1(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def __getattribute__(self, name):
        if name == "__array_interface__":
            ma = self._re_pattern.match(self.__class__.__name__)
            value_type = ma.group("value_type")
            rows = int(ma.group("rows"))
            cols = int(ma.group("cols"))
            return {"shape": (rows, cols),
                    "typestr": _cv_numpy_typestr_map[value_type],
                    "data": (int(self.val), False)}
        else:
            return object.__getattribute__(self, name)


    def __getitem__(self, key):
        ma = self._re_pattern.match(self.__class__.__name__)
        rows = int(ma.group("rows"))
        cols = int(ma.group("cols"))

        if isinstance(key, int):
            if rows != 1 and cols != 1:
                raise IndexError
            i = key
            j = 0
        elif isinstance(key, tuple) and len(key) == 2:
            i = key[0]
            j = key[1]
        else:
            raise TypeError

        if i >= rows or j >= cols:
            raise IndexError

        return self(i, j)


    def __str__(self):
        return _landmarkDetector._Matx_float_6_1___str__(self)
    __swig_destroy__ = _landmarkDetector.delete__Matx_float_6_1
    __del__ = lambda self: None
_Matx_float_6_1_swigregister = _landmarkDetector._Matx_float_6_1_swigregister
_Matx_float_6_1_swigregister(_Matx_float_6_1)

def _Matx_float_6_1_all(alpha):
    return _landmarkDetector._Matx_float_6_1_all(alpha)
_Matx_float_6_1_all = _landmarkDetector._Matx_float_6_1_all

def _Matx_float_6_1_zeros():
    return _landmarkDetector._Matx_float_6_1_zeros()
_Matx_float_6_1_zeros = _landmarkDetector._Matx_float_6_1_zeros

def _Matx_float_6_1_ones():
    return _landmarkDetector._Matx_float_6_1_ones()
_Matx_float_6_1_ones = _landmarkDetector._Matx_float_6_1_ones

def _Matx_float_6_1_eye():
    return _landmarkDetector._Matx_float_6_1_eye()
_Matx_float_6_1_eye = _landmarkDetector._Matx_float_6_1_eye

def _Matx_float_6_1_randu(a, b):
    return _landmarkDetector._Matx_float_6_1_randu(a, b)
_Matx_float_6_1_randu = _landmarkDetector._Matx_float_6_1_randu

def _Matx_float_6_1_randn(a, b):
    return _landmarkDetector._Matx_float_6_1_randn(a, b)
_Matx_float_6_1_randn = _landmarkDetector._Matx_float_6_1_randn


Matx61f = _Matx_float_6_1

class _Vec_float_6(_Matx_float_6_1):
    __swig_setmethods__ = {}
    for _s in [_Matx_float_6_1]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, _Vec_float_6, name, value)
    __swig_getmethods__ = {}
    for _s in [_Matx_float_6_1]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, _Vec_float_6, name)
    __repr__ = _swig_repr
    channels = _landmarkDetector._Vec_float_6_channels
    if _newclass:
        all = staticmethod(_landmarkDetector._Vec_float_6_all)
    else:
        all = _landmarkDetector._Vec_float_6_all

    def mul(self, v):
        return _landmarkDetector._Vec_float_6_mul(self, v)

    def __call__(self, i):
        return _landmarkDetector._Vec_float_6___call__(self, i)

    import re
    _re_pattern = re.compile("^_Vec_(?P<value_type>[a-zA-Z_][a-zA-Z0-9_]*)_(?P<rows>[0-9]+)$")


    def __init__(self, *args):

        ma = self._re_pattern.match(self.__class__.__name__)
        value_type = ma.group("value_type")
        rows = int(ma.group("rows"))

        array = _array_map[value_type](rows)
        for i in range(len(args)):
            array[i] = args[i]

        args = [array]


        this = _landmarkDetector.new__Vec_float_6(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def __getattribute__(self, name):
        if name == "__array_interface__":
            ma = self._re_pattern.match(self.__class__.__name__)
            value_type = ma.group("value_type")
            rows = int(ma.group("rows"))
            return {"shape": (rows, 1),
                    "typestr": _cv_numpy_typestr_map[value_type],
                    "data": (int(self.val), False)}
        else:
            return object.__getattribute__(self, name)

    def __getitem__(self, key):
        ma = self._re_pattern.match(self.__class__.__name__)
        rows = int(ma.group("rows"))

        if not isinstance(key, int):
            raise TypeError

        if key >= rows:
            raise IndexError

        return self(key)


    def __str__(self):
        return _landmarkDetector._Vec_float_6___str__(self)
    __swig_destroy__ = _landmarkDetector.delete__Vec_float_6
    __del__ = lambda self: None
_Vec_float_6_swigregister = _landmarkDetector._Vec_float_6_swigregister
_Vec_float_6_swigregister(_Vec_float_6)

def _Vec_float_6_all(alpha):
    return _landmarkDetector._Vec_float_6_all(alpha)
_Vec_float_6_all = _landmarkDetector._Vec_float_6_all

class _DataType_Vec_float_6(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, _DataType_Vec_float_6, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, _DataType_Vec_float_6, name)
    __repr__ = _swig_repr
    generic_type = _landmarkDetector._DataType_Vec_float_6_generic_type
    channels = _landmarkDetector._DataType_Vec_float_6_channels
    fmt = _landmarkDetector._DataType_Vec_float_6_fmt

    def __init__(self):
        this = _landmarkDetector.new__DataType_Vec_float_6()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _landmarkDetector.delete__DataType_Vec_float_6
    __del__ = lambda self: None
_DataType_Vec_float_6_swigregister = _landmarkDetector._DataType_Vec_float_6_swigregister
_DataType_Vec_float_6_swigregister(_DataType_Vec_float_6)


Vec6f = _Vec_float_6
DataType_Vec6f = _DataType_Vec_float_6

class _cv_numpy_sizeof_double(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, _cv_numpy_sizeof_double, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, _cv_numpy_sizeof_double, name)
    __repr__ = _swig_repr
    value = _landmarkDetector._cv_numpy_sizeof_double_value

    def __init__(self):
        this = _landmarkDetector.new__cv_numpy_sizeof_double()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _landmarkDetector.delete__cv_numpy_sizeof_double
    __del__ = lambda self: None
_cv_numpy_sizeof_double_swigregister = _landmarkDetector._cv_numpy_sizeof_double_swigregister
_cv_numpy_sizeof_double_swigregister(_cv_numpy_sizeof_double)


if _cv_numpy_sizeof_double.value == 1:
    _cv_numpy_typestr_map["double"] = "|" +"f" + "1"
else:
    _cv_numpy_typestr_map["double"] = _cv_numpy_endianess  +"f" + str(_cv_numpy_sizeof_double.value)

class _doubleArray(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, _doubleArray, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, _doubleArray, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _landmarkDetector._doubleArray_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _landmarkDetector._doubleArray___nonzero__(self)

    def __bool__(self):
        return _landmarkDetector._doubleArray___bool__(self)

    def __len__(self):
        return _landmarkDetector._doubleArray___len__(self)

    def __getslice__(self, i, j):
        return _landmarkDetector._doubleArray___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _landmarkDetector._doubleArray___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _landmarkDetector._doubleArray___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _landmarkDetector._doubleArray___delitem__(self, *args)

    def __getitem__(self, *args):
        return _landmarkDetector._doubleArray___getitem__(self, *args)

    def __setitem__(self, *args):
        return _landmarkDetector._doubleArray___setitem__(self, *args)

    def pop(self):
        return _landmarkDetector._doubleArray_pop(self)

    def append(self, x):
        return _landmarkDetector._doubleArray_append(self, x)

    def empty(self):
        return _landmarkDetector._doubleArray_empty(self)

    def size(self):
        return _landmarkDetector._doubleArray_size(self)

    def swap(self, v):
        return _landmarkDetector._doubleArray_swap(self, v)

    def begin(self):
        return _landmarkDetector._doubleArray_begin(self)

    def end(self):
        return _landmarkDetector._doubleArray_end(self)

    def rbegin(self):
        return _landmarkDetector._doubleArray_rbegin(self)

    def rend(self):
        return _landmarkDetector._doubleArray_rend(self)

    def clear(self):
        return _landmarkDetector._doubleArray_clear(self)

    def get_allocator(self):
        return _landmarkDetector._doubleArray_get_allocator(self)

    def pop_back(self):
        return _landmarkDetector._doubleArray_pop_back(self)

    def erase(self, *args):
        return _landmarkDetector._doubleArray_erase(self, *args)

    def __init__(self, *args):
        this = _landmarkDetector.new__doubleArray(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        return _landmarkDetector._doubleArray_push_back(self, x)

    def front(self):
        return _landmarkDetector._doubleArray_front(self)

    def back(self):
        return _landmarkDetector._doubleArray_back(self)

    def assign(self, n, x):
        return _landmarkDetector._doubleArray_assign(self, n, x)

    def resize(self, *args):
        return _landmarkDetector._doubleArray_resize(self, *args)

    def insert(self, *args):
        return _landmarkDetector._doubleArray_insert(self, *args)

    def reserve(self, n):
        return _landmarkDetector._doubleArray_reserve(self, n)

    def capacity(self):
        return _landmarkDetector._doubleArray_capacity(self)
    __swig_destroy__ = _landmarkDetector.delete__doubleArray
    __del__ = lambda self: None
_doubleArray_swigregister = _landmarkDetector._doubleArray_swigregister
_doubleArray_swigregister(_doubleArray)


_array_map["double"] = _doubleArray

class _Matx_double_2_1(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, _Matx_double_2_1, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, _Matx_double_2_1, name)
    __repr__ = _swig_repr
    rows = _landmarkDetector._Matx_double_2_1_rows
    cols = _landmarkDetector._Matx_double_2_1_cols
    channels = _landmarkDetector._Matx_double_2_1_channels
    shortdim = _landmarkDetector._Matx_double_2_1_shortdim
    if _newclass:
        all = staticmethod(_landmarkDetector._Matx_double_2_1_all)
    else:
        all = _landmarkDetector._Matx_double_2_1_all
    if _newclass:
        zeros = staticmethod(_landmarkDetector._Matx_double_2_1_zeros)
    else:
        zeros = _landmarkDetector._Matx_double_2_1_zeros
    if _newclass:
        ones = staticmethod(_landmarkDetector._Matx_double_2_1_ones)
    else:
        ones = _landmarkDetector._Matx_double_2_1_ones
    if _newclass:
        eye = staticmethod(_landmarkDetector._Matx_double_2_1_eye)
    else:
        eye = _landmarkDetector._Matx_double_2_1_eye
    if _newclass:
        randu = staticmethod(_landmarkDetector._Matx_double_2_1_randu)
    else:
        randu = _landmarkDetector._Matx_double_2_1_randu
    if _newclass:
        randn = staticmethod(_landmarkDetector._Matx_double_2_1_randn)
    else:
        randn = _landmarkDetector._Matx_double_2_1_randn

    def dot(self, v):
        return _landmarkDetector._Matx_double_2_1_dot(self, v)

    def ddot(self, v):
        return _landmarkDetector._Matx_double_2_1_ddot(self, v)

    def t(self):
        return _landmarkDetector._Matx_double_2_1_t(self)

    def mul(self, a):
        return _landmarkDetector._Matx_double_2_1_mul(self, a)

    def div(self, a):
        return _landmarkDetector._Matx_double_2_1_div(self, a)

    def __call__(self, i, j):
        return _landmarkDetector._Matx_double_2_1___call__(self, i, j)
    __swig_setmethods__["val"] = _landmarkDetector._Matx_double_2_1_val_set
    __swig_getmethods__["val"] = _landmarkDetector._Matx_double_2_1_val_get
    if _newclass:
        val = _swig_property(_landmarkDetector._Matx_double_2_1_val_get, _landmarkDetector._Matx_double_2_1_val_set)

    import re
    _re_pattern = re.compile("^_Matx_(?P<value_type>[a-zA-Z_][a-zA-Z0-9_]*)_(?P<rows>[0-9]+)_(?P<cols>[0-9]+)$")


    def __init__(self, *args):

        ma = self._re_pattern.match(self.__class__.__name__)
        value_type = ma.group("value_type")
        rows = int(ma.group("rows"))
        cols = int(ma.group("cols"))

        array = _array_map[value_type](rows*cols)
        for i in range(len(args)):
            array[i] = args[i]

        args = [array]


        this = _landmarkDetector.new__Matx_double_2_1(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def __getattribute__(self, name):
        if name == "__array_interface__":
            ma = self._re_pattern.match(self.__class__.__name__)
            value_type = ma.group("value_type")
            rows = int(ma.group("rows"))
            cols = int(ma.group("cols"))
            return {"shape": (rows, cols),
                    "typestr": _cv_numpy_typestr_map[value_type],
                    "data": (int(self.val), False)}
        else:
            return object.__getattribute__(self, name)


    def __getitem__(self, key):
        ma = self._re_pattern.match(self.__class__.__name__)
        rows = int(ma.group("rows"))
        cols = int(ma.group("cols"))

        if isinstance(key, int):
            if rows != 1 and cols != 1:
                raise IndexError
            i = key
            j = 0
        elif isinstance(key, tuple) and len(key) == 2:
            i = key[0]
            j = key[1]
        else:
            raise TypeError

        if i >= rows or j >= cols:
            raise IndexError

        return self(i, j)


    def __str__(self):
        return _landmarkDetector._Matx_double_2_1___str__(self)
    __swig_destroy__ = _landmarkDetector.delete__Matx_double_2_1
    __del__ = lambda self: None
_Matx_double_2_1_swigregister = _landmarkDetector._Matx_double_2_1_swigregister
_Matx_double_2_1_swigregister(_Matx_double_2_1)

def _Matx_double_2_1_all(alpha):
    return _landmarkDetector._Matx_double_2_1_all(alpha)
_Matx_double_2_1_all = _landmarkDetector._Matx_double_2_1_all

def _Matx_double_2_1_zeros():
    return _landmarkDetector._Matx_double_2_1_zeros()
_Matx_double_2_1_zeros = _landmarkDetector._Matx_double_2_1_zeros

def _Matx_double_2_1_ones():
    return _landmarkDetector._Matx_double_2_1_ones()
_Matx_double_2_1_ones = _landmarkDetector._Matx_double_2_1_ones

def _Matx_double_2_1_eye():
    return _landmarkDetector._Matx_double_2_1_eye()
_Matx_double_2_1_eye = _landmarkDetector._Matx_double_2_1_eye

def _Matx_double_2_1_randu(a, b):
    return _landmarkDetector._Matx_double_2_1_randu(a, b)
_Matx_double_2_1_randu = _landmarkDetector._Matx_double_2_1_randu

def _Matx_double_2_1_randn(a, b):
    return _landmarkDetector._Matx_double_2_1_randn(a, b)
_Matx_double_2_1_randn = _landmarkDetector._Matx_double_2_1_randn


Matx21d = _Matx_double_2_1

class _Vec_double_2(_Matx_double_2_1):
    __swig_setmethods__ = {}
    for _s in [_Matx_double_2_1]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, _Vec_double_2, name, value)
    __swig_getmethods__ = {}
    for _s in [_Matx_double_2_1]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, _Vec_double_2, name)
    __repr__ = _swig_repr
    channels = _landmarkDetector._Vec_double_2_channels
    if _newclass:
        all = staticmethod(_landmarkDetector._Vec_double_2_all)
    else:
        all = _landmarkDetector._Vec_double_2_all

    def mul(self, v):
        return _landmarkDetector._Vec_double_2_mul(self, v)

    def __call__(self, i):
        return _landmarkDetector._Vec_double_2___call__(self, i)

    import re
    _re_pattern = re.compile("^_Vec_(?P<value_type>[a-zA-Z_][a-zA-Z0-9_]*)_(?P<rows>[0-9]+)$")


    def __init__(self, *args):

        ma = self._re_pattern.match(self.__class__.__name__)
        value_type = ma.group("value_type")
        rows = int(ma.group("rows"))

        array = _array_map[value_type](rows)
        for i in range(len(args)):
            array[i] = args[i]

        args = [array]


        this = _landmarkDetector.new__Vec_double_2(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def __getattribute__(self, name):
        if name == "__array_interface__":
            ma = self._re_pattern.match(self.__class__.__name__)
            value_type = ma.group("value_type")
            rows = int(ma.group("rows"))
            return {"shape": (rows, 1),
                    "typestr": _cv_numpy_typestr_map[value_type],
                    "data": (int(self.val), False)}
        else:
            return object.__getattribute__(self, name)

    def __getitem__(self, key):
        ma = self._re_pattern.match(self.__class__.__name__)
        rows = int(ma.group("rows"))

        if not isinstance(key, int):
            raise TypeError

        if key >= rows:
            raise IndexError

        return self(key)


    def __str__(self):
        return _landmarkDetector._Vec_double_2___str__(self)
    __swig_destroy__ = _landmarkDetector.delete__Vec_double_2
    __del__ = lambda self: None
_Vec_double_2_swigregister = _landmarkDetector._Vec_double_2_swigregister
_Vec_double_2_swigregister(_Vec_double_2)

def _Vec_double_2_all(alpha):
    return _landmarkDetector._Vec_double_2_all(alpha)
_Vec_double_2_all = _landmarkDetector._Vec_double_2_all

class _DataType_Vec_double_2(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, _DataType_Vec_double_2, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, _DataType_Vec_double_2, name)
    __repr__ = _swig_repr
    generic_type = _landmarkDetector._DataType_Vec_double_2_generic_type
    channels = _landmarkDetector._DataType_Vec_double_2_channels
    fmt = _landmarkDetector._DataType_Vec_double_2_fmt

    def __init__(self):
        this = _landmarkDetector.new__DataType_Vec_double_2()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _landmarkDetector.delete__DataType_Vec_double_2
    __del__ = lambda self: None
_DataType_Vec_double_2_swigregister = _landmarkDetector._DataType_Vec_double_2_swigregister
_DataType_Vec_double_2_swigregister(_DataType_Vec_double_2)


Vec2d = _Vec_double_2
DataType_Vec2d = _DataType_Vec_double_2

class _Matx_double_3_1(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, _Matx_double_3_1, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, _Matx_double_3_1, name)
    __repr__ = _swig_repr
    rows = _landmarkDetector._Matx_double_3_1_rows
    cols = _landmarkDetector._Matx_double_3_1_cols
    channels = _landmarkDetector._Matx_double_3_1_channels
    shortdim = _landmarkDetector._Matx_double_3_1_shortdim
    if _newclass:
        all = staticmethod(_landmarkDetector._Matx_double_3_1_all)
    else:
        all = _landmarkDetector._Matx_double_3_1_all
    if _newclass:
        zeros = staticmethod(_landmarkDetector._Matx_double_3_1_zeros)
    else:
        zeros = _landmarkDetector._Matx_double_3_1_zeros
    if _newclass:
        ones = staticmethod(_landmarkDetector._Matx_double_3_1_ones)
    else:
        ones = _landmarkDetector._Matx_double_3_1_ones
    if _newclass:
        eye = staticmethod(_landmarkDetector._Matx_double_3_1_eye)
    else:
        eye = _landmarkDetector._Matx_double_3_1_eye
    if _newclass:
        randu = staticmethod(_landmarkDetector._Matx_double_3_1_randu)
    else:
        randu = _landmarkDetector._Matx_double_3_1_randu
    if _newclass:
        randn = staticmethod(_landmarkDetector._Matx_double_3_1_randn)
    else:
        randn = _landmarkDetector._Matx_double_3_1_randn

    def dot(self, v):
        return _landmarkDetector._Matx_double_3_1_dot(self, v)

    def ddot(self, v):
        return _landmarkDetector._Matx_double_3_1_ddot(self, v)

    def t(self):
        return _landmarkDetector._Matx_double_3_1_t(self)

    def mul(self, a):
        return _landmarkDetector._Matx_double_3_1_mul(self, a)

    def div(self, a):
        return _landmarkDetector._Matx_double_3_1_div(self, a)

    def __call__(self, i, j):
        return _landmarkDetector._Matx_double_3_1___call__(self, i, j)
    __swig_setmethods__["val"] = _landmarkDetector._Matx_double_3_1_val_set
    __swig_getmethods__["val"] = _landmarkDetector._Matx_double_3_1_val_get
    if _newclass:
        val = _swig_property(_landmarkDetector._Matx_double_3_1_val_get, _landmarkDetector._Matx_double_3_1_val_set)

    import re
    _re_pattern = re.compile("^_Matx_(?P<value_type>[a-zA-Z_][a-zA-Z0-9_]*)_(?P<rows>[0-9]+)_(?P<cols>[0-9]+)$")


    def __init__(self, *args):

        ma = self._re_pattern.match(self.__class__.__name__)
        value_type = ma.group("value_type")
        rows = int(ma.group("rows"))
        cols = int(ma.group("cols"))

        array = _array_map[value_type](rows*cols)
        for i in range(len(args)):
            array[i] = args[i]

        args = [array]


        this = _landmarkDetector.new__Matx_double_3_1(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def __getattribute__(self, name):
        if name == "__array_interface__":
            ma = self._re_pattern.match(self.__class__.__name__)
            value_type = ma.group("value_type")
            rows = int(ma.group("rows"))
            cols = int(ma.group("cols"))
            return {"shape": (rows, cols),
                    "typestr": _cv_numpy_typestr_map[value_type],
                    "data": (int(self.val), False)}
        else:
            return object.__getattribute__(self, name)


    def __getitem__(self, key):
        ma = self._re_pattern.match(self.__class__.__name__)
        rows = int(ma.group("rows"))
        cols = int(ma.group("cols"))

        if isinstance(key, int):
            if rows != 1 and cols != 1:
                raise IndexError
            i = key
            j = 0
        elif isinstance(key, tuple) and len(key) == 2:
            i = key[0]
            j = key[1]
        else:
            raise TypeError

        if i >= rows or j >= cols:
            raise IndexError

        return self(i, j)


    def __str__(self):
        return _landmarkDetector._Matx_double_3_1___str__(self)
    __swig_destroy__ = _landmarkDetector.delete__Matx_double_3_1
    __del__ = lambda self: None
_Matx_double_3_1_swigregister = _landmarkDetector._Matx_double_3_1_swigregister
_Matx_double_3_1_swigregister(_Matx_double_3_1)

def _Matx_double_3_1_all(alpha):
    return _landmarkDetector._Matx_double_3_1_all(alpha)
_Matx_double_3_1_all = _landmarkDetector._Matx_double_3_1_all

def _Matx_double_3_1_zeros():
    return _landmarkDetector._Matx_double_3_1_zeros()
_Matx_double_3_1_zeros = _landmarkDetector._Matx_double_3_1_zeros

def _Matx_double_3_1_ones():
    return _landmarkDetector._Matx_double_3_1_ones()
_Matx_double_3_1_ones = _landmarkDetector._Matx_double_3_1_ones

def _Matx_double_3_1_eye():
    return _landmarkDetector._Matx_double_3_1_eye()
_Matx_double_3_1_eye = _landmarkDetector._Matx_double_3_1_eye

def _Matx_double_3_1_randu(a, b):
    return _landmarkDetector._Matx_double_3_1_randu(a, b)
_Matx_double_3_1_randu = _landmarkDetector._Matx_double_3_1_randu

def _Matx_double_3_1_randn(a, b):
    return _landmarkDetector._Matx_double_3_1_randn(a, b)
_Matx_double_3_1_randn = _landmarkDetector._Matx_double_3_1_randn


Matx31d = _Matx_double_3_1

class _Vec_double_3(_Matx_double_3_1):
    __swig_setmethods__ = {}
    for _s in [_Matx_double_3_1]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, _Vec_double_3, name, value)
    __swig_getmethods__ = {}
    for _s in [_Matx_double_3_1]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, _Vec_double_3, name)
    __repr__ = _swig_repr
    channels = _landmarkDetector._Vec_double_3_channels
    if _newclass:
        all = staticmethod(_landmarkDetector._Vec_double_3_all)
    else:
        all = _landmarkDetector._Vec_double_3_all

    def mul(self, v):
        return _landmarkDetector._Vec_double_3_mul(self, v)

    def __call__(self, i):
        return _landmarkDetector._Vec_double_3___call__(self, i)

    import re
    _re_pattern = re.compile("^_Vec_(?P<value_type>[a-zA-Z_][a-zA-Z0-9_]*)_(?P<rows>[0-9]+)$")


    def __init__(self, *args):

        ma = self._re_pattern.match(self.__class__.__name__)
        value_type = ma.group("value_type")
        rows = int(ma.group("rows"))

        array = _array_map[value_type](rows)
        for i in range(len(args)):
            array[i] = args[i]

        args = [array]


        this = _landmarkDetector.new__Vec_double_3(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def __getattribute__(self, name):
        if name == "__array_interface__":
            ma = self._re_pattern.match(self.__class__.__name__)
            value_type = ma.group("value_type")
            rows = int(ma.group("rows"))
            return {"shape": (rows, 1),
                    "typestr": _cv_numpy_typestr_map[value_type],
                    "data": (int(self.val), False)}
        else:
            return object.__getattribute__(self, name)

    def __getitem__(self, key):
        ma = self._re_pattern.match(self.__class__.__name__)
        rows = int(ma.group("rows"))

        if not isinstance(key, int):
            raise TypeError

        if key >= rows:
            raise IndexError

        return self(key)


    def __str__(self):
        return _landmarkDetector._Vec_double_3___str__(self)
    __swig_destroy__ = _landmarkDetector.delete__Vec_double_3
    __del__ = lambda self: None
_Vec_double_3_swigregister = _landmarkDetector._Vec_double_3_swigregister
_Vec_double_3_swigregister(_Vec_double_3)

def _Vec_double_3_all(alpha):
    return _landmarkDetector._Vec_double_3_all(alpha)
_Vec_double_3_all = _landmarkDetector._Vec_double_3_all

class _DataType_Vec_double_3(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, _DataType_Vec_double_3, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, _DataType_Vec_double_3, name)
    __repr__ = _swig_repr
    generic_type = _landmarkDetector._DataType_Vec_double_3_generic_type
    channels = _landmarkDetector._DataType_Vec_double_3_channels
    fmt = _landmarkDetector._DataType_Vec_double_3_fmt

    def __init__(self):
        this = _landmarkDetector.new__DataType_Vec_double_3()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _landmarkDetector.delete__DataType_Vec_double_3
    __del__ = lambda self: None
_DataType_Vec_double_3_swigregister = _landmarkDetector._DataType_Vec_double_3_swigregister
_DataType_Vec_double_3_swigregister(_DataType_Vec_double_3)


Vec3d = _Vec_double_3
DataType_Vec3d = _DataType_Vec_double_3

class _Matx_double_4_1(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, _Matx_double_4_1, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, _Matx_double_4_1, name)
    __repr__ = _swig_repr
    rows = _landmarkDetector._Matx_double_4_1_rows
    cols = _landmarkDetector._Matx_double_4_1_cols
    channels = _landmarkDetector._Matx_double_4_1_channels
    shortdim = _landmarkDetector._Matx_double_4_1_shortdim
    if _newclass:
        all = staticmethod(_landmarkDetector._Matx_double_4_1_all)
    else:
        all = _landmarkDetector._Matx_double_4_1_all
    if _newclass:
        zeros = staticmethod(_landmarkDetector._Matx_double_4_1_zeros)
    else:
        zeros = _landmarkDetector._Matx_double_4_1_zeros
    if _newclass:
        ones = staticmethod(_landmarkDetector._Matx_double_4_1_ones)
    else:
        ones = _landmarkDetector._Matx_double_4_1_ones
    if _newclass:
        eye = staticmethod(_landmarkDetector._Matx_double_4_1_eye)
    else:
        eye = _landmarkDetector._Matx_double_4_1_eye
    if _newclass:
        randu = staticmethod(_landmarkDetector._Matx_double_4_1_randu)
    else:
        randu = _landmarkDetector._Matx_double_4_1_randu
    if _newclass:
        randn = staticmethod(_landmarkDetector._Matx_double_4_1_randn)
    else:
        randn = _landmarkDetector._Matx_double_4_1_randn

    def dot(self, v):
        return _landmarkDetector._Matx_double_4_1_dot(self, v)

    def ddot(self, v):
        return _landmarkDetector._Matx_double_4_1_ddot(self, v)

    def t(self):
        return _landmarkDetector._Matx_double_4_1_t(self)

    def mul(self, a):
        return _landmarkDetector._Matx_double_4_1_mul(self, a)

    def div(self, a):
        return _landmarkDetector._Matx_double_4_1_div(self, a)

    def __call__(self, i, j):
        return _landmarkDetector._Matx_double_4_1___call__(self, i, j)
    __swig_setmethods__["val"] = _landmarkDetector._Matx_double_4_1_val_set
    __swig_getmethods__["val"] = _landmarkDetector._Matx_double_4_1_val_get
    if _newclass:
        val = _swig_property(_landmarkDetector._Matx_double_4_1_val_get, _landmarkDetector._Matx_double_4_1_val_set)

    import re
    _re_pattern = re.compile("^_Matx_(?P<value_type>[a-zA-Z_][a-zA-Z0-9_]*)_(?P<rows>[0-9]+)_(?P<cols>[0-9]+)$")


    def __init__(self, *args):

        ma = self._re_pattern.match(self.__class__.__name__)
        value_type = ma.group("value_type")
        rows = int(ma.group("rows"))
        cols = int(ma.group("cols"))

        array = _array_map[value_type](rows*cols)
        for i in range(len(args)):
            array[i] = args[i]

        args = [array]


        this = _landmarkDetector.new__Matx_double_4_1(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def __getattribute__(self, name):
        if name == "__array_interface__":
            ma = self._re_pattern.match(self.__class__.__name__)
            value_type = ma.group("value_type")
            rows = int(ma.group("rows"))
            cols = int(ma.group("cols"))
            return {"shape": (rows, cols),
                    "typestr": _cv_numpy_typestr_map[value_type],
                    "data": (int(self.val), False)}
        else:
            return object.__getattribute__(self, name)


    def __getitem__(self, key):
        ma = self._re_pattern.match(self.__class__.__name__)
        rows = int(ma.group("rows"))
        cols = int(ma.group("cols"))

        if isinstance(key, int):
            if rows != 1 and cols != 1:
                raise IndexError
            i = key
            j = 0
        elif isinstance(key, tuple) and len(key) == 2:
            i = key[0]
            j = key[1]
        else:
            raise TypeError

        if i >= rows or j >= cols:
            raise IndexError

        return self(i, j)


    def __str__(self):
        return _landmarkDetector._Matx_double_4_1___str__(self)
    __swig_destroy__ = _landmarkDetector.delete__Matx_double_4_1
    __del__ = lambda self: None
_Matx_double_4_1_swigregister = _landmarkDetector._Matx_double_4_1_swigregister
_Matx_double_4_1_swigregister(_Matx_double_4_1)

def _Matx_double_4_1_all(alpha):
    return _landmarkDetector._Matx_double_4_1_all(alpha)
_Matx_double_4_1_all = _landmarkDetector._Matx_double_4_1_all

def _Matx_double_4_1_zeros():
    return _landmarkDetector._Matx_double_4_1_zeros()
_Matx_double_4_1_zeros = _landmarkDetector._Matx_double_4_1_zeros

def _Matx_double_4_1_ones():
    return _landmarkDetector._Matx_double_4_1_ones()
_Matx_double_4_1_ones = _landmarkDetector._Matx_double_4_1_ones

def _Matx_double_4_1_eye():
    return _landmarkDetector._Matx_double_4_1_eye()
_Matx_double_4_1_eye = _landmarkDetector._Matx_double_4_1_eye

def _Matx_double_4_1_randu(a, b):
    return _landmarkDetector._Matx_double_4_1_randu(a, b)
_Matx_double_4_1_randu = _landmarkDetector._Matx_double_4_1_randu

def _Matx_double_4_1_randn(a, b):
    return _landmarkDetector._Matx_double_4_1_randn(a, b)
_Matx_double_4_1_randn = _landmarkDetector._Matx_double_4_1_randn


Matx41d = _Matx_double_4_1

class _Vec_double_4(_Matx_double_4_1):
    __swig_setmethods__ = {}
    for _s in [_Matx_double_4_1]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, _Vec_double_4, name, value)
    __swig_getmethods__ = {}
    for _s in [_Matx_double_4_1]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, _Vec_double_4, name)
    __repr__ = _swig_repr
    channels = _landmarkDetector._Vec_double_4_channels
    if _newclass:
        all = staticmethod(_landmarkDetector._Vec_double_4_all)
    else:
        all = _landmarkDetector._Vec_double_4_all

    def mul(self, v):
        return _landmarkDetector._Vec_double_4_mul(self, v)

    def __call__(self, i):
        return _landmarkDetector._Vec_double_4___call__(self, i)

    import re
    _re_pattern = re.compile("^_Vec_(?P<value_type>[a-zA-Z_][a-zA-Z0-9_]*)_(?P<rows>[0-9]+)$")


    def __init__(self, *args):

        ma = self._re_pattern.match(self.__class__.__name__)
        value_type = ma.group("value_type")
        rows = int(ma.group("rows"))

        array = _array_map[value_type](rows)
        for i in range(len(args)):
            array[i] = args[i]

        args = [array]


        this = _landmarkDetector.new__Vec_double_4(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def __getattribute__(self, name):
        if name == "__array_interface__":
            ma = self._re_pattern.match(self.__class__.__name__)
            value_type = ma.group("value_type")
            rows = int(ma.group("rows"))
            return {"shape": (rows, 1),
                    "typestr": _cv_numpy_typestr_map[value_type],
                    "data": (int(self.val), False)}
        else:
            return object.__getattribute__(self, name)

    def __getitem__(self, key):
        ma = self._re_pattern.match(self.__class__.__name__)
        rows = int(ma.group("rows"))

        if not isinstance(key, int):
            raise TypeError

        if key >= rows:
            raise IndexError

        return self(key)


    def __str__(self):
        return _landmarkDetector._Vec_double_4___str__(self)
    __swig_destroy__ = _landmarkDetector.delete__Vec_double_4
    __del__ = lambda self: None
_Vec_double_4_swigregister = _landmarkDetector._Vec_double_4_swigregister
_Vec_double_4_swigregister(_Vec_double_4)

def _Vec_double_4_all(alpha):
    return _landmarkDetector._Vec_double_4_all(alpha)
_Vec_double_4_all = _landmarkDetector._Vec_double_4_all

class _DataType_Vec_double_4(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, _DataType_Vec_double_4, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, _DataType_Vec_double_4, name)
    __repr__ = _swig_repr
    generic_type = _landmarkDetector._DataType_Vec_double_4_generic_type
    channels = _landmarkDetector._DataType_Vec_double_4_channels
    fmt = _landmarkDetector._DataType_Vec_double_4_fmt

    def __init__(self):
        this = _landmarkDetector.new__DataType_Vec_double_4()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _landmarkDetector.delete__DataType_Vec_double_4
    __del__ = lambda self: None
_DataType_Vec_double_4_swigregister = _landmarkDetector._DataType_Vec_double_4_swigregister
_DataType_Vec_double_4_swigregister(_DataType_Vec_double_4)


Vec4d = _Vec_double_4
DataType_Vec4d = _DataType_Vec_double_4

class _Matx_double_6_1(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, _Matx_double_6_1, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, _Matx_double_6_1, name)
    __repr__ = _swig_repr
    rows = _landmarkDetector._Matx_double_6_1_rows
    cols = _landmarkDetector._Matx_double_6_1_cols
    channels = _landmarkDetector._Matx_double_6_1_channels
    shortdim = _landmarkDetector._Matx_double_6_1_shortdim
    if _newclass:
        all = staticmethod(_landmarkDetector._Matx_double_6_1_all)
    else:
        all = _landmarkDetector._Matx_double_6_1_all
    if _newclass:
        zeros = staticmethod(_landmarkDetector._Matx_double_6_1_zeros)
    else:
        zeros = _landmarkDetector._Matx_double_6_1_zeros
    if _newclass:
        ones = staticmethod(_landmarkDetector._Matx_double_6_1_ones)
    else:
        ones = _landmarkDetector._Matx_double_6_1_ones
    if _newclass:
        eye = staticmethod(_landmarkDetector._Matx_double_6_1_eye)
    else:
        eye = _landmarkDetector._Matx_double_6_1_eye
    if _newclass:
        randu = staticmethod(_landmarkDetector._Matx_double_6_1_randu)
    else:
        randu = _landmarkDetector._Matx_double_6_1_randu
    if _newclass:
        randn = staticmethod(_landmarkDetector._Matx_double_6_1_randn)
    else:
        randn = _landmarkDetector._Matx_double_6_1_randn

    def dot(self, v):
        return _landmarkDetector._Matx_double_6_1_dot(self, v)

    def ddot(self, v):
        return _landmarkDetector._Matx_double_6_1_ddot(self, v)

    def t(self):
        return _landmarkDetector._Matx_double_6_1_t(self)

    def mul(self, a):
        return _landmarkDetector._Matx_double_6_1_mul(self, a)

    def div(self, a):
        return _landmarkDetector._Matx_double_6_1_div(self, a)

    def __call__(self, i, j):
        return _landmarkDetector._Matx_double_6_1___call__(self, i, j)
    __swig_setmethods__["val"] = _landmarkDetector._Matx_double_6_1_val_set
    __swig_getmethods__["val"] = _landmarkDetector._Matx_double_6_1_val_get
    if _newclass:
        val = _swig_property(_landmarkDetector._Matx_double_6_1_val_get, _landmarkDetector._Matx_double_6_1_val_set)

    import re
    _re_pattern = re.compile("^_Matx_(?P<value_type>[a-zA-Z_][a-zA-Z0-9_]*)_(?P<rows>[0-9]+)_(?P<cols>[0-9]+)$")


    def __init__(self, *args):

        ma = self._re_pattern.match(self.__class__.__name__)
        value_type = ma.group("value_type")
        rows = int(ma.group("rows"))
        cols = int(ma.group("cols"))

        array = _array_map[value_type](rows*cols)
        for i in range(len(args)):
            array[i] = args[i]

        args = [array]


        this = _landmarkDetector.new__Matx_double_6_1(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def __getattribute__(self, name):
        if name == "__array_interface__":
            ma = self._re_pattern.match(self.__class__.__name__)
            value_type = ma.group("value_type")
            rows = int(ma.group("rows"))
            cols = int(ma.group("cols"))
            return {"shape": (rows, cols),
                    "typestr": _cv_numpy_typestr_map[value_type],
                    "data": (int(self.val), False)}
        else:
            return object.__getattribute__(self, name)


    def __getitem__(self, key):
        ma = self._re_pattern.match(self.__class__.__name__)
        rows = int(ma.group("rows"))
        cols = int(ma.group("cols"))

        if isinstance(key, int):
            if rows != 1 and cols != 1:
                raise IndexError
            i = key
            j = 0
        elif isinstance(key, tuple) and len(key) == 2:
            i = key[0]
            j = key[1]
        else:
            raise TypeError

        if i >= rows or j >= cols:
            raise IndexError

        return self(i, j)


    def __str__(self):
        return _landmarkDetector._Matx_double_6_1___str__(self)
    __swig_destroy__ = _landmarkDetector.delete__Matx_double_6_1
    __del__ = lambda self: None
_Matx_double_6_1_swigregister = _landmarkDetector._Matx_double_6_1_swigregister
_Matx_double_6_1_swigregister(_Matx_double_6_1)

def _Matx_double_6_1_all(alpha):
    return _landmarkDetector._Matx_double_6_1_all(alpha)
_Matx_double_6_1_all = _landmarkDetector._Matx_double_6_1_all

def _Matx_double_6_1_zeros():
    return _landmarkDetector._Matx_double_6_1_zeros()
_Matx_double_6_1_zeros = _landmarkDetector._Matx_double_6_1_zeros

def _Matx_double_6_1_ones():
    return _landmarkDetector._Matx_double_6_1_ones()
_Matx_double_6_1_ones = _landmarkDetector._Matx_double_6_1_ones

def _Matx_double_6_1_eye():
    return _landmarkDetector._Matx_double_6_1_eye()
_Matx_double_6_1_eye = _landmarkDetector._Matx_double_6_1_eye

def _Matx_double_6_1_randu(a, b):
    return _landmarkDetector._Matx_double_6_1_randu(a, b)
_Matx_double_6_1_randu = _landmarkDetector._Matx_double_6_1_randu

def _Matx_double_6_1_randn(a, b):
    return _landmarkDetector._Matx_double_6_1_randn(a, b)
_Matx_double_6_1_randn = _landmarkDetector._Matx_double_6_1_randn


Matx61d = _Matx_double_6_1

class _Vec_double_6(_Matx_double_6_1):
    __swig_setmethods__ = {}
    for _s in [_Matx_double_6_1]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, _Vec_double_6, name, value)
    __swig_getmethods__ = {}
    for _s in [_Matx_double_6_1]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, _Vec_double_6, name)
    __repr__ = _swig_repr
    channels = _landmarkDetector._Vec_double_6_channels
    if _newclass:
        all = staticmethod(_landmarkDetector._Vec_double_6_all)
    else:
        all = _landmarkDetector._Vec_double_6_all

    def mul(self, v):
        return _landmarkDetector._Vec_double_6_mul(self, v)

    def __call__(self, i):
        return _landmarkDetector._Vec_double_6___call__(self, i)

    import re
    _re_pattern = re.compile("^_Vec_(?P<value_type>[a-zA-Z_][a-zA-Z0-9_]*)_(?P<rows>[0-9]+)$")


    def __init__(self, *args):

        ma = self._re_pattern.match(self.__class__.__name__)
        value_type = ma.group("value_type")
        rows = int(ma.group("rows"))

        array = _array_map[value_type](rows)
        for i in range(len(args)):
            array[i] = args[i]

        args = [array]


        this = _landmarkDetector.new__Vec_double_6(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def __getattribute__(self, name):
        if name == "__array_interface__":
            ma = self._re_pattern.match(self.__class__.__name__)
            value_type = ma.group("value_type")
            rows = int(ma.group("rows"))
            return {"shape": (rows, 1),
                    "typestr": _cv_numpy_typestr_map[value_type],
                    "data": (int(self.val), False)}
        else:
            return object.__getattribute__(self, name)

    def __getitem__(self, key):
        ma = self._re_pattern.match(self.__class__.__name__)
        rows = int(ma.group("rows"))

        if not isinstance(key, int):
            raise TypeError

        if key >= rows:
            raise IndexError

        return self(key)


    def __str__(self):
        return _landmarkDetector._Vec_double_6___str__(self)
    __swig_destroy__ = _landmarkDetector.delete__Vec_double_6
    __del__ = lambda self: None
_Vec_double_6_swigregister = _landmarkDetector._Vec_double_6_swigregister
_Vec_double_6_swigregister(_Vec_double_6)

def _Vec_double_6_all(alpha):
    return _landmarkDetector._Vec_double_6_all(alpha)
_Vec_double_6_all = _landmarkDetector._Vec_double_6_all

class _DataType_Vec_double_6(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, _DataType_Vec_double_6, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, _DataType_Vec_double_6, name)
    __repr__ = _swig_repr
    generic_type = _landmarkDetector._DataType_Vec_double_6_generic_type
    channels = _landmarkDetector._DataType_Vec_double_6_channels
    fmt = _landmarkDetector._DataType_Vec_double_6_fmt

    def __init__(self):
        this = _landmarkDetector.new__DataType_Vec_double_6()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _landmarkDetector.delete__DataType_Vec_double_6
    __del__ = lambda self: None
_DataType_Vec_double_6_swigregister = _landmarkDetector._DataType_Vec_double_6_swigregister
_DataType_Vec_double_6_swigregister(_DataType_Vec_double_6)


Vec6d = _Vec_double_6
DataType_Vec6d = _DataType_Vec_double_6

class _mat__np_array_constructor(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, _mat__np_array_constructor, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, _mat__np_array_constructor, name)
    __repr__ = _swig_repr

    def __init__(self):
        this = _landmarkDetector.new__mat__np_array_constructor()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _landmarkDetector.delete__mat__np_array_constructor
    __del__ = lambda self: None
_mat__np_array_constructor_swigregister = _landmarkDetector._mat__np_array_constructor_swigregister
_mat__np_array_constructor_swigregister(_mat__np_array_constructor)


def _depthToDtype(depth):
    return _landmarkDetector._depthToDtype(depth)
_depthToDtype = _landmarkDetector._depthToDtype

def _toCvType(dtype, nChannel):
    return _landmarkDetector._toCvType(dtype, nChannel)
_toCvType = _landmarkDetector._toCvType
class StringVector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, StringVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, StringVector, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _landmarkDetector.StringVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _landmarkDetector.StringVector___nonzero__(self)

    def __bool__(self):
        return _landmarkDetector.StringVector___bool__(self)

    def __len__(self):
        return _landmarkDetector.StringVector___len__(self)

    def __getslice__(self, i, j):
        return _landmarkDetector.StringVector___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _landmarkDetector.StringVector___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _landmarkDetector.StringVector___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _landmarkDetector.StringVector___delitem__(self, *args)

    def __getitem__(self, *args):
        return _landmarkDetector.StringVector___getitem__(self, *args)

    def __setitem__(self, *args):
        return _landmarkDetector.StringVector___setitem__(self, *args)

    def pop(self):
        return _landmarkDetector.StringVector_pop(self)

    def append(self, x):
        return _landmarkDetector.StringVector_append(self, x)

    def empty(self):
        return _landmarkDetector.StringVector_empty(self)

    def size(self):
        return _landmarkDetector.StringVector_size(self)

    def swap(self, v):
        return _landmarkDetector.StringVector_swap(self, v)

    def begin(self):
        return _landmarkDetector.StringVector_begin(self)

    def end(self):
        return _landmarkDetector.StringVector_end(self)

    def rbegin(self):
        return _landmarkDetector.StringVector_rbegin(self)

    def rend(self):
        return _landmarkDetector.StringVector_rend(self)

    def clear(self):
        return _landmarkDetector.StringVector_clear(self)

    def get_allocator(self):
        return _landmarkDetector.StringVector_get_allocator(self)

    def pop_back(self):
        return _landmarkDetector.StringVector_pop_back(self)

    def erase(self, *args):
        return _landmarkDetector.StringVector_erase(self, *args)

    def __init__(self, *args):
        this = _landmarkDetector.new_StringVector(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        return _landmarkDetector.StringVector_push_back(self, x)

    def front(self):
        return _landmarkDetector.StringVector_front(self)

    def back(self):
        return _landmarkDetector.StringVector_back(self)

    def assign(self, n, x):
        return _landmarkDetector.StringVector_assign(self, n, x)

    def resize(self, *args):
        return _landmarkDetector.StringVector_resize(self, *args)

    def insert(self, *args):
        return _landmarkDetector.StringVector_insert(self, *args)

    def reserve(self, n):
        return _landmarkDetector.StringVector_reserve(self, n)

    def capacity(self):
        return _landmarkDetector.StringVector_capacity(self)
    __swig_destroy__ = _landmarkDetector.delete_StringVector
    __del__ = lambda self: None
StringVector_swigregister = _landmarkDetector.StringVector_swigregister
StringVector_swigregister(StringVector)

class PairDoulbeVector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, PairDoulbeVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, PairDoulbeVector, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _landmarkDetector.PairDoulbeVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _landmarkDetector.PairDoulbeVector___nonzero__(self)

    def __bool__(self):
        return _landmarkDetector.PairDoulbeVector___bool__(self)

    def __len__(self):
        return _landmarkDetector.PairDoulbeVector___len__(self)

    def __getslice__(self, i, j):
        return _landmarkDetector.PairDoulbeVector___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _landmarkDetector.PairDoulbeVector___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _landmarkDetector.PairDoulbeVector___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _landmarkDetector.PairDoulbeVector___delitem__(self, *args)

    def __getitem__(self, *args):
        return _landmarkDetector.PairDoulbeVector___getitem__(self, *args)

    def __setitem__(self, *args):
        return _landmarkDetector.PairDoulbeVector___setitem__(self, *args)

    def pop(self):
        return _landmarkDetector.PairDoulbeVector_pop(self)

    def append(self, x):
        return _landmarkDetector.PairDoulbeVector_append(self, x)

    def empty(self):
        return _landmarkDetector.PairDoulbeVector_empty(self)

    def size(self):
        return _landmarkDetector.PairDoulbeVector_size(self)

    def swap(self, v):
        return _landmarkDetector.PairDoulbeVector_swap(self, v)

    def begin(self):
        return _landmarkDetector.PairDoulbeVector_begin(self)

    def end(self):
        return _landmarkDetector.PairDoulbeVector_end(self)

    def rbegin(self):
        return _landmarkDetector.PairDoulbeVector_rbegin(self)

    def rend(self):
        return _landmarkDetector.PairDoulbeVector_rend(self)

    def clear(self):
        return _landmarkDetector.PairDoulbeVector_clear(self)

    def get_allocator(self):
        return _landmarkDetector.PairDoulbeVector_get_allocator(self)

    def pop_back(self):
        return _landmarkDetector.PairDoulbeVector_pop_back(self)

    def erase(self, *args):
        return _landmarkDetector.PairDoulbeVector_erase(self, *args)

    def __init__(self, *args):
        this = _landmarkDetector.new_PairDoulbeVector(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        return _landmarkDetector.PairDoulbeVector_push_back(self, x)

    def front(self):
        return _landmarkDetector.PairDoulbeVector_front(self)

    def back(self):
        return _landmarkDetector.PairDoulbeVector_back(self)

    def assign(self, n, x):
        return _landmarkDetector.PairDoulbeVector_assign(self, n, x)

    def resize(self, *args):
        return _landmarkDetector.PairDoulbeVector_resize(self, *args)

    def insert(self, *args):
        return _landmarkDetector.PairDoulbeVector_insert(self, *args)

    def reserve(self, n):
        return _landmarkDetector.PairDoulbeVector_reserve(self, n)

    def capacity(self):
        return _landmarkDetector.PairDoulbeVector_capacity(self)
    __swig_destroy__ = _landmarkDetector.delete_PairDoulbeVector
    __del__ = lambda self: None
PairDoulbeVector_swigregister = _landmarkDetector.PairDoulbeVector_swigregister
PairDoulbeVector_swigregister(PairDoulbeVector)

class DoublePair(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, DoublePair, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, DoublePair, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _landmarkDetector.new_DoublePair(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_setmethods__["first"] = _landmarkDetector.DoublePair_first_set
    __swig_getmethods__["first"] = _landmarkDetector.DoublePair_first_get
    if _newclass:
        first = _swig_property(_landmarkDetector.DoublePair_first_get, _landmarkDetector.DoublePair_first_set)
    __swig_setmethods__["second"] = _landmarkDetector.DoublePair_second_set
    __swig_getmethods__["second"] = _landmarkDetector.DoublePair_second_get
    if _newclass:
        second = _swig_property(_landmarkDetector.DoublePair_second_get, _landmarkDetector.DoublePair_second_set)
    def __len__(self):
        return 2
    def __repr__(self):
        return str((self.first, self.second))
    def __getitem__(self, index): 
        if not (index % 2):
            return self.first
        else:
            return self.second
    def __setitem__(self, index, val):
        if not (index % 2):
            self.first = val
        else:
            self.second = val
    __swig_destroy__ = _landmarkDetector.delete_DoublePair
    __del__ = lambda self: None
DoublePair_swigregister = _landmarkDetector.DoublePair_swigregister
DoublePair_swigregister(DoublePair)

class FloatRectVector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, FloatRectVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, FloatRectVector, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _landmarkDetector.FloatRectVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _landmarkDetector.FloatRectVector___nonzero__(self)

    def __bool__(self):
        return _landmarkDetector.FloatRectVector___bool__(self)

    def __len__(self):
        return _landmarkDetector.FloatRectVector___len__(self)

    def __getslice__(self, i, j):
        return _landmarkDetector.FloatRectVector___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _landmarkDetector.FloatRectVector___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _landmarkDetector.FloatRectVector___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _landmarkDetector.FloatRectVector___delitem__(self, *args)

    def __getitem__(self, *args):
        return _landmarkDetector.FloatRectVector___getitem__(self, *args)

    def __setitem__(self, *args):
        return _landmarkDetector.FloatRectVector___setitem__(self, *args)

    def pop(self):
        return _landmarkDetector.FloatRectVector_pop(self)

    def append(self, x):
        return _landmarkDetector.FloatRectVector_append(self, x)

    def empty(self):
        return _landmarkDetector.FloatRectVector_empty(self)

    def size(self):
        return _landmarkDetector.FloatRectVector_size(self)

    def swap(self, v):
        return _landmarkDetector.FloatRectVector_swap(self, v)

    def begin(self):
        return _landmarkDetector.FloatRectVector_begin(self)

    def end(self):
        return _landmarkDetector.FloatRectVector_end(self)

    def rbegin(self):
        return _landmarkDetector.FloatRectVector_rbegin(self)

    def rend(self):
        return _landmarkDetector.FloatRectVector_rend(self)

    def clear(self):
        return _landmarkDetector.FloatRectVector_clear(self)

    def get_allocator(self):
        return _landmarkDetector.FloatRectVector_get_allocator(self)

    def pop_back(self):
        return _landmarkDetector.FloatRectVector_pop_back(self)

    def erase(self, *args):
        return _landmarkDetector.FloatRectVector_erase(self, *args)

    def __init__(self, *args):
        this = _landmarkDetector.new_FloatRectVector(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        return _landmarkDetector.FloatRectVector_push_back(self, x)

    def front(self):
        return _landmarkDetector.FloatRectVector_front(self)

    def back(self):
        return _landmarkDetector.FloatRectVector_back(self)

    def assign(self, n, x):
        return _landmarkDetector.FloatRectVector_assign(self, n, x)

    def resize(self, *args):
        return _landmarkDetector.FloatRectVector_resize(self, *args)

    def insert(self, *args):
        return _landmarkDetector.FloatRectVector_insert(self, *args)

    def reserve(self, n):
        return _landmarkDetector.FloatRectVector_reserve(self, n)

    def capacity(self):
        return _landmarkDetector.FloatRectVector_capacity(self)
    __swig_destroy__ = _landmarkDetector.delete_FloatRectVector
    __del__ = lambda self: None
FloatRectVector_swigregister = _landmarkDetector.FloatRectVector_swigregister
FloatRectVector_swigregister(FloatRectVector)

class Rect2f(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Rect2f, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Rect2f, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _landmarkDetector.new_Rect2f(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def tl(self):
        return _landmarkDetector.Rect2f_tl(self)

    def br(self):
        return _landmarkDetector.Rect2f_br(self)

    def size(self):
        return _landmarkDetector.Rect2f_size(self)

    def area(self):
        return _landmarkDetector.Rect2f_area(self)

    def contains(self, pt):
        return _landmarkDetector.Rect2f_contains(self, pt)
    __swig_setmethods__["x"] = _landmarkDetector.Rect2f_x_set
    __swig_getmethods__["x"] = _landmarkDetector.Rect2f_x_get
    if _newclass:
        x = _swig_property(_landmarkDetector.Rect2f_x_get, _landmarkDetector.Rect2f_x_set)
    __swig_setmethods__["y"] = _landmarkDetector.Rect2f_y_set
    __swig_getmethods__["y"] = _landmarkDetector.Rect2f_y_get
    if _newclass:
        y = _swig_property(_landmarkDetector.Rect2f_y_get, _landmarkDetector.Rect2f_y_set)
    __swig_setmethods__["width"] = _landmarkDetector.Rect2f_width_set
    __swig_getmethods__["width"] = _landmarkDetector.Rect2f_width_get
    if _newclass:
        width = _swig_property(_landmarkDetector.Rect2f_width_get, _landmarkDetector.Rect2f_width_set)
    __swig_setmethods__["height"] = _landmarkDetector.Rect2f_height_set
    __swig_getmethods__["height"] = _landmarkDetector.Rect2f_height_get
    if _newclass:
        height = _swig_property(_landmarkDetector.Rect2f_height_get, _landmarkDetector.Rect2f_height_set)

    def __iter__(self):
        return iter((self.x, self.y, self.width, self.height))


    def __str__(self):
        return _landmarkDetector.Rect2f___str__(self)
    __swig_destroy__ = _landmarkDetector.delete_Rect2f
    __del__ = lambda self: None
Rect2f_swigregister = _landmarkDetector.Rect2f_swigregister
Rect2f_swigregister(Rect2f)

class Rect2d(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Rect2d, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Rect2d, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _landmarkDetector.new_Rect2d(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def tl(self):
        return _landmarkDetector.Rect2d_tl(self)

    def br(self):
        return _landmarkDetector.Rect2d_br(self)

    def size(self):
        return _landmarkDetector.Rect2d_size(self)

    def area(self):
        return _landmarkDetector.Rect2d_area(self)

    def contains(self, pt):
        return _landmarkDetector.Rect2d_contains(self, pt)
    __swig_setmethods__["x"] = _landmarkDetector.Rect2d_x_set
    __swig_getmethods__["x"] = _landmarkDetector.Rect2d_x_get
    if _newclass:
        x = _swig_property(_landmarkDetector.Rect2d_x_get, _landmarkDetector.Rect2d_x_set)
    __swig_setmethods__["y"] = _landmarkDetector.Rect2d_y_set
    __swig_getmethods__["y"] = _landmarkDetector.Rect2d_y_get
    if _newclass:
        y = _swig_property(_landmarkDetector.Rect2d_y_get, _landmarkDetector.Rect2d_y_set)
    __swig_setmethods__["width"] = _landmarkDetector.Rect2d_width_set
    __swig_getmethods__["width"] = _landmarkDetector.Rect2d_width_get
    if _newclass:
        width = _swig_property(_landmarkDetector.Rect2d_width_get, _landmarkDetector.Rect2d_width_set)
    __swig_setmethods__["height"] = _landmarkDetector.Rect2d_height_set
    __swig_getmethods__["height"] = _landmarkDetector.Rect2d_height_get
    if _newclass:
        height = _swig_property(_landmarkDetector.Rect2d_height_get, _landmarkDetector.Rect2d_height_set)

    def __iter__(self):
        return iter((self.x, self.y, self.width, self.height))


    def __str__(self):
        return _landmarkDetector.Rect2d___str__(self)
    __swig_destroy__ = _landmarkDetector.delete_Rect2d
    __del__ = lambda self: None
Rect2d_swigregister = _landmarkDetector.Rect2d_swigregister
Rect2d_swigregister(Rect2d)

class Mat2uchar(Mat):
    __swig_setmethods__ = {}
    for _s in [Mat]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Mat2uchar, name, value)
    __swig_getmethods__ = {}
    for _s in [Mat]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Mat2uchar, name)
    __repr__ = _swig_repr

    def create(self, *args):
        return _landmarkDetector.Mat2uchar_create(self, *args)

    def cross(self, m):
        return _landmarkDetector.Mat2uchar_cross(self, m)

    def row(self, y):
        return _landmarkDetector.Mat2uchar_row(self, y)

    def col(self, x):
        return _landmarkDetector.Mat2uchar_col(self, x)

    def diag(self, d=0):
        return _landmarkDetector.Mat2uchar_diag(self, d)

    def clone(self):
        return _landmarkDetector.Mat2uchar_clone(self)

    def elemSize(self):
        return _landmarkDetector.Mat2uchar_elemSize(self)

    def elemSize1(self):
        return _landmarkDetector.Mat2uchar_elemSize1(self)

    def type(self):
        return _landmarkDetector.Mat2uchar_type(self)

    def depth(self):
        return _landmarkDetector.Mat2uchar_depth(self)

    def channels(self):
        return _landmarkDetector.Mat2uchar_channels(self)

    def step1(self, i=0):
        return _landmarkDetector.Mat2uchar_step1(self, i)

    def stepT(self, i=0):
        return _landmarkDetector.Mat2uchar_stepT(self, i)

    def adjustROI(self, dtop, dbottom, dleft, dright):
        return _landmarkDetector.Mat2uchar_adjustROI(self, dtop, dbottom, dleft, dright)

    def __call__(self, *args):
        return _landmarkDetector.Mat2uchar___call__(self, *args)

    def __init__(self, *args):
        this = _landmarkDetector.new_Mat2uchar(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    @classmethod
    def __check_channels_compatibility(cls, array):
        obj = cls()
        n_channel = obj.channels()

        if n_channel == 1:
            if len(array.shape) != 2:
                raise ValueError("{} expects a 2-dimensional numpy ndarray.".format(cls))
        else:
            if len(array.shape) != 3:
                raise ValueError("{} expects a 3-dimensional numpy ndarray.".format(cls))
            elif array.shape[2] != n_channel:
                raise ValueError("{} expects the last ndarray dimension to have a size of {}".format(cls, n_channel))

    @classmethod
    def from_array(cls, array):
        import numpy as np
        array = np.asarray(array)

        if cls()._typestr() != array.__array_interface__['typestr']:
            raise ValueError("{} expects a {} datatype.".format(cls, cls()._typestr()))

        cls.__check_channels_compatibility(array)

        new_mat = cls(_mat__np_array_constructor(),
                      array.shape[0],
                      array.shape[1],
                      array.__array_interface__['data'][0])

    # Holds an internal reference to keep the image buffer alive
        new_mat._array = array

        return new_mat


    def __str__(self):
        return _landmarkDetector.Mat2uchar___str__(self)
    __swig_destroy__ = _landmarkDetector.delete_Mat2uchar
    __del__ = lambda self: None
Mat2uchar_swigregister = _landmarkDetector.Mat2uchar_swigregister
Mat2uchar_swigregister(Mat2uchar)

class Mat2f(Mat):
    __swig_setmethods__ = {}
    for _s in [Mat]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Mat2f, name, value)
    __swig_getmethods__ = {}
    for _s in [Mat]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Mat2f, name)
    __repr__ = _swig_repr

    def create(self, *args):
        return _landmarkDetector.Mat2f_create(self, *args)

    def cross(self, m):
        return _landmarkDetector.Mat2f_cross(self, m)

    def row(self, y):
        return _landmarkDetector.Mat2f_row(self, y)

    def col(self, x):
        return _landmarkDetector.Mat2f_col(self, x)

    def diag(self, d=0):
        return _landmarkDetector.Mat2f_diag(self, d)

    def clone(self):
        return _landmarkDetector.Mat2f_clone(self)

    def elemSize(self):
        return _landmarkDetector.Mat2f_elemSize(self)

    def elemSize1(self):
        return _landmarkDetector.Mat2f_elemSize1(self)

    def type(self):
        return _landmarkDetector.Mat2f_type(self)

    def depth(self):
        return _landmarkDetector.Mat2f_depth(self)

    def channels(self):
        return _landmarkDetector.Mat2f_channels(self)

    def step1(self, i=0):
        return _landmarkDetector.Mat2f_step1(self, i)

    def stepT(self, i=0):
        return _landmarkDetector.Mat2f_stepT(self, i)

    def adjustROI(self, dtop, dbottom, dleft, dright):
        return _landmarkDetector.Mat2f_adjustROI(self, dtop, dbottom, dleft, dright)

    def __call__(self, *args):
        return _landmarkDetector.Mat2f___call__(self, *args)

    def __init__(self, *args):
        this = _landmarkDetector.new_Mat2f(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    @classmethod
    def __check_channels_compatibility(cls, array):
        obj = cls()
        n_channel = obj.channels()

        if n_channel == 1:
            if len(array.shape) != 2:
                raise ValueError("{} expects a 2-dimensional numpy ndarray.".format(cls))
        else:
            if len(array.shape) != 3:
                raise ValueError("{} expects a 3-dimensional numpy ndarray.".format(cls))
            elif array.shape[2] != n_channel:
                raise ValueError("{} expects the last ndarray dimension to have a size of {}".format(cls, n_channel))

    @classmethod
    def from_array(cls, array):
        import numpy as np
        array = np.asarray(array)

        if cls()._typestr() != array.__array_interface__['typestr']:
            raise ValueError("{} expects a {} datatype.".format(cls, cls()._typestr()))

        cls.__check_channels_compatibility(array)

        new_mat = cls(_mat__np_array_constructor(),
                      array.shape[0],
                      array.shape[1],
                      array.__array_interface__['data'][0])

    # Holds an internal reference to keep the image buffer alive
        new_mat._array = array

        return new_mat


    def __str__(self):
        return _landmarkDetector.Mat2f___str__(self)
    __swig_destroy__ = _landmarkDetector.delete_Mat2f
    __del__ = lambda self: None
Mat2f_swigregister = _landmarkDetector.Mat2f_swigregister
Mat2f_swigregister(Mat2f)

class Mat2d(Mat):
    __swig_setmethods__ = {}
    for _s in [Mat]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Mat2d, name, value)
    __swig_getmethods__ = {}
    for _s in [Mat]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Mat2d, name)
    __repr__ = _swig_repr

    def create(self, *args):
        return _landmarkDetector.Mat2d_create(self, *args)

    def cross(self, m):
        return _landmarkDetector.Mat2d_cross(self, m)

    def row(self, y):
        return _landmarkDetector.Mat2d_row(self, y)

    def col(self, x):
        return _landmarkDetector.Mat2d_col(self, x)

    def diag(self, d=0):
        return _landmarkDetector.Mat2d_diag(self, d)

    def clone(self):
        return _landmarkDetector.Mat2d_clone(self)

    def elemSize(self):
        return _landmarkDetector.Mat2d_elemSize(self)

    def elemSize1(self):
        return _landmarkDetector.Mat2d_elemSize1(self)

    def type(self):
        return _landmarkDetector.Mat2d_type(self)

    def depth(self):
        return _landmarkDetector.Mat2d_depth(self)

    def channels(self):
        return _landmarkDetector.Mat2d_channels(self)

    def step1(self, i=0):
        return _landmarkDetector.Mat2d_step1(self, i)

    def stepT(self, i=0):
        return _landmarkDetector.Mat2d_stepT(self, i)

    def adjustROI(self, dtop, dbottom, dleft, dright):
        return _landmarkDetector.Mat2d_adjustROI(self, dtop, dbottom, dleft, dright)

    def __call__(self, *args):
        return _landmarkDetector.Mat2d___call__(self, *args)

    def __init__(self, *args):
        this = _landmarkDetector.new_Mat2d(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    @classmethod
    def __check_channels_compatibility(cls, array):
        obj = cls()
        n_channel = obj.channels()

        if n_channel == 1:
            if len(array.shape) != 2:
                raise ValueError("{} expects a 2-dimensional numpy ndarray.".format(cls))
        else:
            if len(array.shape) != 3:
                raise ValueError("{} expects a 3-dimensional numpy ndarray.".format(cls))
            elif array.shape[2] != n_channel:
                raise ValueError("{} expects the last ndarray dimension to have a size of {}".format(cls, n_channel))

    @classmethod
    def from_array(cls, array):
        import numpy as np
        array = np.asarray(array)

        if cls()._typestr() != array.__array_interface__['typestr']:
            raise ValueError("{} expects a {} datatype.".format(cls, cls()._typestr()))

        cls.__check_channels_compatibility(array)

        new_mat = cls(_mat__np_array_constructor(),
                      array.shape[0],
                      array.shape[1],
                      array.__array_interface__['data'][0])

    # Holds an internal reference to keep the image buffer alive
        new_mat._array = array

        return new_mat


    def __str__(self):
        return _landmarkDetector.Mat2d___str__(self)
    __swig_destroy__ = _landmarkDetector.delete_Mat2d
    __del__ = lambda self: None
Mat2d_swigregister = _landmarkDetector.Mat2d_swigregister
Mat2d_swigregister(Mat2d)

class Mat2i(Mat):
    __swig_setmethods__ = {}
    for _s in [Mat]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Mat2i, name, value)
    __swig_getmethods__ = {}
    for _s in [Mat]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Mat2i, name)
    __repr__ = _swig_repr

    def create(self, *args):
        return _landmarkDetector.Mat2i_create(self, *args)

    def cross(self, m):
        return _landmarkDetector.Mat2i_cross(self, m)

    def row(self, y):
        return _landmarkDetector.Mat2i_row(self, y)

    def col(self, x):
        return _landmarkDetector.Mat2i_col(self, x)

    def diag(self, d=0):
        return _landmarkDetector.Mat2i_diag(self, d)

    def clone(self):
        return _landmarkDetector.Mat2i_clone(self)

    def elemSize(self):
        return _landmarkDetector.Mat2i_elemSize(self)

    def elemSize1(self):
        return _landmarkDetector.Mat2i_elemSize1(self)

    def type(self):
        return _landmarkDetector.Mat2i_type(self)

    def depth(self):
        return _landmarkDetector.Mat2i_depth(self)

    def channels(self):
        return _landmarkDetector.Mat2i_channels(self)

    def step1(self, i=0):
        return _landmarkDetector.Mat2i_step1(self, i)

    def stepT(self, i=0):
        return _landmarkDetector.Mat2i_stepT(self, i)

    def adjustROI(self, dtop, dbottom, dleft, dright):
        return _landmarkDetector.Mat2i_adjustROI(self, dtop, dbottom, dleft, dright)

    def __call__(self, *args):
        return _landmarkDetector.Mat2i___call__(self, *args)

    def __init__(self, *args):
        this = _landmarkDetector.new_Mat2i(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    @classmethod
    def __check_channels_compatibility(cls, array):
        obj = cls()
        n_channel = obj.channels()

        if n_channel == 1:
            if len(array.shape) != 2:
                raise ValueError("{} expects a 2-dimensional numpy ndarray.".format(cls))
        else:
            if len(array.shape) != 3:
                raise ValueError("{} expects a 3-dimensional numpy ndarray.".format(cls))
            elif array.shape[2] != n_channel:
                raise ValueError("{} expects the last ndarray dimension to have a size of {}".format(cls, n_channel))

    @classmethod
    def from_array(cls, array):
        import numpy as np
        array = np.asarray(array)

        if cls()._typestr() != array.__array_interface__['typestr']:
            raise ValueError("{} expects a {} datatype.".format(cls, cls()._typestr()))

        cls.__check_channels_compatibility(array)

        new_mat = cls(_mat__np_array_constructor(),
                      array.shape[0],
                      array.shape[1],
                      array.__array_interface__['data'][0])

    # Holds an internal reference to keep the image buffer alive
        new_mat._array = array

        return new_mat


    def __str__(self):
        return _landmarkDetector.Mat2i___str__(self)
    __swig_destroy__ = _landmarkDetector.delete_Mat2i
    __del__ = lambda self: None
Mat2i_swigregister = _landmarkDetector.Mat2i_swigregister
Mat2i_swigregister(Mat2i)

class Point3f(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Point3f, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Point3f, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _landmarkDetector.new_Point3f(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def dot(self, pt):
        return _landmarkDetector.Point3f_dot(self, pt)

    def ddot(self, pt):
        return _landmarkDetector.Point3f_ddot(self, pt)

    def cross(self, pt):
        return _landmarkDetector.Point3f_cross(self, pt)
    __swig_setmethods__["x"] = _landmarkDetector.Point3f_x_set
    __swig_getmethods__["x"] = _landmarkDetector.Point3f_x_get
    if _newclass:
        x = _swig_property(_landmarkDetector.Point3f_x_get, _landmarkDetector.Point3f_x_set)
    __swig_setmethods__["y"] = _landmarkDetector.Point3f_y_set
    __swig_getmethods__["y"] = _landmarkDetector.Point3f_y_get
    if _newclass:
        y = _swig_property(_landmarkDetector.Point3f_y_get, _landmarkDetector.Point3f_y_set)
    __swig_setmethods__["z"] = _landmarkDetector.Point3f_z_set
    __swig_getmethods__["z"] = _landmarkDetector.Point3f_z_get
    if _newclass:
        z = _swig_property(_landmarkDetector.Point3f_z_get, _landmarkDetector.Point3f_z_set)

    def __iter__(self):
        return iter((self.x, self.y,self.z))

    __swig_destroy__ = _landmarkDetector.delete_Point3f
    __del__ = lambda self: None
Point3f_swigregister = _landmarkDetector.Point3f_swigregister
Point3f_swigregister(Point3f)

class CCNF_neuron(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CCNF_neuron, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CCNF_neuron, name)
    __repr__ = _swig_repr
    __swig_setmethods__["neuron_type"] = _landmarkDetector.CCNF_neuron_neuron_type_set
    __swig_getmethods__["neuron_type"] = _landmarkDetector.CCNF_neuron_neuron_type_get
    if _newclass:
        neuron_type = _swig_property(_landmarkDetector.CCNF_neuron_neuron_type_get, _landmarkDetector.CCNF_neuron_neuron_type_set)
    __swig_setmethods__["norm_weights"] = _landmarkDetector.CCNF_neuron_norm_weights_set
    __swig_getmethods__["norm_weights"] = _landmarkDetector.CCNF_neuron_norm_weights_get
    if _newclass:
        norm_weights = _swig_property(_landmarkDetector.CCNF_neuron_norm_weights_get, _landmarkDetector.CCNF_neuron_norm_weights_set)
    __swig_setmethods__["bias"] = _landmarkDetector.CCNF_neuron_bias_set
    __swig_getmethods__["bias"] = _landmarkDetector.CCNF_neuron_bias_get
    if _newclass:
        bias = _swig_property(_landmarkDetector.CCNF_neuron_bias_get, _landmarkDetector.CCNF_neuron_bias_set)
    __swig_setmethods__["weights"] = _landmarkDetector.CCNF_neuron_weights_set
    __swig_getmethods__["weights"] = _landmarkDetector.CCNF_neuron_weights_get
    if _newclass:
        weights = _swig_property(_landmarkDetector.CCNF_neuron_weights_get, _landmarkDetector.CCNF_neuron_weights_set)
    __swig_setmethods__["weights_dfts"] = _landmarkDetector.CCNF_neuron_weights_dfts_set
    __swig_getmethods__["weights_dfts"] = _landmarkDetector.CCNF_neuron_weights_dfts_get
    if _newclass:
        weights_dfts = _swig_property(_landmarkDetector.CCNF_neuron_weights_dfts_get, _landmarkDetector.CCNF_neuron_weights_dfts_set)
    __swig_setmethods__["alpha"] = _landmarkDetector.CCNF_neuron_alpha_set
    __swig_getmethods__["alpha"] = _landmarkDetector.CCNF_neuron_alpha_get
    if _newclass:
        alpha = _swig_property(_landmarkDetector.CCNF_neuron_alpha_get, _landmarkDetector.CCNF_neuron_alpha_set)

    def __init__(self, *args):
        this = _landmarkDetector.new_CCNF_neuron(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Read(self, stream):
        return _landmarkDetector.CCNF_neuron_Read(self, stream)

    def Response(self, im, im_dft, integral_img, integral_img_sq, resp):
        return _landmarkDetector.CCNF_neuron_Response(self, im, im_dft, integral_img, integral_img_sq, resp)
    __swig_destroy__ = _landmarkDetector.delete_CCNF_neuron
    __del__ = lambda self: None
CCNF_neuron_swigregister = _landmarkDetector.CCNF_neuron_swigregister
CCNF_neuron_swigregister(CCNF_neuron)

class CCNF_patch_expert(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CCNF_patch_expert, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CCNF_patch_expert, name)
    __repr__ = _swig_repr
    __swig_setmethods__["width"] = _landmarkDetector.CCNF_patch_expert_width_set
    __swig_getmethods__["width"] = _landmarkDetector.CCNF_patch_expert_width_get
    if _newclass:
        width = _swig_property(_landmarkDetector.CCNF_patch_expert_width_get, _landmarkDetector.CCNF_patch_expert_width_set)
    __swig_setmethods__["height"] = _landmarkDetector.CCNF_patch_expert_height_set
    __swig_getmethods__["height"] = _landmarkDetector.CCNF_patch_expert_height_get
    if _newclass:
        height = _swig_property(_landmarkDetector.CCNF_patch_expert_height_get, _landmarkDetector.CCNF_patch_expert_height_set)
    __swig_setmethods__["neurons"] = _landmarkDetector.CCNF_patch_expert_neurons_set
    __swig_getmethods__["neurons"] = _landmarkDetector.CCNF_patch_expert_neurons_get
    if _newclass:
        neurons = _swig_property(_landmarkDetector.CCNF_patch_expert_neurons_get, _landmarkDetector.CCNF_patch_expert_neurons_set)
    __swig_setmethods__["window_sizes"] = _landmarkDetector.CCNF_patch_expert_window_sizes_set
    __swig_getmethods__["window_sizes"] = _landmarkDetector.CCNF_patch_expert_window_sizes_get
    if _newclass:
        window_sizes = _swig_property(_landmarkDetector.CCNF_patch_expert_window_sizes_get, _landmarkDetector.CCNF_patch_expert_window_sizes_set)
    __swig_setmethods__["Sigmas"] = _landmarkDetector.CCNF_patch_expert_Sigmas_set
    __swig_getmethods__["Sigmas"] = _landmarkDetector.CCNF_patch_expert_Sigmas_get
    if _newclass:
        Sigmas = _swig_property(_landmarkDetector.CCNF_patch_expert_Sigmas_get, _landmarkDetector.CCNF_patch_expert_Sigmas_set)
    __swig_setmethods__["betas"] = _landmarkDetector.CCNF_patch_expert_betas_set
    __swig_getmethods__["betas"] = _landmarkDetector.CCNF_patch_expert_betas_get
    if _newclass:
        betas = _swig_property(_landmarkDetector.CCNF_patch_expert_betas_get, _landmarkDetector.CCNF_patch_expert_betas_set)
    __swig_setmethods__["weight_matrix"] = _landmarkDetector.CCNF_patch_expert_weight_matrix_set
    __swig_getmethods__["weight_matrix"] = _landmarkDetector.CCNF_patch_expert_weight_matrix_get
    if _newclass:
        weight_matrix = _swig_property(_landmarkDetector.CCNF_patch_expert_weight_matrix_get, _landmarkDetector.CCNF_patch_expert_weight_matrix_set)
    __swig_setmethods__["patch_confidence"] = _landmarkDetector.CCNF_patch_expert_patch_confidence_set
    __swig_getmethods__["patch_confidence"] = _landmarkDetector.CCNF_patch_expert_patch_confidence_get
    if _newclass:
        patch_confidence = _swig_property(_landmarkDetector.CCNF_patch_expert_patch_confidence_get, _landmarkDetector.CCNF_patch_expert_patch_confidence_set)

    def __init__(self, *args):
        this = _landmarkDetector.new_CCNF_patch_expert(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Read(self, stream, window_sizes, sigma_components):
        return _landmarkDetector.CCNF_patch_expert_Read(self, stream, window_sizes, sigma_components)

    def Response(self, area_of_interest, response):
        return _landmarkDetector.CCNF_patch_expert_Response(self, area_of_interest, response)

    def ResponseOpenBlas(self, area_of_interest, response, im2col_prealloc):
        return _landmarkDetector.CCNF_patch_expert_ResponseOpenBlas(self, area_of_interest, response, im2col_prealloc)

    def ComputeSigmas(self, sigma_components, window_size):
        return _landmarkDetector.CCNF_patch_expert_ComputeSigmas(self, sigma_components, window_size)
    __swig_destroy__ = _landmarkDetector.delete_CCNF_patch_expert
    __del__ = lambda self: None
CCNF_patch_expert_swigregister = _landmarkDetector.CCNF_patch_expert_swigregister
CCNF_patch_expert_swigregister(CCNF_patch_expert)

class CEN_patch_expert(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CEN_patch_expert, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CEN_patch_expert, name)
    __repr__ = _swig_repr
    __swig_setmethods__["width_support"] = _landmarkDetector.CEN_patch_expert_width_support_set
    __swig_getmethods__["width_support"] = _landmarkDetector.CEN_patch_expert_width_support_get
    if _newclass:
        width_support = _swig_property(_landmarkDetector.CEN_patch_expert_width_support_get, _landmarkDetector.CEN_patch_expert_width_support_set)
    __swig_setmethods__["height_support"] = _landmarkDetector.CEN_patch_expert_height_support_set
    __swig_getmethods__["height_support"] = _landmarkDetector.CEN_patch_expert_height_support_get
    if _newclass:
        height_support = _swig_property(_landmarkDetector.CEN_patch_expert_height_support_get, _landmarkDetector.CEN_patch_expert_height_support_set)
    __swig_setmethods__["biases"] = _landmarkDetector.CEN_patch_expert_biases_set
    __swig_getmethods__["biases"] = _landmarkDetector.CEN_patch_expert_biases_get
    if _newclass:
        biases = _swig_property(_landmarkDetector.CEN_patch_expert_biases_get, _landmarkDetector.CEN_patch_expert_biases_set)
    __swig_setmethods__["weights"] = _landmarkDetector.CEN_patch_expert_weights_set
    __swig_getmethods__["weights"] = _landmarkDetector.CEN_patch_expert_weights_get
    if _newclass:
        weights = _swig_property(_landmarkDetector.CEN_patch_expert_weights_get, _landmarkDetector.CEN_patch_expert_weights_set)
    __swig_setmethods__["activation_function"] = _landmarkDetector.CEN_patch_expert_activation_function_set
    __swig_getmethods__["activation_function"] = _landmarkDetector.CEN_patch_expert_activation_function_get
    if _newclass:
        activation_function = _swig_property(_landmarkDetector.CEN_patch_expert_activation_function_get, _landmarkDetector.CEN_patch_expert_activation_function_set)
    __swig_setmethods__["confidence"] = _landmarkDetector.CEN_patch_expert_confidence_set
    __swig_getmethods__["confidence"] = _landmarkDetector.CEN_patch_expert_confidence_get
    if _newclass:
        confidence = _swig_property(_landmarkDetector.CEN_patch_expert_confidence_get, _landmarkDetector.CEN_patch_expert_confidence_set)

    def __init__(self, *args):
        this = _landmarkDetector.new_CEN_patch_expert(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Read(self, stream):
        return _landmarkDetector.CEN_patch_expert_Read(self, stream)

    def Response(self, area_of_interest, response):
        return _landmarkDetector.CEN_patch_expert_Response(self, area_of_interest, response)

    def ResponseInternal(self, response):
        return _landmarkDetector.CEN_patch_expert_ResponseInternal(self, response)

    def ResponseSparse(self, area_of_interest_left, area_of_interest_right, response_left, response_right, mapMatrix, im2col_prealloc_left, im2col_prealloc_right):
        return _landmarkDetector.CEN_patch_expert_ResponseSparse(self, area_of_interest_left, area_of_interest_right, response_left, response_right, mapMatrix, im2col_prealloc_left, im2col_prealloc_right)
    __swig_destroy__ = _landmarkDetector.delete_CEN_patch_expert
    __del__ = lambda self: None
CEN_patch_expert_swigregister = _landmarkDetector.CEN_patch_expert_swigregister
CEN_patch_expert_swigregister(CEN_patch_expert)


def interpolationMatrix(mapMatrix, response_height, response_width, input_width, input_height):
    return _landmarkDetector.interpolationMatrix(mapMatrix, response_height, response_width, input_width, input_height)
interpolationMatrix = _landmarkDetector.interpolationMatrix

def PReLU(input_output_maps, prelu_weights):
    return _landmarkDetector.PReLU(input_output_maps, prelu_weights)
PReLU = _landmarkDetector.PReLU

def fully_connected(outputs, input_maps, weights, biases):
    return _landmarkDetector.fully_connected(outputs, input_maps, weights, biases)
fully_connected = _landmarkDetector.fully_connected

def max_pooling(outputs, input_maps, stride_x, stride_y, kernel_size_x, kernel_size_y):
    return _landmarkDetector.max_pooling(outputs, input_maps, stride_x, stride_y, kernel_size_x, kernel_size_y)
max_pooling = _landmarkDetector.max_pooling

def convolution_fft2(outputs, input_maps, kernels, biases, precomp_dfts):
    return _landmarkDetector.convolution_fft2(outputs, input_maps, kernels, biases, precomp_dfts)
convolution_fft2 = _landmarkDetector.convolution_fft2

def convolution_direct_blas(outputs, input_maps, weight_matrix, height_k, width_k, pre_alloc_im2col):
    return _landmarkDetector.convolution_direct_blas(outputs, input_maps, weight_matrix, height_k, width_k, pre_alloc_im2col)
convolution_direct_blas = _landmarkDetector.convolution_direct_blas
class CNN(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CNN, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CNN, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _landmarkDetector.new_CNN(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Inference(self, input_img, direct=True, thread_safe=False):
        return _landmarkDetector.CNN_Inference(self, input_img, direct, thread_safe)

    def Read(self, location):
        return _landmarkDetector.CNN_Read(self, location)

    def ClearPrecomp(self):
        return _landmarkDetector.CNN_ClearPrecomp(self)

    def NumberOfLayers(self):
        return _landmarkDetector.CNN_NumberOfLayers(self)
    __swig_destroy__ = _landmarkDetector.delete_CNN
    __del__ = lambda self: None
CNN_swigregister = _landmarkDetector.CNN_swigregister
CNN_swigregister(CNN)

class FaceDetectorMTCNN(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, FaceDetectorMTCNN, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, FaceDetectorMTCNN, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _landmarkDetector.new_FaceDetectorMTCNN(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def DetectFaces(self, o_regions, input_img, o_confidences, min_face=60, t1=0.6, t2=0.7, t3=0.7):
        return _landmarkDetector.FaceDetectorMTCNN_DetectFaces(self, o_regions, input_img, o_confidences, min_face, t1, t2, t3)

    def Read(self, location):
        return _landmarkDetector.FaceDetectorMTCNN_Read(self, location)

    def empty(self):
        return _landmarkDetector.FaceDetectorMTCNN_empty(self)
    __swig_destroy__ = _landmarkDetector.delete_FaceDetectorMTCNN
    __del__ = lambda self: None
FaceDetectorMTCNN_swigregister = _landmarkDetector.FaceDetectorMTCNN_swigregister
FaceDetectorMTCNN_swigregister(FaceDetectorMTCNN)

class DetectionValidator(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, DetectionValidator, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, DetectionValidator, name)
    __repr__ = _swig_repr
    __swig_setmethods__["orientations"] = _landmarkDetector.DetectionValidator_orientations_set
    __swig_getmethods__["orientations"] = _landmarkDetector.DetectionValidator_orientations_get
    if _newclass:
        orientations = _swig_property(_landmarkDetector.DetectionValidator_orientations_get, _landmarkDetector.DetectionValidator_orientations_set)
    __swig_setmethods__["paws"] = _landmarkDetector.DetectionValidator_paws_set
    __swig_getmethods__["paws"] = _landmarkDetector.DetectionValidator_paws_get
    if _newclass:
        paws = _swig_property(_landmarkDetector.DetectionValidator_paws_get, _landmarkDetector.DetectionValidator_paws_set)
    __swig_setmethods__["cnn_convolutional_layers"] = _landmarkDetector.DetectionValidator_cnn_convolutional_layers_set
    __swig_getmethods__["cnn_convolutional_layers"] = _landmarkDetector.DetectionValidator_cnn_convolutional_layers_get
    if _newclass:
        cnn_convolutional_layers = _swig_property(_landmarkDetector.DetectionValidator_cnn_convolutional_layers_get, _landmarkDetector.DetectionValidator_cnn_convolutional_layers_set)
    __swig_setmethods__["cnn_convolutional_layers_weights"] = _landmarkDetector.DetectionValidator_cnn_convolutional_layers_weights_set
    __swig_getmethods__["cnn_convolutional_layers_weights"] = _landmarkDetector.DetectionValidator_cnn_convolutional_layers_weights_get
    if _newclass:
        cnn_convolutional_layers_weights = _swig_property(_landmarkDetector.DetectionValidator_cnn_convolutional_layers_weights_get, _landmarkDetector.DetectionValidator_cnn_convolutional_layers_weights_set)
    __swig_setmethods__["cnn_convolutional_layers_im2col_precomp"] = _landmarkDetector.DetectionValidator_cnn_convolutional_layers_im2col_precomp_set
    __swig_getmethods__["cnn_convolutional_layers_im2col_precomp"] = _landmarkDetector.DetectionValidator_cnn_convolutional_layers_im2col_precomp_get
    if _newclass:
        cnn_convolutional_layers_im2col_precomp = _swig_property(_landmarkDetector.DetectionValidator_cnn_convolutional_layers_im2col_precomp_get, _landmarkDetector.DetectionValidator_cnn_convolutional_layers_im2col_precomp_set)
    __swig_setmethods__["cnn_subsampling_layers"] = _landmarkDetector.DetectionValidator_cnn_subsampling_layers_set
    __swig_getmethods__["cnn_subsampling_layers"] = _landmarkDetector.DetectionValidator_cnn_subsampling_layers_get
    if _newclass:
        cnn_subsampling_layers = _swig_property(_landmarkDetector.DetectionValidator_cnn_subsampling_layers_get, _landmarkDetector.DetectionValidator_cnn_subsampling_layers_set)
    __swig_setmethods__["cnn_fully_connected_layers_weights"] = _landmarkDetector.DetectionValidator_cnn_fully_connected_layers_weights_set
    __swig_getmethods__["cnn_fully_connected_layers_weights"] = _landmarkDetector.DetectionValidator_cnn_fully_connected_layers_weights_get
    if _newclass:
        cnn_fully_connected_layers_weights = _swig_property(_landmarkDetector.DetectionValidator_cnn_fully_connected_layers_weights_get, _landmarkDetector.DetectionValidator_cnn_fully_connected_layers_weights_set)
    __swig_setmethods__["cnn_fully_connected_layers_biases"] = _landmarkDetector.DetectionValidator_cnn_fully_connected_layers_biases_set
    __swig_getmethods__["cnn_fully_connected_layers_biases"] = _landmarkDetector.DetectionValidator_cnn_fully_connected_layers_biases_get
    if _newclass:
        cnn_fully_connected_layers_biases = _swig_property(_landmarkDetector.DetectionValidator_cnn_fully_connected_layers_biases_get, _landmarkDetector.DetectionValidator_cnn_fully_connected_layers_biases_set)
    __swig_setmethods__["cnn_layer_types"] = _landmarkDetector.DetectionValidator_cnn_layer_types_set
    __swig_getmethods__["cnn_layer_types"] = _landmarkDetector.DetectionValidator_cnn_layer_types_get
    if _newclass:
        cnn_layer_types = _swig_property(_landmarkDetector.DetectionValidator_cnn_layer_types_get, _landmarkDetector.DetectionValidator_cnn_layer_types_set)
    __swig_setmethods__["mean_images"] = _landmarkDetector.DetectionValidator_mean_images_set
    __swig_getmethods__["mean_images"] = _landmarkDetector.DetectionValidator_mean_images_get
    if _newclass:
        mean_images = _swig_property(_landmarkDetector.DetectionValidator_mean_images_get, _landmarkDetector.DetectionValidator_mean_images_set)
    __swig_setmethods__["standard_deviations"] = _landmarkDetector.DetectionValidator_standard_deviations_set
    __swig_getmethods__["standard_deviations"] = _landmarkDetector.DetectionValidator_standard_deviations_get
    if _newclass:
        standard_deviations = _swig_property(_landmarkDetector.DetectionValidator_standard_deviations_get, _landmarkDetector.DetectionValidator_standard_deviations_set)

    def __init__(self, *args):
        this = _landmarkDetector.new_DetectionValidator(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Check(self, orientation, intensity_img, detected_landmarks):
        return _landmarkDetector.DetectionValidator_Check(self, orientation, intensity_img, detected_landmarks)

    def Read(self, location):
        return _landmarkDetector.DetectionValidator_Read(self, location)

    def GetViewId(self, orientation):
        return _landmarkDetector.DetectionValidator_GetViewId(self, orientation)
    __swig_destroy__ = _landmarkDetector.delete_DetectionValidator
    __del__ = lambda self: None
DetectionValidator_swigregister = _landmarkDetector.DetectionValidator_swigregister
DetectionValidator_swigregister(DetectionValidator)


def DetectLandmarksInVideo(*args):
    return _landmarkDetector.DetectLandmarksInVideo(*args)
DetectLandmarksInVideo = _landmarkDetector.DetectLandmarksInVideo

def DetectLandmarksInImage(*args):
    return _landmarkDetector.DetectLandmarksInImage(*args)
DetectLandmarksInImage = _landmarkDetector.DetectLandmarksInImage

def GetPose(clnf_model, fx, fy, cx, cy):
    return _landmarkDetector.GetPose(clnf_model, fx, fy, cx, cy)
GetPose = _landmarkDetector.GetPose

def testcv2():
    return _landmarkDetector.testcv2()
testcv2 = _landmarkDetector.testcv2

def GetPoseWRTCamera(clnf_model, fx, fy, cx, cy):
    return _landmarkDetector.GetPoseWRTCamera(clnf_model, fx, fy, cx, cy)
GetPoseWRTCamera = _landmarkDetector.GetPoseWRTCamera

def matchTemplate_m(input_img, img_dft, _integral_img, _integral_img_sq, templ, templ_dfts, result, method):
    return _landmarkDetector.matchTemplate_m(input_img, img_dft, _integral_img, _integral_img_sq, templ, templ_dfts, result, method)
matchTemplate_m = _landmarkDetector.matchTemplate_m

def ExtractBoundingBox(landmarks, min_x, max_x, min_y, max_y):
    return _landmarkDetector.ExtractBoundingBox(landmarks, min_x, max_x, min_y, max_y)
ExtractBoundingBox = _landmarkDetector.ExtractBoundingBox

def CalculateVisibleLandmarks(*args):
    return _landmarkDetector.CalculateVisibleLandmarks(*args)
CalculateVisibleLandmarks = _landmarkDetector.CalculateVisibleLandmarks

def CalculateVisibleEyeLandmarks(clnf_model):
    return _landmarkDetector.CalculateVisibleEyeLandmarks(clnf_model)
CalculateVisibleEyeLandmarks = _landmarkDetector.CalculateVisibleEyeLandmarks

def CalculateAllLandmarks(*args):
    return _landmarkDetector.CalculateAllLandmarks(*args)
CalculateAllLandmarks = _landmarkDetector.CalculateAllLandmarks

def CalculateAllEyeLandmarks(clnf_model):
    return _landmarkDetector.CalculateAllEyeLandmarks(clnf_model)
CalculateAllEyeLandmarks = _landmarkDetector.CalculateAllEyeLandmarks

def Calculate3DEyeLandmarks(clnf_model, fx, fy, cx, cy):
    return _landmarkDetector.Calculate3DEyeLandmarks(clnf_model, fx, fy, cx, cy)
Calculate3DEyeLandmarks = _landmarkDetector.Calculate3DEyeLandmarks

def DetectFaces(*args):
    return _landmarkDetector.DetectFaces(*args)
DetectFaces = _landmarkDetector.DetectFaces

def DetectSingleFace(*args):
    return _landmarkDetector.DetectSingleFace(*args)
DetectSingleFace = _landmarkDetector.DetectSingleFace

def DetectFacesHOG(*args):
    return _landmarkDetector.DetectFacesHOG(*args)
DetectFacesHOG = _landmarkDetector.DetectFacesHOG

def DetectSingleFaceHOG(*args):
    return _landmarkDetector.DetectSingleFaceHOG(*args)
DetectSingleFaceHOG = _landmarkDetector.DetectSingleFaceHOG

def DetectFacesMTCNN(o_regions, image, detector, confidences):
    return _landmarkDetector.DetectFacesMTCNN(o_regions, image, detector, confidences)
DetectFacesMTCNN = _landmarkDetector.DetectFacesMTCNN

def DetectSingleFaceMTCNN(*args):
    return _landmarkDetector.DetectSingleFaceMTCNN(*args)
DetectSingleFaceMTCNN = _landmarkDetector.DetectSingleFaceMTCNN

def ReadMatBin(stream, output_mat):
    return _landmarkDetector.ReadMatBin(stream, output_mat)
ReadMatBin = _landmarkDetector.ReadMatBin

def ReadMat(stream, output_matrix):
    return _landmarkDetector.ReadMat(stream, output_matrix)
ReadMat = _landmarkDetector.ReadMat

def SkipComments(stream):
    return _landmarkDetector.SkipComments(stream)
SkipComments = _landmarkDetector.SkipComments
class PAW(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, PAW, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, PAW, name)
    __repr__ = _swig_repr
    __swig_setmethods__["number_of_pixels"] = _landmarkDetector.PAW_number_of_pixels_set
    __swig_getmethods__["number_of_pixels"] = _landmarkDetector.PAW_number_of_pixels_get
    if _newclass:
        number_of_pixels = _swig_property(_landmarkDetector.PAW_number_of_pixels_get, _landmarkDetector.PAW_number_of_pixels_set)
    __swig_setmethods__["min_x"] = _landmarkDetector.PAW_min_x_set
    __swig_getmethods__["min_x"] = _landmarkDetector.PAW_min_x_get
    if _newclass:
        min_x = _swig_property(_landmarkDetector.PAW_min_x_get, _landmarkDetector.PAW_min_x_set)
    __swig_setmethods__["min_y"] = _landmarkDetector.PAW_min_y_set
    __swig_getmethods__["min_y"] = _landmarkDetector.PAW_min_y_get
    if _newclass:
        min_y = _swig_property(_landmarkDetector.PAW_min_y_get, _landmarkDetector.PAW_min_y_set)
    __swig_setmethods__["destination_landmarks"] = _landmarkDetector.PAW_destination_landmarks_set
    __swig_getmethods__["destination_landmarks"] = _landmarkDetector.PAW_destination_landmarks_get
    if _newclass:
        destination_landmarks = _swig_property(_landmarkDetector.PAW_destination_landmarks_get, _landmarkDetector.PAW_destination_landmarks_set)
    __swig_setmethods__["source_landmarks"] = _landmarkDetector.PAW_source_landmarks_set
    __swig_getmethods__["source_landmarks"] = _landmarkDetector.PAW_source_landmarks_get
    if _newclass:
        source_landmarks = _swig_property(_landmarkDetector.PAW_source_landmarks_get, _landmarkDetector.PAW_source_landmarks_set)
    __swig_setmethods__["triangulation"] = _landmarkDetector.PAW_triangulation_set
    __swig_getmethods__["triangulation"] = _landmarkDetector.PAW_triangulation_get
    if _newclass:
        triangulation = _swig_property(_landmarkDetector.PAW_triangulation_get, _landmarkDetector.PAW_triangulation_set)
    __swig_setmethods__["triangle_id"] = _landmarkDetector.PAW_triangle_id_set
    __swig_getmethods__["triangle_id"] = _landmarkDetector.PAW_triangle_id_get
    if _newclass:
        triangle_id = _swig_property(_landmarkDetector.PAW_triangle_id_get, _landmarkDetector.PAW_triangle_id_set)
    __swig_setmethods__["pixel_mask"] = _landmarkDetector.PAW_pixel_mask_set
    __swig_getmethods__["pixel_mask"] = _landmarkDetector.PAW_pixel_mask_get
    if _newclass:
        pixel_mask = _swig_property(_landmarkDetector.PAW_pixel_mask_get, _landmarkDetector.PAW_pixel_mask_set)
    __swig_setmethods__["coefficients"] = _landmarkDetector.PAW_coefficients_set
    __swig_getmethods__["coefficients"] = _landmarkDetector.PAW_coefficients_get
    if _newclass:
        coefficients = _swig_property(_landmarkDetector.PAW_coefficients_get, _landmarkDetector.PAW_coefficients_set)
    __swig_setmethods__["alpha"] = _landmarkDetector.PAW_alpha_set
    __swig_getmethods__["alpha"] = _landmarkDetector.PAW_alpha_get
    if _newclass:
        alpha = _swig_property(_landmarkDetector.PAW_alpha_get, _landmarkDetector.PAW_alpha_set)
    __swig_setmethods__["beta"] = _landmarkDetector.PAW_beta_set
    __swig_getmethods__["beta"] = _landmarkDetector.PAW_beta_get
    if _newclass:
        beta = _swig_property(_landmarkDetector.PAW_beta_get, _landmarkDetector.PAW_beta_set)
    __swig_setmethods__["map_x"] = _landmarkDetector.PAW_map_x_set
    __swig_getmethods__["map_x"] = _landmarkDetector.PAW_map_x_get
    if _newclass:
        map_x = _swig_property(_landmarkDetector.PAW_map_x_get, _landmarkDetector.PAW_map_x_set)
    __swig_setmethods__["map_y"] = _landmarkDetector.PAW_map_y_set
    __swig_getmethods__["map_y"] = _landmarkDetector.PAW_map_y_get
    if _newclass:
        map_y = _swig_property(_landmarkDetector.PAW_map_y_get, _landmarkDetector.PAW_map_y_set)

    def __init__(self, *args):
        this = _landmarkDetector.new_PAW(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Read(self, s):
        return _landmarkDetector.PAW_Read(self, s)

    def Warp(self, image_to_warp, destination_image, landmarks_to_warp):
        return _landmarkDetector.PAW_Warp(self, image_to_warp, destination_image, landmarks_to_warp)

    def CalcCoeff(self):
        return _landmarkDetector.PAW_CalcCoeff(self)

    def WarpRegion(self, map_x, map_y):
        return _landmarkDetector.PAW_WarpRegion(self, map_x, map_y)

    def NumberOfLandmarks(self):
        return _landmarkDetector.PAW_NumberOfLandmarks(self)

    def NumberOfTriangles(self):
        return _landmarkDetector.PAW_NumberOfTriangles(self)

    def constWidth(self):
        return _landmarkDetector.PAW_constWidth(self)

    def Height(self):
        return _landmarkDetector.PAW_Height(self)
    __swig_destroy__ = _landmarkDetector.delete_PAW
    __del__ = lambda self: None
PAW_swigregister = _landmarkDetector.PAW_swigregister
PAW_swigregister(PAW)

class PDM(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, PDM, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, PDM, name)
    __repr__ = _swig_repr
    __swig_setmethods__["mean_shape"] = _landmarkDetector.PDM_mean_shape_set
    __swig_getmethods__["mean_shape"] = _landmarkDetector.PDM_mean_shape_get
    if _newclass:
        mean_shape = _swig_property(_landmarkDetector.PDM_mean_shape_get, _landmarkDetector.PDM_mean_shape_set)
    __swig_setmethods__["princ_comp"] = _landmarkDetector.PDM_princ_comp_set
    __swig_getmethods__["princ_comp"] = _landmarkDetector.PDM_princ_comp_get
    if _newclass:
        princ_comp = _swig_property(_landmarkDetector.PDM_princ_comp_get, _landmarkDetector.PDM_princ_comp_set)
    __swig_setmethods__["eigen_values"] = _landmarkDetector.PDM_eigen_values_set
    __swig_getmethods__["eigen_values"] = _landmarkDetector.PDM_eigen_values_get
    if _newclass:
        eigen_values = _swig_property(_landmarkDetector.PDM_eigen_values_get, _landmarkDetector.PDM_eigen_values_set)

    def __init__(self, *args):
        this = _landmarkDetector.new_PDM(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Read(self, location):
        return _landmarkDetector.PDM_Read(self, location)

    def NumberOfPoints(self):
        return _landmarkDetector.PDM_NumberOfPoints(self)

    def NumberOfModes(self):
        return _landmarkDetector.PDM_NumberOfModes(self)

    def Clamp(self, params_local, params_global, params):
        return _landmarkDetector.PDM_Clamp(self, params_local, params_global, params)

    def CalcShape3D(self, out_shape, params_local):
        return _landmarkDetector.PDM_CalcShape3D(self, out_shape, params_local)

    def CalcShape2D(self, out_shape, params_local, params_global):
        return _landmarkDetector.PDM_CalcShape2D(self, out_shape, params_local, params_global)

    def CalcParams(self, *args):
        return _landmarkDetector.PDM_CalcParams(self, *args)

    def CalcBoundingBox(self, out_bounding_box, params_global, params_local):
        return _landmarkDetector.PDM_CalcBoundingBox(self, out_bounding_box, params_global, params_local)

    def ComputeRigidJacobian(self, params_local, params_global, Jacob, W, Jacob_t_w):
        return _landmarkDetector.PDM_ComputeRigidJacobian(self, params_local, params_global, Jacob, W, Jacob_t_w)

    def ComputeJacobian(self, params_local, params_global, Jacobian, W, Jacob_t_w):
        return _landmarkDetector.PDM_ComputeJacobian(self, params_local, params_global, Jacobian, W, Jacob_t_w)

    def UpdateModelParameters(self, delta_p, params_local, params_global):
        return _landmarkDetector.PDM_UpdateModelParameters(self, delta_p, params_local, params_global)
    __swig_destroy__ = _landmarkDetector.delete_PDM
    __del__ = lambda self: None
PDM_swigregister = _landmarkDetector.PDM_swigregister
PDM_swigregister(PDM)

class SVR_patch_expert(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SVR_patch_expert, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SVR_patch_expert, name)
    __repr__ = _swig_repr
    __swig_setmethods__["type"] = _landmarkDetector.SVR_patch_expert_type_set
    __swig_getmethods__["type"] = _landmarkDetector.SVR_patch_expert_type_get
    if _newclass:
        type = _swig_property(_landmarkDetector.SVR_patch_expert_type_get, _landmarkDetector.SVR_patch_expert_type_set)
    __swig_setmethods__["scaling"] = _landmarkDetector.SVR_patch_expert_scaling_set
    __swig_getmethods__["scaling"] = _landmarkDetector.SVR_patch_expert_scaling_get
    if _newclass:
        scaling = _swig_property(_landmarkDetector.SVR_patch_expert_scaling_get, _landmarkDetector.SVR_patch_expert_scaling_set)
    __swig_setmethods__["bias"] = _landmarkDetector.SVR_patch_expert_bias_set
    __swig_getmethods__["bias"] = _landmarkDetector.SVR_patch_expert_bias_get
    if _newclass:
        bias = _swig_property(_landmarkDetector.SVR_patch_expert_bias_get, _landmarkDetector.SVR_patch_expert_bias_set)
    __swig_setmethods__["weights"] = _landmarkDetector.SVR_patch_expert_weights_set
    __swig_getmethods__["weights"] = _landmarkDetector.SVR_patch_expert_weights_get
    if _newclass:
        weights = _swig_property(_landmarkDetector.SVR_patch_expert_weights_get, _landmarkDetector.SVR_patch_expert_weights_set)
    __swig_setmethods__["weights_dfts"] = _landmarkDetector.SVR_patch_expert_weights_dfts_set
    __swig_getmethods__["weights_dfts"] = _landmarkDetector.SVR_patch_expert_weights_dfts_get
    if _newclass:
        weights_dfts = _swig_property(_landmarkDetector.SVR_patch_expert_weights_dfts_get, _landmarkDetector.SVR_patch_expert_weights_dfts_set)
    __swig_setmethods__["confidence"] = _landmarkDetector.SVR_patch_expert_confidence_set
    __swig_getmethods__["confidence"] = _landmarkDetector.SVR_patch_expert_confidence_get
    if _newclass:
        confidence = _swig_property(_landmarkDetector.SVR_patch_expert_confidence_get, _landmarkDetector.SVR_patch_expert_confidence_set)

    def __init__(self, *args):
        this = _landmarkDetector.new_SVR_patch_expert(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Read(self, stream):
        return _landmarkDetector.SVR_patch_expert_Read(self, stream)

    def Response(self, area_of_interest, response):
        return _landmarkDetector.SVR_patch_expert_Response(self, area_of_interest, response)

    def ResponseDepth(self, area_of_interest, response):
        return _landmarkDetector.SVR_patch_expert_ResponseDepth(self, area_of_interest, response)
    __swig_destroy__ = _landmarkDetector.delete_SVR_patch_expert
    __del__ = lambda self: None
SVR_patch_expert_swigregister = _landmarkDetector.SVR_patch_expert_swigregister
SVR_patch_expert_swigregister(SVR_patch_expert)

class Multi_SVR_patch_expert(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Multi_SVR_patch_expert, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Multi_SVR_patch_expert, name)
    __repr__ = _swig_repr
    __swig_setmethods__["width"] = _landmarkDetector.Multi_SVR_patch_expert_width_set
    __swig_getmethods__["width"] = _landmarkDetector.Multi_SVR_patch_expert_width_get
    if _newclass:
        width = _swig_property(_landmarkDetector.Multi_SVR_patch_expert_width_get, _landmarkDetector.Multi_SVR_patch_expert_width_set)
    __swig_setmethods__["height"] = _landmarkDetector.Multi_SVR_patch_expert_height_set
    __swig_getmethods__["height"] = _landmarkDetector.Multi_SVR_patch_expert_height_get
    if _newclass:
        height = _swig_property(_landmarkDetector.Multi_SVR_patch_expert_height_get, _landmarkDetector.Multi_SVR_patch_expert_height_set)
    __swig_setmethods__["svr_patch_experts"] = _landmarkDetector.Multi_SVR_patch_expert_svr_patch_experts_set
    __swig_getmethods__["svr_patch_experts"] = _landmarkDetector.Multi_SVR_patch_expert_svr_patch_experts_get
    if _newclass:
        svr_patch_experts = _swig_property(_landmarkDetector.Multi_SVR_patch_expert_svr_patch_experts_get, _landmarkDetector.Multi_SVR_patch_expert_svr_patch_experts_set)

    def __init__(self, *args):
        this = _landmarkDetector.new_Multi_SVR_patch_expert(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Read(self, stream):
        return _landmarkDetector.Multi_SVR_patch_expert_Read(self, stream)

    def Response(self, area_of_interest, response):
        return _landmarkDetector.Multi_SVR_patch_expert_Response(self, area_of_interest, response)

    def ResponseDepth(self, area_of_interest, response):
        return _landmarkDetector.Multi_SVR_patch_expert_ResponseDepth(self, area_of_interest, response)
    __swig_destroy__ = _landmarkDetector.delete_Multi_SVR_patch_expert
    __del__ = lambda self: None
Multi_SVR_patch_expert_swigregister = _landmarkDetector.Multi_SVR_patch_expert_swigregister
Multi_SVR_patch_expert_swigregister(Multi_SVR_patch_expert)


def openblas_set_num_threads(num_threads):
    return _landmarkDetector.openblas_set_num_threads(num_threads)
openblas_set_num_threads = _landmarkDetector.openblas_set_num_threads

def sgemm_(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13):
    return _landmarkDetector.sgemm_(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13)
sgemm_ = _landmarkDetector.sgemm_
class CLNF(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CLNF, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CLNF, name)
    __repr__ = _swig_repr
    __swig_setmethods__["pdm"] = _landmarkDetector.CLNF_pdm_set
    __swig_getmethods__["pdm"] = _landmarkDetector.CLNF_pdm_get
    if _newclass:
        pdm = _swig_property(_landmarkDetector.CLNF_pdm_get, _landmarkDetector.CLNF_pdm_set)
    __swig_setmethods__["patch_experts"] = _landmarkDetector.CLNF_patch_experts_set
    __swig_getmethods__["patch_experts"] = _landmarkDetector.CLNF_patch_experts_get
    if _newclass:
        patch_experts = _swig_property(_landmarkDetector.CLNF_patch_experts_get, _landmarkDetector.CLNF_patch_experts_set)
    __swig_setmethods__["params_local"] = _landmarkDetector.CLNF_params_local_set
    __swig_getmethods__["params_local"] = _landmarkDetector.CLNF_params_local_get
    if _newclass:
        params_local = _swig_property(_landmarkDetector.CLNF_params_local_get, _landmarkDetector.CLNF_params_local_set)
    __swig_setmethods__["params_global"] = _landmarkDetector.CLNF_params_global_set
    __swig_getmethods__["params_global"] = _landmarkDetector.CLNF_params_global_get
    if _newclass:
        params_global = _swig_property(_landmarkDetector.CLNF_params_global_get, _landmarkDetector.CLNF_params_global_set)
    __swig_setmethods__["hierarchical_models"] = _landmarkDetector.CLNF_hierarchical_models_set
    __swig_getmethods__["hierarchical_models"] = _landmarkDetector.CLNF_hierarchical_models_get
    if _newclass:
        hierarchical_models = _swig_property(_landmarkDetector.CLNF_hierarchical_models_get, _landmarkDetector.CLNF_hierarchical_models_set)
    __swig_setmethods__["hierarchical_model_names"] = _landmarkDetector.CLNF_hierarchical_model_names_set
    __swig_getmethods__["hierarchical_model_names"] = _landmarkDetector.CLNF_hierarchical_model_names_get
    if _newclass:
        hierarchical_model_names = _swig_property(_landmarkDetector.CLNF_hierarchical_model_names_get, _landmarkDetector.CLNF_hierarchical_model_names_set)
    __swig_setmethods__["hierarchical_mapping"] = _landmarkDetector.CLNF_hierarchical_mapping_set
    __swig_getmethods__["hierarchical_mapping"] = _landmarkDetector.CLNF_hierarchical_mapping_get
    if _newclass:
        hierarchical_mapping = _swig_property(_landmarkDetector.CLNF_hierarchical_mapping_get, _landmarkDetector.CLNF_hierarchical_mapping_set)
    __swig_setmethods__["hierarchical_params"] = _landmarkDetector.CLNF_hierarchical_params_set
    __swig_getmethods__["hierarchical_params"] = _landmarkDetector.CLNF_hierarchical_params_get
    if _newclass:
        hierarchical_params = _swig_property(_landmarkDetector.CLNF_hierarchical_params_get, _landmarkDetector.CLNF_hierarchical_params_set)
    __swig_setmethods__["face_detector_HAAR"] = _landmarkDetector.CLNF_face_detector_HAAR_set
    __swig_getmethods__["face_detector_HAAR"] = _landmarkDetector.CLNF_face_detector_HAAR_get
    if _newclass:
        face_detector_HAAR = _swig_property(_landmarkDetector.CLNF_face_detector_HAAR_get, _landmarkDetector.CLNF_face_detector_HAAR_set)
    __swig_setmethods__["haar_face_detector_location"] = _landmarkDetector.CLNF_haar_face_detector_location_set
    __swig_getmethods__["haar_face_detector_location"] = _landmarkDetector.CLNF_haar_face_detector_location_get
    if _newclass:
        haar_face_detector_location = _swig_property(_landmarkDetector.CLNF_haar_face_detector_location_get, _landmarkDetector.CLNF_haar_face_detector_location_set)
    __swig_setmethods__["face_detector_HOG"] = _landmarkDetector.CLNF_face_detector_HOG_set
    __swig_getmethods__["face_detector_HOG"] = _landmarkDetector.CLNF_face_detector_HOG_get
    if _newclass:
        face_detector_HOG = _swig_property(_landmarkDetector.CLNF_face_detector_HOG_get, _landmarkDetector.CLNF_face_detector_HOG_set)
    __swig_setmethods__["face_detector_MTCNN"] = _landmarkDetector.CLNF_face_detector_MTCNN_set
    __swig_getmethods__["face_detector_MTCNN"] = _landmarkDetector.CLNF_face_detector_MTCNN_get
    if _newclass:
        face_detector_MTCNN = _swig_property(_landmarkDetector.CLNF_face_detector_MTCNN_get, _landmarkDetector.CLNF_face_detector_MTCNN_set)
    __swig_setmethods__["mtcnn_face_detector_location"] = _landmarkDetector.CLNF_mtcnn_face_detector_location_set
    __swig_getmethods__["mtcnn_face_detector_location"] = _landmarkDetector.CLNF_mtcnn_face_detector_location_get
    if _newclass:
        mtcnn_face_detector_location = _swig_property(_landmarkDetector.CLNF_mtcnn_face_detector_location_get, _landmarkDetector.CLNF_mtcnn_face_detector_location_set)
    __swig_setmethods__["landmark_validator"] = _landmarkDetector.CLNF_landmark_validator_set
    __swig_getmethods__["landmark_validator"] = _landmarkDetector.CLNF_landmark_validator_get
    if _newclass:
        landmark_validator = _swig_property(_landmarkDetector.CLNF_landmark_validator_get, _landmarkDetector.CLNF_landmark_validator_set)
    __swig_setmethods__["detection_success"] = _landmarkDetector.CLNF_detection_success_set
    __swig_getmethods__["detection_success"] = _landmarkDetector.CLNF_detection_success_get
    if _newclass:
        detection_success = _swig_property(_landmarkDetector.CLNF_detection_success_get, _landmarkDetector.CLNF_detection_success_set)
    __swig_setmethods__["tracking_initialised"] = _landmarkDetector.CLNF_tracking_initialised_set
    __swig_getmethods__["tracking_initialised"] = _landmarkDetector.CLNF_tracking_initialised_get
    if _newclass:
        tracking_initialised = _swig_property(_landmarkDetector.CLNF_tracking_initialised_get, _landmarkDetector.CLNF_tracking_initialised_set)
    __swig_setmethods__["detection_certainty"] = _landmarkDetector.CLNF_detection_certainty_set
    __swig_getmethods__["detection_certainty"] = _landmarkDetector.CLNF_detection_certainty_get
    if _newclass:
        detection_certainty = _swig_property(_landmarkDetector.CLNF_detection_certainty_get, _landmarkDetector.CLNF_detection_certainty_set)
    __swig_setmethods__["eye_model"] = _landmarkDetector.CLNF_eye_model_set
    __swig_getmethods__["eye_model"] = _landmarkDetector.CLNF_eye_model_get
    if _newclass:
        eye_model = _swig_property(_landmarkDetector.CLNF_eye_model_get, _landmarkDetector.CLNF_eye_model_set)
    __swig_setmethods__["triangulations"] = _landmarkDetector.CLNF_triangulations_set
    __swig_getmethods__["triangulations"] = _landmarkDetector.CLNF_triangulations_get
    if _newclass:
        triangulations = _swig_property(_landmarkDetector.CLNF_triangulations_get, _landmarkDetector.CLNF_triangulations_set)
    __swig_setmethods__["detected_landmarks"] = _landmarkDetector.CLNF_detected_landmarks_set
    __swig_getmethods__["detected_landmarks"] = _landmarkDetector.CLNF_detected_landmarks_get
    if _newclass:
        detected_landmarks = _swig_property(_landmarkDetector.CLNF_detected_landmarks_get, _landmarkDetector.CLNF_detected_landmarks_set)
    __swig_setmethods__["model_likelihood"] = _landmarkDetector.CLNF_model_likelihood_set
    __swig_getmethods__["model_likelihood"] = _landmarkDetector.CLNF_model_likelihood_get
    if _newclass:
        model_likelihood = _swig_property(_landmarkDetector.CLNF_model_likelihood_get, _landmarkDetector.CLNF_model_likelihood_set)
    __swig_setmethods__["landmark_likelihoods"] = _landmarkDetector.CLNF_landmark_likelihoods_set
    __swig_getmethods__["landmark_likelihoods"] = _landmarkDetector.CLNF_landmark_likelihoods_get
    if _newclass:
        landmark_likelihoods = _swig_property(_landmarkDetector.CLNF_landmark_likelihoods_get, _landmarkDetector.CLNF_landmark_likelihoods_set)
    __swig_setmethods__["failures_in_a_row"] = _landmarkDetector.CLNF_failures_in_a_row_set
    __swig_getmethods__["failures_in_a_row"] = _landmarkDetector.CLNF_failures_in_a_row_get
    if _newclass:
        failures_in_a_row = _swig_property(_landmarkDetector.CLNF_failures_in_a_row_get, _landmarkDetector.CLNF_failures_in_a_row_set)
    __swig_setmethods__["face_template"] = _landmarkDetector.CLNF_face_template_set
    __swig_getmethods__["face_template"] = _landmarkDetector.CLNF_face_template_get
    if _newclass:
        face_template = _swig_property(_landmarkDetector.CLNF_face_template_get, _landmarkDetector.CLNF_face_template_set)
    __swig_setmethods__["preference_det"] = _landmarkDetector.CLNF_preference_det_set
    __swig_getmethods__["preference_det"] = _landmarkDetector.CLNF_preference_det_get
    if _newclass:
        preference_det = _swig_property(_landmarkDetector.CLNF_preference_det_get, _landmarkDetector.CLNF_preference_det_set)
    __swig_setmethods__["view_used"] = _landmarkDetector.CLNF_view_used_set
    __swig_getmethods__["view_used"] = _landmarkDetector.CLNF_view_used_get
    if _newclass:
        view_used = _swig_property(_landmarkDetector.CLNF_view_used_get, _landmarkDetector.CLNF_view_used_set)
    __swig_setmethods__["loaded_successfully"] = _landmarkDetector.CLNF_loaded_successfully_set
    __swig_getmethods__["loaded_successfully"] = _landmarkDetector.CLNF_loaded_successfully_get
    if _newclass:
        loaded_successfully = _swig_property(_landmarkDetector.CLNF_loaded_successfully_get, _landmarkDetector.CLNF_loaded_successfully_set)
    __swig_destroy__ = _landmarkDetector.delete_CLNF
    __del__ = lambda self: None

    def __init__(self, *args):
        this = _landmarkDetector.new_CLNF(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def DetectLandmarks(self, image, params):
        return _landmarkDetector.CLNF_DetectLandmarks(self, image, params)

    def GetShape(self, *args):
        return _landmarkDetector.CLNF_GetShape(self, *args)

    def GetBoundingBox(self):
        return _landmarkDetector.CLNF_GetBoundingBox(self)

    def GetVisibilities(self):
        return _landmarkDetector.CLNF_GetVisibilities(self)

    def Reset(self, *args):
        return _landmarkDetector.CLNF_Reset(self, *args)

    def Read(self, name):
        return _landmarkDetector.CLNF_Read(self, name)

    def GetEyes0(self):
        return _landmarkDetector.CLNF_GetEyes0(self)

    def GetEyes1(self):
        return _landmarkDetector.CLNF_GetEyes1(self)

    def GetParamsLocal0(self):
        return _landmarkDetector.CLNF_GetParamsLocal0(self)

    def GetParamsLocal1(self):
        return _landmarkDetector.CLNF_GetParamsLocal1(self)

    def GetPdm0(self):
        return _landmarkDetector.CLNF_GetPdm0(self)

    def GetPdm1(self):
        return _landmarkDetector.CLNF_GetPdm1(self)
CLNF_swigregister = _landmarkDetector.CLNF_swigregister
CLNF_swigregister(CLNF)

class FaceModelParameters(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, FaceModelParameters, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, FaceModelParameters, name)
    __repr__ = _swig_repr
    __swig_setmethods__["num_optimisation_iteration"] = _landmarkDetector.FaceModelParameters_num_optimisation_iteration_set
    __swig_getmethods__["num_optimisation_iteration"] = _landmarkDetector.FaceModelParameters_num_optimisation_iteration_get
    if _newclass:
        num_optimisation_iteration = _swig_property(_landmarkDetector.FaceModelParameters_num_optimisation_iteration_get, _landmarkDetector.FaceModelParameters_num_optimisation_iteration_set)
    __swig_setmethods__["limit_pose"] = _landmarkDetector.FaceModelParameters_limit_pose_set
    __swig_getmethods__["limit_pose"] = _landmarkDetector.FaceModelParameters_limit_pose_get
    if _newclass:
        limit_pose = _swig_property(_landmarkDetector.FaceModelParameters_limit_pose_get, _landmarkDetector.FaceModelParameters_limit_pose_set)
    __swig_setmethods__["validate_detections"] = _landmarkDetector.FaceModelParameters_validate_detections_set
    __swig_getmethods__["validate_detections"] = _landmarkDetector.FaceModelParameters_validate_detections_get
    if _newclass:
        validate_detections = _swig_property(_landmarkDetector.FaceModelParameters_validate_detections_get, _landmarkDetector.FaceModelParameters_validate_detections_set)
    __swig_setmethods__["validation_boundary"] = _landmarkDetector.FaceModelParameters_validation_boundary_set
    __swig_getmethods__["validation_boundary"] = _landmarkDetector.FaceModelParameters_validation_boundary_get
    if _newclass:
        validation_boundary = _swig_property(_landmarkDetector.FaceModelParameters_validation_boundary_get, _landmarkDetector.FaceModelParameters_validation_boundary_set)
    __swig_setmethods__["window_sizes_small"] = _landmarkDetector.FaceModelParameters_window_sizes_small_set
    __swig_getmethods__["window_sizes_small"] = _landmarkDetector.FaceModelParameters_window_sizes_small_get
    if _newclass:
        window_sizes_small = _swig_property(_landmarkDetector.FaceModelParameters_window_sizes_small_get, _landmarkDetector.FaceModelParameters_window_sizes_small_set)
    __swig_setmethods__["window_sizes_init"] = _landmarkDetector.FaceModelParameters_window_sizes_init_set
    __swig_getmethods__["window_sizes_init"] = _landmarkDetector.FaceModelParameters_window_sizes_init_get
    if _newclass:
        window_sizes_init = _swig_property(_landmarkDetector.FaceModelParameters_window_sizes_init_get, _landmarkDetector.FaceModelParameters_window_sizes_init_set)
    __swig_setmethods__["window_sizes_current"] = _landmarkDetector.FaceModelParameters_window_sizes_current_set
    __swig_getmethods__["window_sizes_current"] = _landmarkDetector.FaceModelParameters_window_sizes_current_get
    if _newclass:
        window_sizes_current = _swig_property(_landmarkDetector.FaceModelParameters_window_sizes_current_get, _landmarkDetector.FaceModelParameters_window_sizes_current_set)
    __swig_setmethods__["face_template_scale"] = _landmarkDetector.FaceModelParameters_face_template_scale_set
    __swig_getmethods__["face_template_scale"] = _landmarkDetector.FaceModelParameters_face_template_scale_get
    if _newclass:
        face_template_scale = _swig_property(_landmarkDetector.FaceModelParameters_face_template_scale_get, _landmarkDetector.FaceModelParameters_face_template_scale_set)
    __swig_setmethods__["use_face_template"] = _landmarkDetector.FaceModelParameters_use_face_template_set
    __swig_getmethods__["use_face_template"] = _landmarkDetector.FaceModelParameters_use_face_template_get
    if _newclass:
        use_face_template = _swig_property(_landmarkDetector.FaceModelParameters_use_face_template_get, _landmarkDetector.FaceModelParameters_use_face_template_set)
    __swig_setmethods__["model_location"] = _landmarkDetector.FaceModelParameters_model_location_set
    __swig_getmethods__["model_location"] = _landmarkDetector.FaceModelParameters_model_location_get
    if _newclass:
        model_location = _swig_property(_landmarkDetector.FaceModelParameters_model_location_get, _landmarkDetector.FaceModelParameters_model_location_set)
    __swig_setmethods__["sigma"] = _landmarkDetector.FaceModelParameters_sigma_set
    __swig_getmethods__["sigma"] = _landmarkDetector.FaceModelParameters_sigma_get
    if _newclass:
        sigma = _swig_property(_landmarkDetector.FaceModelParameters_sigma_get, _landmarkDetector.FaceModelParameters_sigma_set)
    __swig_setmethods__["reg_factor"] = _landmarkDetector.FaceModelParameters_reg_factor_set
    __swig_getmethods__["reg_factor"] = _landmarkDetector.FaceModelParameters_reg_factor_get
    if _newclass:
        reg_factor = _swig_property(_landmarkDetector.FaceModelParameters_reg_factor_get, _landmarkDetector.FaceModelParameters_reg_factor_set)
    __swig_setmethods__["weight_factor"] = _landmarkDetector.FaceModelParameters_weight_factor_set
    __swig_getmethods__["weight_factor"] = _landmarkDetector.FaceModelParameters_weight_factor_get
    if _newclass:
        weight_factor = _swig_property(_landmarkDetector.FaceModelParameters_weight_factor_get, _landmarkDetector.FaceModelParameters_weight_factor_set)
    __swig_setmethods__["multi_view"] = _landmarkDetector.FaceModelParameters_multi_view_set
    __swig_getmethods__["multi_view"] = _landmarkDetector.FaceModelParameters_multi_view_get
    if _newclass:
        multi_view = _swig_property(_landmarkDetector.FaceModelParameters_multi_view_get, _landmarkDetector.FaceModelParameters_multi_view_set)
    CLM_DETECTOR = _landmarkDetector.FaceModelParameters_CLM_DETECTOR
    CLNF_DETECTOR = _landmarkDetector.FaceModelParameters_CLNF_DETECTOR
    CECLM_DETECTOR = _landmarkDetector.FaceModelParameters_CECLM_DETECTOR
    __swig_setmethods__["curr_landmark_detector"] = _landmarkDetector.FaceModelParameters_curr_landmark_detector_set
    __swig_getmethods__["curr_landmark_detector"] = _landmarkDetector.FaceModelParameters_curr_landmark_detector_get
    if _newclass:
        curr_landmark_detector = _swig_property(_landmarkDetector.FaceModelParameters_curr_landmark_detector_get, _landmarkDetector.FaceModelParameters_curr_landmark_detector_set)
    __swig_setmethods__["reinit_video_every"] = _landmarkDetector.FaceModelParameters_reinit_video_every_set
    __swig_getmethods__["reinit_video_every"] = _landmarkDetector.FaceModelParameters_reinit_video_every_get
    if _newclass:
        reinit_video_every = _swig_property(_landmarkDetector.FaceModelParameters_reinit_video_every_get, _landmarkDetector.FaceModelParameters_reinit_video_every_set)
    HAAR_DETECTOR = _landmarkDetector.FaceModelParameters_HAAR_DETECTOR
    HOG_SVM_DETECTOR = _landmarkDetector.FaceModelParameters_HOG_SVM_DETECTOR
    MTCNN_DETECTOR = _landmarkDetector.FaceModelParameters_MTCNN_DETECTOR
    __swig_setmethods__["haar_face_detector_location"] = _landmarkDetector.FaceModelParameters_haar_face_detector_location_set
    __swig_getmethods__["haar_face_detector_location"] = _landmarkDetector.FaceModelParameters_haar_face_detector_location_get
    if _newclass:
        haar_face_detector_location = _swig_property(_landmarkDetector.FaceModelParameters_haar_face_detector_location_get, _landmarkDetector.FaceModelParameters_haar_face_detector_location_set)
    __swig_setmethods__["mtcnn_face_detector_location"] = _landmarkDetector.FaceModelParameters_mtcnn_face_detector_location_set
    __swig_getmethods__["mtcnn_face_detector_location"] = _landmarkDetector.FaceModelParameters_mtcnn_face_detector_location_get
    if _newclass:
        mtcnn_face_detector_location = _swig_property(_landmarkDetector.FaceModelParameters_mtcnn_face_detector_location_get, _landmarkDetector.FaceModelParameters_mtcnn_face_detector_location_set)
    __swig_setmethods__["curr_face_detector"] = _landmarkDetector.FaceModelParameters_curr_face_detector_set
    __swig_getmethods__["curr_face_detector"] = _landmarkDetector.FaceModelParameters_curr_face_detector_get
    if _newclass:
        curr_face_detector = _swig_property(_landmarkDetector.FaceModelParameters_curr_face_detector_get, _landmarkDetector.FaceModelParameters_curr_face_detector_set)
    __swig_setmethods__["quiet_mode"] = _landmarkDetector.FaceModelParameters_quiet_mode_set
    __swig_getmethods__["quiet_mode"] = _landmarkDetector.FaceModelParameters_quiet_mode_get
    if _newclass:
        quiet_mode = _swig_property(_landmarkDetector.FaceModelParameters_quiet_mode_get, _landmarkDetector.FaceModelParameters_quiet_mode_set)
    __swig_setmethods__["refine_hierarchical"] = _landmarkDetector.FaceModelParameters_refine_hierarchical_set
    __swig_getmethods__["refine_hierarchical"] = _landmarkDetector.FaceModelParameters_refine_hierarchical_get
    if _newclass:
        refine_hierarchical = _swig_property(_landmarkDetector.FaceModelParameters_refine_hierarchical_get, _landmarkDetector.FaceModelParameters_refine_hierarchical_set)
    __swig_setmethods__["refine_parameters"] = _landmarkDetector.FaceModelParameters_refine_parameters_set
    __swig_getmethods__["refine_parameters"] = _landmarkDetector.FaceModelParameters_refine_parameters_get
    if _newclass:
        refine_parameters = _swig_property(_landmarkDetector.FaceModelParameters_refine_parameters_get, _landmarkDetector.FaceModelParameters_refine_parameters_set)

    def __init__(self, *args):
        this = _landmarkDetector.new_FaceModelParameters(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _landmarkDetector.delete_FaceModelParameters
    __del__ = lambda self: None
FaceModelParameters_swigregister = _landmarkDetector.FaceModelParameters_swigregister
FaceModelParameters_swigregister(FaceModelParameters)


def AlignFace(aligned_face, frame, detected_landmarks, params_global, pdm, rigid=True, scale=0.7, width=96, height=96):
    return _landmarkDetector.AlignFace(aligned_face, frame, detected_landmarks, params_global, pdm, rigid, scale, width, height)
AlignFace = _landmarkDetector.AlignFace

def AlignFaceMask(aligned_face, frame, detected_landmarks, params_global, pdm, triangulation, rigid=True, scale=0.7, width=96, height=96):
    return _landmarkDetector.AlignFaceMask(aligned_face, frame, detected_landmarks, params_global, pdm, triangulation, rigid, scale, width, height)
AlignFaceMask = _landmarkDetector.AlignFaceMask

def Extract_FHOG_descriptor(descriptor, image, num_rows, num_cols, cell_size=8):
    return _landmarkDetector.Extract_FHOG_descriptor(descriptor, image, num_rows, num_cols, cell_size)
Extract_FHOG_descriptor = _landmarkDetector.Extract_FHOG_descriptor

def ExtractSummaryStatistics(descriptors, sum_stats, mean, stdev, max_min):
    return _landmarkDetector.ExtractSummaryStatistics(descriptors, sum_stats, mean, stdev, max_min)
ExtractSummaryStatistics = _landmarkDetector.ExtractSummaryStatistics

def AddDescriptor(descriptors, new_descriptor, curr_frame, num_frames_to_keep=120):
    return _landmarkDetector.AddDescriptor(descriptors, new_descriptor, curr_frame, num_frames_to_keep)
AddDescriptor = _landmarkDetector.AddDescriptor
class FaceAnalyser(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, FaceAnalyser, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, FaceAnalyser, name)
    __repr__ = _swig_repr
    SVR_appearance_static_linear = _landmarkDetector.FaceAnalyser_SVR_appearance_static_linear
    SVR_appearance_dynamic_linear = _landmarkDetector.FaceAnalyser_SVR_appearance_dynamic_linear
    SVR_dynamic_geom_linear = _landmarkDetector.FaceAnalyser_SVR_dynamic_geom_linear
    SVR_combined_linear = _landmarkDetector.FaceAnalyser_SVR_combined_linear
    SVM_linear_stat = _landmarkDetector.FaceAnalyser_SVM_linear_stat
    SVM_linear_dyn = _landmarkDetector.FaceAnalyser_SVM_linear_dyn
    SVR_linear_static_seg = _landmarkDetector.FaceAnalyser_SVR_linear_static_seg
    SVR_linear_dynamic_seg = _landmarkDetector.FaceAnalyser_SVR_linear_dynamic_seg

    def __init__(self, face_analyser_params):
        this = _landmarkDetector.new_FaceAnalyser(face_analyser_params)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def AddNextFrame(self, frame, detected_landmarks, success, timestamp_seconds, online=False):
        return _landmarkDetector.FaceAnalyser_AddNextFrame(self, frame, detected_landmarks, success, timestamp_seconds, online)

    def GetCurrentTimeSeconds(self):
        return _landmarkDetector.FaceAnalyser_GetCurrentTimeSeconds(self)

    def GetCurrentAUsClass(self):
        return _landmarkDetector.FaceAnalyser_GetCurrentAUsClass(self)

    def GetCurrentAUsReg(self):
        return _landmarkDetector.FaceAnalyser_GetCurrentAUsReg(self)

    def GetCurrentAUsCombined(self):
        return _landmarkDetector.FaceAnalyser_GetCurrentAUsCombined(self)

    def PredictStaticAUsAndComputeFeatures(self, frame, detected_landmarks):
        return _landmarkDetector.FaceAnalyser_PredictStaticAUsAndComputeFeatures(self, frame, detected_landmarks)

    def Reset(self):
        return _landmarkDetector.FaceAnalyser_Reset(self)

    def GetLatestHOG(self, hog_descriptor, num_rows, num_cols):
        return _landmarkDetector.FaceAnalyser_GetLatestHOG(self, hog_descriptor, num_rows, num_cols)

    def GetLatestAlignedFace(self, image):
        return _landmarkDetector.FaceAnalyser_GetLatestAlignedFace(self, image)

    def GetLatestNeutralHOG(self, hog_descriptor, num_rows, num_cols):
        return _landmarkDetector.FaceAnalyser_GetLatestNeutralHOG(self, hog_descriptor, num_rows, num_cols)

    def GetTriangulation(self):
        return _landmarkDetector.FaceAnalyser_GetTriangulation(self)

    def GetGeomDescriptor(self, geom_desc):
        return _landmarkDetector.FaceAnalyser_GetGeomDescriptor(self, geom_desc)

    def GetAUClassNames(self):
        return _landmarkDetector.FaceAnalyser_GetAUClassNames(self)

    def GetAURegNames(self):
        return _landmarkDetector.FaceAnalyser_GetAURegNames(self)

    def GetDynamicAUClass(self):
        return _landmarkDetector.FaceAnalyser_GetDynamicAUClass(self)

    def GetDynamicAUReg(self):
        return _landmarkDetector.FaceAnalyser_GetDynamicAUReg(self)

    def ExtractAllPredictionsOfflineReg(self, au_predictions, confidences, successes, timestamps, dynamic):
        return _landmarkDetector.FaceAnalyser_ExtractAllPredictionsOfflineReg(self, au_predictions, confidences, successes, timestamps, dynamic)

    def ExtractAllPredictionsOfflineClass(self, au_predictions, confidences, successes, timestamps, dynamic):
        return _landmarkDetector.FaceAnalyser_ExtractAllPredictionsOfflineClass(self, au_predictions, confidences, successes, timestamps, dynamic)

    def PostprocessOutputFile(self, output_file):
        return _landmarkDetector.FaceAnalyser_PostprocessOutputFile(self, output_file)
    __swig_destroy__ = _landmarkDetector.delete_FaceAnalyser
    __del__ = lambda self: None
FaceAnalyser_swigregister = _landmarkDetector.FaceAnalyser_swigregister
FaceAnalyser_swigregister(FaceAnalyser)

class FaceAnalyserParameters(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, FaceAnalyserParameters, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, FaceAnalyserParameters, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _landmarkDetector.new_FaceAnalyserParameters(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_getmethods__["sim_scale_au"] = _landmarkDetector.FaceAnalyserParameters_sim_scale_au_get
    if _newclass:
        sim_scale_au = _swig_property(_landmarkDetector.FaceAnalyserParameters_sim_scale_au_get)
    __swig_getmethods__["sim_size_au"] = _landmarkDetector.FaceAnalyserParameters_sim_size_au_get
    if _newclass:
        sim_size_au = _swig_property(_landmarkDetector.FaceAnalyserParameters_sim_size_au_get)
    __swig_setmethods__["grayscale"] = _landmarkDetector.FaceAnalyserParameters_grayscale_set
    __swig_getmethods__["grayscale"] = _landmarkDetector.FaceAnalyserParameters_grayscale_get
    if _newclass:
        grayscale = _swig_property(_landmarkDetector.FaceAnalyserParameters_grayscale_get, _landmarkDetector.FaceAnalyserParameters_grayscale_set)

    def setAlignedOutput(self, output_size, scale=-1, masked=True):
        return _landmarkDetector.FaceAnalyserParameters_setAlignedOutput(self, output_size, scale, masked)

    def OptimizeForVideos(self):
        return _landmarkDetector.FaceAnalyserParameters_OptimizeForVideos(self)

    def OptimizeForImages(self):
        return _landmarkDetector.FaceAnalyserParameters_OptimizeForImages(self)

    def getAlignMask(self):
        return _landmarkDetector.FaceAnalyserParameters_getAlignMask(self)

    def getSimScaleOut(self):
        return _landmarkDetector.FaceAnalyserParameters_getSimScaleOut(self)

    def getSimSizeOut(self):
        return _landmarkDetector.FaceAnalyserParameters_getSimSizeOut(self)

    def getDynamic(self):
        return _landmarkDetector.FaceAnalyserParameters_getDynamic(self)

    def getModelLoc(self):
        return _landmarkDetector.FaceAnalyserParameters_getModelLoc(self)

    def getOrientationBins(self):
        return _landmarkDetector.FaceAnalyserParameters_getOrientationBins(self)
    __swig_destroy__ = _landmarkDetector.delete_FaceAnalyserParameters
    __del__ = lambda self: None
FaceAnalyserParameters_swigregister = _landmarkDetector.FaceAnalyserParameters_swigregister
FaceAnalyserParameters_swigregister(FaceAnalyserParameters)

class SVM_dynamic_lin(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SVM_dynamic_lin, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SVM_dynamic_lin, name)
    __repr__ = _swig_repr

    def __init__(self):
        this = _landmarkDetector.new_SVM_dynamic_lin()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Predict(self, predictions, names, fhog_descriptor, geom_params, running_median, running_median_geom):
        return _landmarkDetector.SVM_dynamic_lin_Predict(self, predictions, names, fhog_descriptor, geom_params, running_median, running_median_geom)

    def Read(self, stream, au_names):
        return _landmarkDetector.SVM_dynamic_lin_Read(self, stream, au_names)

    def GetAUNames(self):
        return _landmarkDetector.SVM_dynamic_lin_GetAUNames(self)
    __swig_destroy__ = _landmarkDetector.delete_SVM_dynamic_lin
    __del__ = lambda self: None
SVM_dynamic_lin_swigregister = _landmarkDetector.SVM_dynamic_lin_swigregister
SVM_dynamic_lin_swigregister(SVM_dynamic_lin)

class SVM_static_lin(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SVM_static_lin, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SVM_static_lin, name)
    __repr__ = _swig_repr

    def __init__(self):
        this = _landmarkDetector.new_SVM_static_lin()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Predict(self, predictions, names, fhog_descriptor, geom_params):
        return _landmarkDetector.SVM_static_lin_Predict(self, predictions, names, fhog_descriptor, geom_params)

    def Read(self, stream, au_names):
        return _landmarkDetector.SVM_static_lin_Read(self, stream, au_names)

    def GetAUNames(self):
        return _landmarkDetector.SVM_static_lin_GetAUNames(self)
    __swig_destroy__ = _landmarkDetector.delete_SVM_static_lin
    __del__ = lambda self: None
SVM_static_lin_swigregister = _landmarkDetector.SVM_static_lin_swigregister
SVM_static_lin_swigregister(SVM_static_lin)

class SVR_dynamic_lin_regressors(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SVR_dynamic_lin_regressors, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SVR_dynamic_lin_regressors, name)
    __repr__ = _swig_repr

    def __init__(self):
        this = _landmarkDetector.new_SVR_dynamic_lin_regressors()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Predict(self, predictions, names, descriptor, geom_params, running_median, running_median_geom):
        return _landmarkDetector.SVR_dynamic_lin_regressors_Predict(self, predictions, names, descriptor, geom_params, running_median, running_median_geom)

    def Read(self, stream, au_names):
        return _landmarkDetector.SVR_dynamic_lin_regressors_Read(self, stream, au_names)

    def GetAUNames(self):
        return _landmarkDetector.SVR_dynamic_lin_regressors_GetAUNames(self)

    def GetCutoffs(self):
        return _landmarkDetector.SVR_dynamic_lin_regressors_GetCutoffs(self)
    __swig_destroy__ = _landmarkDetector.delete_SVR_dynamic_lin_regressors
    __del__ = lambda self: None
SVR_dynamic_lin_regressors_swigregister = _landmarkDetector.SVR_dynamic_lin_regressors_swigregister
SVR_dynamic_lin_regressors_swigregister(SVR_dynamic_lin_regressors)

class SVR_static_lin_regressors(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SVR_static_lin_regressors, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SVR_static_lin_regressors, name)
    __repr__ = _swig_repr

    def __init__(self):
        this = _landmarkDetector.new_SVR_static_lin_regressors()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Predict(self, predictions, names, fhog_descriptor, geom_params):
        return _landmarkDetector.SVR_static_lin_regressors_Predict(self, predictions, names, fhog_descriptor, geom_params)

    def Read(self, stream, au_names):
        return _landmarkDetector.SVR_static_lin_regressors_Read(self, stream, au_names)

    def GetAUNames(self):
        return _landmarkDetector.SVR_static_lin_regressors_GetAUNames(self)
    __swig_destroy__ = _landmarkDetector.delete_SVR_static_lin_regressors
    __del__ = lambda self: None
SVR_static_lin_regressors_swigregister = _landmarkDetector.SVR_static_lin_regressors_swigregister
SVR_static_lin_regressors_swigregister(SVR_static_lin_regressors)


def EstimateGaze(clnf_model, gaze_absolute, fx, fy, cx, cy, left_eye):
    return _landmarkDetector.EstimateGaze(clnf_model, gaze_absolute, fx, fy, cx, cy, left_eye)
EstimateGaze = _landmarkDetector.EstimateGaze

def GetGazeAngle(gaze_vector_1, gaze_vector_2):
    return _landmarkDetector.GetGazeAngle(gaze_vector_1, gaze_vector_2)
GetGazeAngle = _landmarkDetector.GetGazeAngle

def GetPupilPosition(eyeLdmks3d):
    return _landmarkDetector.GetPupilPosition(eyeLdmks3d)
GetPupilPosition = _landmarkDetector.GetPupilPosition
# This file is compatible with both classic and new-style classes.


